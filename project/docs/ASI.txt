<page>
  <title>The ASI Network</title>
  <url>https://network.fetch.ai</url>
  <content>Introduction[](#introduction)
-----------------------------

The **ASI Network** represents the foundation of the ASI Ecosystem as it enables the decentralized digital economy driven by [Agents](https://uagents.fetch.ai/docs/) , [Agentverse](https://agentverse.ai/docs)  and [ASI-1 Mini](https://docs.asi1.ai/docs) . The Network provides integration with blockchain technology and ensures security, transparency, and scalability of transactions, and enhanced trust across the overall Ecosystem.

### The Almanac Contract[](#the-almanac-contract)

The [Almanac Contract](https://network.fetch.ai/docs/introduction/almanac/introduction) is an important component within the ASI Network. It connects together Agents and the Agentverse by working as decentralized registry and allowing for Agents discoverability and coordination. Whenever Agents are registered in the Almanac, they become accessible across the entire ASI Ecosystem, allowing the system, and [ASI-1 Mini](https://docs.asi1.ai/docs) , to dynamically locate and engage with them based on users’ or Agents’ requests and queries. This ensures the accurate and reliable execution of objectives, as the Almanac supports the identification and deployment of the most appropriate Agents for any given function being requested for execution, amongst all those registered Agents in the Agentverse and ASI Network.

The Almanac facilitates remote communication between agents but also provides a layer of trust and verification, ensuring that accurate and up-to-date information is available at all times for everybody. By maintaining an organized directory of Agents and their functions, the Almanac empowers the complex multi-Agent workflows efficiently.

### Fetch Name Service - FNS[](#fetch-name-service---fns)

The [Fetch Name Service (FNS)](https://uagents.fetch.ai/docs/guides/name-service)  is another key element providing human-readable names for interacting with Agents and Functions. The FNS simplifies resource identification and makes it easier for developers and users to access agents and functions and thus enhancing overall user accessibility.

### Fetch Ledger[](#fetch-ledger)

The [Fetch Ledger](https://network.fetch.ai/docs/introduction/ledger/ledger-intro) is an additional central component of the ASI Network. It provides a secure, decentralized, and transparent record of all transactions and data exchanges that take place within the ASI Ecosystem itself. The Ledger uses the [FET token](https://network.fetch.ai/docs/introduction/native-and-erc-fet) to facilitate transactions, agent interactions, and smart contracts execution, but it also to ensure that the integrity and efficiency of the Network is maintained.

### Jenesis[](#jenesis)

An additional tool is [Jenesis](https://network.fetch.ai/docs/guides/jenesis/getting-started); it simplifies the development and deployment of smart contracts and decentralized applications (i.e., dApps) on the ASI Network and other CosmWasm-enabled platforms. Jenesis offers a streamlined environment for developers that reduces the complexity of building blockchain-based solutions and accelerates the deployment of decentralized services and applications.

### CosmPy[](#cosmpy)

As a complementary tool to the above ones, [CosmPy](https://network.fetch.ai/docs/guides/cosmpy/installation) is a Python-based library that facilitates interactions with Cosmos SDK-based blockchains, including the ASI Network. CosmPy provides developers with a straightforward way to manage blockchain transactions, write and test smart contracts but also interact with agents; all within the familiar Python environment.

### Conclusions[](#conclusions)

These components together constitute the backbone structure of the ASI Network. These tools are essential in enabling a decentralized economy of autonomous Agents and AI-driven Agent services. By leveraging the Fetch Ledger, Almanac Contract, FNS, Jenesis, and CosmPy, the ASI Network focuses on creating an environment where agents can autonomously manage tasks, interact with each other, and create value in a secure and scalable way.

The FET token empowers the ASI Ecosystem, providing the economic incentive and governance framework necessary for the sustainability and evolution of the Network itself. The token acts both as the medium of exchange and the incentive structure for participants, while supporting the Network’s governance and staking mechanisms.</content>
</page>

<page>
  <title>The ASI Network</title>
  <url>https://network.fetch.ai/docs</url>
  <content>Introduction[](#introduction)
-----------------------------

The **ASI Network** represents the foundation of the ASI Ecosystem as it enables the decentralized digital economy driven by [Agents](https://uagents.fetch.ai/docs/) , [Agentverse](https://agentverse.ai/docs)  and [ASI-1 Mini](https://docs.asi1.ai/docs) . The Network provides integration with blockchain technology and ensures security, transparency, and scalability of transactions, and enhanced trust across the overall Ecosystem.

### The Almanac Contract[](#the-almanac-contract)

The [Almanac Contract](https://network.fetch.ai/docs/introduction/almanac/introduction) is an important component within the ASI Network. It connects together Agents and the Agentverse by working as decentralized registry and allowing for Agents discoverability and coordination. Whenever Agents are registered in the Almanac, they become accessible across the entire ASI Ecosystem, allowing the system, and [ASI-1 Mini](https://docs.asi1.ai/docs) , to dynamically locate and engage with them based on users’ or Agents’ requests and queries. This ensures the accurate and reliable execution of objectives, as the Almanac supports the identification and deployment of the most appropriate Agents for any given function being requested for execution, amongst all those registered Agents in the Agentverse and ASI Network.

The Almanac facilitates remote communication between agents but also provides a layer of trust and verification, ensuring that accurate and up-to-date information is available at all times for everybody. By maintaining an organized directory of Agents and their functions, the Almanac empowers the complex multi-Agent workflows efficiently.

### Fetch Name Service - FNS[](#fetch-name-service---fns)

The [Fetch Name Service (FNS)](https://uagents.fetch.ai/docs/guides/name-service)  is another key element providing human-readable names for interacting with Agents and Functions. The FNS simplifies resource identification and makes it easier for developers and users to access agents and functions and thus enhancing overall user accessibility.

### Fetch Ledger[](#fetch-ledger)

The [Fetch Ledger](https://network.fetch.ai/docs/introduction/ledger/ledger-intro) is an additional central component of the ASI Network. It provides a secure, decentralized, and transparent record of all transactions and data exchanges that take place within the ASI Ecosystem itself. The Ledger uses the [FET token](https://network.fetch.ai/docs/introduction/native-and-erc-fet) to facilitate transactions, agent interactions, and smart contracts execution, but it also to ensure that the integrity and efficiency of the Network is maintained.

### Jenesis[](#jenesis)

An additional tool is [Jenesis](https://network.fetch.ai/docs/guides/jenesis/getting-started); it simplifies the development and deployment of smart contracts and decentralized applications (i.e., dApps) on the ASI Network and other CosmWasm-enabled platforms. Jenesis offers a streamlined environment for developers that reduces the complexity of building blockchain-based solutions and accelerates the deployment of decentralized services and applications.

### CosmPy[](#cosmpy)

As a complementary tool to the above ones, [CosmPy](https://network.fetch.ai/docs/guides/cosmpy/installation) is a Python-based library that facilitates interactions with Cosmos SDK-based blockchains, including the ASI Network. CosmPy provides developers with a straightforward way to manage blockchain transactions, write and test smart contracts but also interact with agents; all within the familiar Python environment.

### Conclusions[](#conclusions)

These components together constitute the backbone structure of the ASI Network. These tools are essential in enabling a decentralized economy of autonomous Agents and AI-driven Agent services. By leveraging the Fetch Ledger, Almanac Contract, FNS, Jenesis, and CosmPy, the ASI Network focuses on creating an environment where agents can autonomously manage tasks, interact with each other, and create value in a secure and scalable way.

The FET token empowers the ASI Ecosystem, providing the economic incentive and governance framework necessary for the sustainability and evolution of the Network itself. The token acts both as the medium of exchange and the incentive structure for participants, while supporting the Network’s governance and staking mechanisms.</content>
</page>

<page>
  <title>Page</title>
  <url>https://network.fetch.ai/docs/introduction/native-and-erc-fet</url>
  <content>Native and ERC-20 FET tokens[](#native-and-erc-20-fet-tokens)
-------------------------------------------------------------

The Fetch.ai (FET) token is the utility token and the key medium of exchange on the Fetch.ai network. FET can be used to pay for services in the ASI ecosystem and network transaction fees. Users can also choose to stake FET to participate in securing the network via its Proof-of-Stake (PoS) consensus mechanism and earn rewards in return for contributing to [validator](https://network.fetch.ai/docs/introduction/ledger/validators) nodes.

The Fetch.ai team initially developed the FET utility token on an [ERC-20 contract](https://etherscan.io/token/0xaea46A60368A7bD060eec7DF8CBa43b7EF41Ad85)  on the Ethereum network while finishing the work on the Fetch.ai native main network (Main-net). This helped developers across the world get their hands on the FET tokens earlier and kickstart the process of developing innovative solutions within the ASI ecosystem. FET, as an ERC-20 token on the Ethereum contract has never been Fetch.ai’s end game because the Ethereum chain does not offer the degree of scalability needed by the kinds of applications the ASI ecosystem aims for.

With the launch of the Fetch.ai Mainnet, the native FET became available. This meant that users operating on the Fetch.ai network no longer needed to hold any token (e.g. ETH or BTC) associated with any other network. It is only the native FET token that fuels the ASI ecosystem and its applications.

ERC-20 FET tokens are still in circulation and currently co-exist with native FET tokens and can be [transferred from one to the other](https://network.fetch.ai/docs/guides/network/how-to-convert-fet-to-and-from-erc20) easily on the Fetch.ai network. All of the ERC-20 FET tokens will ultimately become native FET tokens, but in the foreseeable future both will live side by side. FET tokens can be purchased from different [centralized or decentralized exchanges](https://coinmarketcap.com/currencies/fetch/#Markets) .

However, keep in mind that certain exchanges may buy or sell one type of FET or the other.

Last updated on

May 14, 2025

[Setting up the ASI Alliance extension wallet with a Ledger hardware wallet](https://network.fetch.ai/docs/guides/asi-wallet/asi-wallet-hardware-connection-guide "Setting up the ASI Alliance extension wallet with a Ledger hardware wallet")</content>
</page>

<page>
  <title>How to convert native FET to and from ERC-20 FET</title>
  <url>https://network.fetch.ai/docs/guides/network/how-to-convert-fet-to-and-from-erc20</url>
  <content>On this page you can find instructions on how to convert ERC-20 to native FETs and viceversa. Visit the [Native and ERC-20 FET tokens](https://network.fetch.ai/docs/introduction/native-and-erc-fet) page to understand the difference between the two tokens.

**Let’s get started!**

Native to ERC-20 FET[](#native-to-erc-20-fet)
---------------------------------------------

1.  Ensure you have the [ASI Alliance Wallet installed](https://network.fetch.ai/docs/guides/asi-wallet/web-wallet/get-started) and that the native FETs you want to convert are in this wallet.
2.  Ensure you have the [Metamask wallet](https://metamask.io/)  installed and that your Ethereum account is set up on it. This is where the ERC-20 FETs will go to.
3.  Go to the [Token Bridge](https://token-bridge.fetch.ai/) .
4.  Unlock the Metamask wallet if instructed to do so.
5.  Ensure the **Native to ERC-20** tab is selected.
6.  Hit **Connect Browser Wallet** and allow the token bridge to connect to your ASI Alliance Wallet.
7.  The fields will be automatically populated with the addresses on the two wallets. Ensure these are correct.
8.  Under **Amount**, enter the amount of tokens you wish to convert.
9.  Hit **Transfer**.

ERC-20 to Native FET[](#erc-20-to-native-fet)
---------------------------------------------

1.  Ensure you have the [Metamask wallet](https://metamask.io/)  installed and that the ERC-20 FETs you want to convert are in this wallet.
2.  Ensure you have the [ASI Alliance Wallet installed](https://network.fetch.ai/docs/guides/asi-wallet/web-wallet/get-started) and that your Fetch.ai account is set up on it. This is where the native FETs will go to.
3.  Go to the [Token Bridge](https://token-bridge.fetch.ai/) .
4.  Unlock the Metamask wallet if instructed to do so.
5.  Ensure the **ERC-20 to Native** tab is selected.
6.  The Ethereum address should be automatically filled in with the address of the active account on your Metamask wallet. Ensure that it is correct.
7.  Insert your ASI Alliance Wallet address in the **Native Address** section.
8.  Under **Amount**, enter the amount of tokens you wish to convert.
9.  Hit **Transfer** and allow the Token Bridge to connect with your wallet.

Last updated on

May 14, 2025

[Registration and endpoints weighting](https://network.fetch.ai/docs/introduction/almanac/endpoints "Registration and endpoints weighting")</content>
</page>

<page>
  <title>How to stake FET with the ASI Alliance Wallet</title>
  <url>https://network.fetch.ai/docs/guides/network/how-to-stake</url>
  <content>Staking is the process of delegating to a validator. Delegators bond their funds to validator nodes and in doing so support the security and longevity of the network.

As a consequence of the provided support for the network delegators receive rewards in the form of FET. Rewards are paid on a per-block basis and added to the existing rewards.

ℹ️

Your funds never leave your wallet throughout the staking duration. You can remove your stake at any time. Once you remove your stake you’ll have to wait for 21 days before your FET is available. This is the standard waiting time across Cosmos SDK based blockchain projects and acts as a security measure for the network.

Additional information on different ways to stake FET tokens can be found [here](https://network.fetch.ai/docs/guides/network/different-ways-to-stake-the-fet-token). Also, checkout the following guides for a better understanding of the staking process both on **ASI Alliance Web** and **Mobile** Wallet:

*   [Stake on ASI Alliance Mobile Wallet](https://network.fetch.ai/docs/guides/asi-wallet/mobile-wallet/stake)
*   [Stake on ASI Alliance Web Wallet](https://network.fetch.ai/docs/guides/asi-wallet/web-wallet/stake)

Staking[](#staking)
-------------------

1.  Download and install the ASI Alliance browser extension wallet [ASI Alliance Wallet](https://fetch.ai/get-fetch-wallet)  .
    
2.  If this is your first time setting up the wallet select the **Create new account** option. If you have an existing account select the **Import existing account** option and restore your wallet by inputting your seed phrase. If you’re using a ledger hardware wallet select the **Connect ledger** option.
    
    ℹ️
    
    Here, you will find a list of every active [validator](https://network.fetch.ai/concepts/fetch-network/ledger/validators) with whom you can stake your FETs. You can also see the amount of FET staked to each validator and their commission rates.
    
    The validators on this page are ordered according to the number of FETs delegated to them and not their reputation or benefits. Visit the [Choosing a validator](https://network.fetch.ai/docs/guides/network/re-delegating-staked-fet-token#choosing-a-validator) section for further details on key points to be considered when choosing a validator.
    
3.  Log into the wallet and select **Stake** . This will open up the staking interface. Here you can browse all validators and select one or multiple validators to stake with.
    
    ℹ️
    
    You can check the details of any validator, including their _voting power_, _self-bonded rate_, _uptime_, _active/inactive status_ at any given time, as well as _contact information_, by heading over to [this page](https://explore.fetch.ai/validators) . For a visualization of the validators’ _voting power_ (more is NOT better) check out [this page](https://explore.fetch.ai/voting-power-distribution) .
    
4.  Choose the FET amount you wish to stake and select the validator of your choice.
    
    ℹ️
    
    Don’t forget to leave at least 1 available undelegated FET in your wallet. This minimum amount is necessary to pay for transaction fees, claim staking rewards, redelegate and remove your stake. The transaction fee is minimal, but it is not zero. This is why it’s important to have at least 1 available FET.
    
5.  Your ASI Alliance wallet will show you a summary of the transaction. Review it and if you are satisfied confirm the transaction by clicking **Approve** to complete the staking process.
    

### Claim your staking rewards[](#claim-your-staking-rewards)

1.  First of all, ensure you are logged into your [ASI Alliance Wallet](https://network.fetch.ai/docs/guides/asi-wallet/web-wallet/get-started).
    
2.  From the wallet dashboard select **Claim**.
    
    ℹ️
    
    This will claim the total rewards accrued across every validator that you have delegated to.
    
3.  The wallet shows you a summary of the transaction. Review it and if you are happy, hit **Approve** to complete the operation.
    

Upon completion, you will see the rewards added to your **Total Balance**

Remove your Stake[](#remove-your-stake)
---------------------------------------

1.  Log into your wallet
    
2.  In the wallet dashboard click on the **Stake** button. This will open a secondary dashboard.
    
3.  On the secondary dashboard click on **My Stake**
    
4.  Select the validator and amount you wish to remove from staking.
    
5.  The wallet will show you a summary of the transaction. Review it and if you are happy hit **Approve** to complete the operation.
    
    ℹ️
    
    When you remove your stake, there is an unbonding (also known as, cooldown) period of 21 days. In your staking dashboard, the **Unbonding Delegations** section shows you the stakes you have removed which are now in the unbonding period. You can also see the amount of FET unbonded and the number of days remaining from the unbonding period. This is how long you need to wait before being able to withdraw the funds to your wallet.
    

Last updated on

May 14, 2025

[Registration and endpoints weighting](https://network.fetch.ai/docs/introduction/almanac/endpoints "Registration and endpoints weighting")</content>
</page>

<page>
  <title>Different ways of staking FET</title>
  <url>https://network.fetch.ai/docs/guides/network/different-ways-to-stake-the-fet-token</url>
  <content>Below you can find different ways one can stake FET.

STAKING/UNSTAKING ON FETCH MAINNET FOR BINANCE USERS[](#stakingunstaking-on-fetch-mainnet-for-binance-users)
------------------------------------------------------------------------------------------------------------

[Binance has completed the Fetch.ai (FET) mainnet integration](https://www.binance.com/en/support/announcement/f68b1651b8df40998e109588007bb517) .

This means Binance has integrated Native FET tokens which can be staked easily on Cosmostation without relying on the token bridge.

Below you can find the detailed user journey:

For any additional clarification, please feel free to refer to the section **Applicable for users holding FET on Binance** below.

### How to stake FET using Ledger on Cosmostation _Web Wallet_: applicable for users holding FET on Binance[](#how-to-stake-fet-using-ledger-on-cosmostation-web-wallet-applicable-for-users-holding-fet-on-binance)

Please, follow the steps below:

1.  Let’s first head over to [Cosmostation Web Wallet](https://wallet.cosmostation.io/?network=fetchai)  (Fetch.ai chain) and create an address for Fetch.ai chain. There is a detailed pdf from the Cosmostation team explaining how to create an account using ledger and how to use the web wallet.
    
2.  Once done, we would need to send a small amount of FET as test from your Binance account to your generated Cosmostation address. Make sure the addresses are correct and above all the chain chosen for your generated address is Fetch.ai chain on Cosmostation web wallet.
    
3.  If the tokens arrive successfully, then send the remaining amount.
    
4.  Then, we would need to delegate to the preferred validators and start staking.
    

### How to stake on Fetch Mainnet using Cosmostation _Mobile Wallets_: applicable for users holding FET on Binance[](#how-to-stake-on-fetch-mainnet-using-cosmostation-mobile-wallets-applicable-for-users-holding-fet-on-binance)

Please, follow the steps below:

1.  First of all, we need to consider if we wish to stake FET using Cosmostation iOS or Android mobile apps. For Mobile users: [iOS](https://apps.apple.com/us/app/cosmostation/id1459830339)  and [Android](https://play.google.com/store/apps/details?id=wannabit.io.cosmostaion&hl=en&gl=US) .
    
2.  We then need to create a Cosmostation address for Fetch.ai chain. Head over to [Cosmostation FAQs](https://guide.cosmostation.io/)  for a better understanding on how to create a wallet and check your address.
    
3.  Then, we need to send a small amount of $FET from your Binance account to your generated cosmostation address. Make sure the addresses are correct and above all the chain chosen for your generated address is Fetch.ai chain on Cosmostation.
    
4.  If the tokens arrive, then send the remaining amount.
    
5.  Then, we would need to delegate to the preferred validators and start staking.
    

STAKING/UNSTAKING ON FETCH MAINNET FOR USERS WITH ACCESS TO MIGRATED TOKENS[](#stakingunstaking-on-fetch-mainnet-for-users-with-access-to-migrated-tokens)
----------------------------------------------------------------------------------------------------------------------------------------------------------

ℹ️

Our staking program has moved from Ethereum and we have successfully migrated all the tokens on September 15, 2021 — which you can access on our [ASI ALliance browser wallet](https://chromewebstore.google.com/detail/asi-alliance-wallet/ellkdbaphhldpeajbepobaecooaoafpg?hl=en-GB) .

**If you want to access your migrated tokens, here is how you do it.**

*   For those who staked on **staking.fetch.ai** using only Metamask — [Here is the guide](https://medium.com/fetch-ai/staking-migration-guide-how-to-participate-69a60cb5e2eb) .
    
*   For those who staked on **staking.fetch.ai** using ledger — [Here is the guide](https://medium.com/fetch-ai/token-migration-guide-for-hardware-wallets-8c2b99cdced7)  (refer to Key Migration Desktop).
    

**IMPORTANTLY, BE SURE TO CREATE YOUR COSMOSTATION ADDRESS ONLY FOR FETCH.AI CHAIN.**

Head over to [Cosmostation FAQs](https://guide.cosmostation.io/)  for a better understanding on how to create a wallet and check your address.

Below, you can find the detailed user journey explaining how to stake on our Mainnet if you have your tokens on the Fetch browser wallet.

To unstake your tokens, you can use our [guide](https://network.fetch.ai/docs/guides/network/how-to-convert-fet-to-and-from-erc20) which explains how to convert and send native and ERC-20 FET tokens back to your metamask using the Fetch browser wallet.

STAKING/UNSTAKING ON FETCH MAINNET IF YOU HAVE ERC-20 TOKENS ON OTHER EXCHANGES[](#stakingunstaking-on-fetch-mainnet-if-you-have-erc-20-tokens-on-other-exchanges)
------------------------------------------------------------------------------------------------------------------------------------------------------------------

Except Binance and HitBTC all other exchanges including Coinbase currently hold ERC-20 FET. To stake on Mainnet, you must use our [Token bridge](https://token-bridge.fetch.ai/)  and metamask.

Please feel free to refer to the section **Applicable for users on exchanges with ERC-20 FET** at the below sections of this page.

For **Mobile users**: have a look at the **Staking on Fetch Mainnet using Cosmostation Mobile Wallet** guide above.

To unstake your tokens, you can use our [guide](https://network.fetch.ai/docs/guides/network/how-to-convert-fet-to-and-from-erc20) which explains how to convert and send native and ERC-20 FET tokens back to your metamask using the Fetch browser wallet.

For **Ledger users** on exchanges with ERC-20 FET, follow the guide for staking on **Fetch Mainnet using Ledger and Cosmostation Web Wallet: applicable for users on exchanges with ERC20 FET** below.

### How to stake FET using Ledger on Cosmostation Web Wallet: applicable for users on exchanges with ERC20 FET[](#how-to-stake-fet-using-ledger-on-cosmostation-web-wallet-applicable-for-users-on-exchanges-with-erc20-fet)

ℹ️

**Disclaimer**: The guide is a courtesy of [Cros-Net](https://cros-nest.com/)  which is a validator on Fetch.ai Mainnet.

What do you need:

*   Ledger Nano and a Desktop PC, as mobile devices are not yet supported.
*   Ledger Live software installed on your PC and an empty MetaMask wallet on your Brave/Chrome Browser. FET ERC20 tokens (except HitBTC all other exchanges

Head over here — [Cosmostation web application](https://wallet.cosmostation.io/)  (Cosmos Web Wallet) to stake the ERC20 Fetch coins. This guide also assumes you have Fetch.AI tokens stored in your Ledger Nano Wallet ready to be staked.

Please, follow the steps below:

1.  **Install Ethereum and Cosmos Ledger apps**. After setting up your device with a PIN and passphrase, you should install both the Ethereum and Cosmos wallets through the Ledger Live app.
    
2.  **Set specific Ethereum app settings correctly**. Open the Ethereum app on your Ledger wallet. Within the app, go to settings. Make sure **Contract Data** is set to **Allow contract data in transactions**. By default this is turned off, it must be turned on so signing the transaction later on won’t fail. Now exit the app.
    
3.  **Obtaining Fetch.ai address**:
    
    *   Open Cosmos app on your Ledger.
    *   Via Brave/Chrome, go to Cosmos Web Wallet: [Cosmostation](https://wallet.cosmostation.io/) .
    *   On the top right corner, drop down menu, make sure it is set to **fetch.ai**.
    *   Click **Connect Wallet**. Click **Connect to Ledger**.
    *   Your fetch.ai address will appear in the middle of the screen. Make a note of this address as it will be needed later when staking.
    *   Logout of Cosmostation website.
    *   Close down the Cosmos App on Ledger Wallet and open up Ethereum App.
4.  **Set MetaMask bridge with Ledger Live Wallet**.
    
    *   On your Brave/Chrome browser, open the MetaMask wallet. You will now link this wallet with your Ledger via a bridge. Make sure that MetaMask is set to Ethereum Mainnet.
    *   Open the MetaMask wallet and click on top right corner where it has your profile icon.
    *   Choose **Connect Hardware Wallet**, a dialog will appear asking you to **Open Ledger Live**.
    *   Click **Open Ledger Live**. Ledger Live will then ask you to login (if not done so already). Ledger Live will then display **Expose your device accounts through websocket**.
    *   Click **Open** to expose the device via web socket. When doing this for the first time, you will receive a message asking if you want to allow Ledger to make outside connections. Click **OK** on this.
    *   Once the connection is established and the bridge is set, Ledger Live will display **Ethereum bridge opened**. Now we can communicate between the two wallets in this process.
    *   You will also notice that your MetaMask will now have two accounts on Ethereum Mainnet, one which is your original account that was setup with it. The second account is a hardware account linked to Ledger Wallet with **Hardware** displayed next to it.
5.  **Visit the bridge to move coins onto Cosmostation**.
    
    To complete this phase, visit the [bridge](https://token-bridge.fetch.ai/) .
    
    *   Make sure MetaMask is unlocked so it can be connected onto this bridge.
    *   Make sure MetaMask is set to the HARDWARE wallet and that you have enough Ethereum in there to sign the transaction and pay the fees for transfer.
6.  **Open Wallet and check bridge details**.
    
    The source address (Ethereum address of HARDWARE wallet) will be already filled in, and you will see a blank field for the Native address (this is your Fetch native destination address from **STEP 3**).
    
7.  **Enter Fetch address details and make transfer**.
    
    Paste your address starting with **fetch1**, that you identified in STEP 2 into the **Native Address** field, enter the amount, and then click the **Transfer** button. The Ethereum address is connected to the site through Metamask or other browser extension, and needs to be the source from which your tokens will move to Mainnet. The Fetch (Native) address is your destination address, to which they will move on main-net.
    
8.  **Sign the transaction — first one**.
    
    This will trigger a transaction that will ask you to **approve** the bridge contract for holding your tokens. After signing the transaction in your Brave/Chrome browser, be sure to also sign it on your physical device (Ledger Nano), and it will be submitted to the Ethereum blockchain. Once this step is done, you can check your Ledger Live and see that the Fetch Tokens have transferred. As the first transaction is signed, make sure the bridge between Ledger Nano and MetaMask is still running. This is not needed for the second signing below.
    
9.  **Sign the transaction — second one**.
    
    To complete the tokens transfer, you will be asked to sign a second transaction. In case this step fails, retry the process again from Step 8 above and you will only need to sign once (since Fetch tokens would have been transferred onto Mainnet).
    
10.  **Check tokens transferred to validator area**.
    
    After completing these steps, your Fetch address will be credited with tokens that you can delegate to a validator of your choice to start earning staking rewards. Login to [Cosmostation](https://wallet.cosmostation.io/)   as you did in Step 3. Your coins should be present at the centre of the dashboard.
    
11.  **Delegating stake**.
    
    After completing the transfer onto Fetch AI Mainnet and confirming that the coins are now visible on your dashboard, it is time to stake the coins.
    
    *   Make sure Ledger is unlocked and Cosmos App is running.
    *   Click on Wallet and select **Reward**.
    *   This will show a list of validators to delegate to. (In case you get an error when trying to open the **Reward** section, make sure the Cosmos App is unlocked and running on your Ledger).
    *   Validators are listed at the bottom of the screen. Choose a validator to delegate to by clicking on the **Delegate** button. A dialog will appear.
    *   Enter the amount of Fetch tokens you want to delegate and then click on the **Generate & Sign Transaction** button.
    *   Confirm this on your Ledger wallet and your coins will be sent to the validator for staking.
    *   Repeat the process if you wish to delegate to other validators.
    *   As each validator is added, this will be displayed in the UI of the page.

### How to stake on Fetch Mainnet using Cosmostation Mobile Wallets: applicable for users on exchanges with ERC20 FET[](#how-to-stake-on-fetch-mainnet-using-cosmostation-mobile-wallets-applicable-for-users-on-exchanges-with-erc20-fet)

What you will need:

*   A Metamask extension for your browser.
    
*   A Cosmostation Wallet: [iOS](https://apps.apple.com/us/app/cosmostation/id1459830339)  or [Android](https://play.google.com/store/apps/details?id=wannabit.io.cosmostaion&hl=en&gl=US) .
    

Please, follow the steps below:

a. If you do not have the metamask extension installed on your browser. Download it and create an account. Never give out your metamask private key, never give out your mnemonics, and store your password safe.

b. Let’s set Metamask to receive FET. Click on add token and click on **custom** and add the ERC20 FET address [0xaea46A60368A7bD060eec7DF8CBa43b7EF41Ad85](https://etherscan.io/address/0xaea46A60368A7bD060eec7DF8CBa43b7EF41Ad85) 

c. Send your tokens from your exchange to Metamask. We will take Binance as an example here.

*   Go to Wallet/Overview FIAT and SPOT.
*   Withdraw your FET and ETH to your metamask account. You will need some ETH to pay for withdrawal. You can also buy ETH on Metamask directly. To withdraw your FET, copy and paste your Metamask address into the field. **Always use the ERC20 network to send your FET**.

_If you’re on any other exchange, please send your tokens directly to Metamask_.

d. Then, we need to wait for Metamask to receive your FET and ETH which may take a few minutes. If you are stuck, please refresh your page but be patient. If you start to get worried, head over to etherscan.io and check your tx hash. If it is successful, it is down to ETH network congestion but your tokens are on their way.

e. Now, download the Cosmostation Wallet for your phone. Create an account on it. Remember to choose Fetch Mainnet when you’re asked to choose a Cosmo network. Once again you will be asked to store your mnemonics so write them down and keep them somewhere safe.

f. After you have successfully created your wallet on the Cosmostation wallet app, you can go to [Token Bridge](https://token-bridge.fetch.ai/) . Ensure your metamask is connected to the token bridge. Once you have your tokens, connect your metamask with [Token Bridge](https://token-bridge.fetch.ai/) . A new window will pop up and you will be prompted to approve the request to connect.

g. _Enter your metamask address in the Ethereum Address, your Cosmostation Wallet address in the Native Address field_. Enter the amount of FET you wish to transfer, note that you must send a minimum of 100 FET across the bridge.

h. Let’s then enter the amount — click **Transfer** — pay for the first little transaction with ETH to approve — once the transaction is approved, a metamask pop-up should come asking to pay for the swap. Please pay the second transaction with ETH. If the first transaction succeeds but nothing comes on the page to pay the second transaction : just refresh the page, copy-paste your addresses again, enter again the amount, and you should see the **swap** button now.

i. Once you have transferred and swapped on step **g**, check your Cosmostation wallet and wait for a few minutes before the transferred tokens show up.

l. Once they have arrived you can delegate them to a validator of your choice.

**Congratulations you have successfully staked on Fetch.ai Mainnet 2.0!**</content>
</page>

<page>
  <title>Re-delegating staked FET token</title>
  <url>https://network.fetch.ai/docs/guides/network/re-delegating-staked-fet-token</url>
  <content>Re-delegating staked FET
------------------------

Re-delegation is the process of moving some or all of your FET from one validator to another.

⚠️

If you wish to re-delegate, please do not manually remove your stake from one validator and stake with another. This will trigger the unbonding period, causing you to miss out on staking rewards for 21 days while you wait for the unbonding period to end. Re-delegation, unlike manually removing and adding stake, is an instant process for moving some or all of your staked FETs from one validator to another.

Why Redelegate[](#why-redelegate)
---------------------------------

There may be different reasons why you might choose to re-delegate and redistribute your stake. For instance:

1.  **Increase the decentralization and therefore security of the network.**
    
    For the ASI network to be as secure as possible, there should not be a large concentration of stakes (e.g. more than 33% of the delegated FETs) staked within only a small number of (e.g. 10) validators. If you see this is currently the case and that you have also contributed to it by delegating your stakes with one of those validators, you may want to consider redistributing your stakes to some of the other validators.
    
2.  **Reduce your staking risks.**
    
    Remember that when you delegate your tokens with a validator, just as you share the rewards for their contribution to the network, you also share the punishment they would receive if they misbehave and act against the network’s protocol. If this happens, your stake with them will be slashed. To reduce this risk, you may choose to re-delegate parts of your stakes to other validators to have a wider stake distribution.
    
    ℹ️
    
    You can only re-delegate from one validator to another validator once. You can not re-delegate twice. You will go through a 21 day unboding period if you re-delegate from one validator to another and then immediately re-delegate to a third validator. This is commonly referred to as validator hopping and is discouraged.
    

To Re-delegate your Stake[](#to-re-delegate-your-stake)
-------------------------------------------------------

1.  Download and install the ASI Alliance browser extension wallet you can find a download link as well as a getting started guide here [ASI Alliance Wallet](https://network.fetch.ai/docs/guides/asi-wallet/web-wallet/get-started) .
    
2.  Once you’ve set up the wallet click the **Stake** button.
    
3.  From there hover over and select **My Stake**.
    
4.  Proceed by selecting the **Re-delegate** option.
    
5.  Select the amount you wish to re-delegate as well as the validator that you wish to re-delegate to. You can select the validator by clicking the **Select Validator** drop down menu.
    
6.  The wallet will show you a summary of the transaction. Review it and if you are satisfied, hit **Approve** to complete the operation.
    

Choosing a Validator[](#choosing-a-validator)
---------------------------------------------

Choosing a validator to delegate your stake with is an important decision which ultimately impacts the network’s security and performance. When you choose a validator, you are essentially casting a vote in the network indicating their trustworthiness, and that it is beneficial to have them participate in the maintenance of the network’s operation.

When it comes to choose a validator, it is completely up to you to research about the delegators thus to do your own research and due diligence to find out about their reputation and how well they have performed so far. **Delegation is meant to be an active role between you and a validator**.

To help you choose the most suitable validator, here is a list of criteria you could look for:

*   Do they have a website?
    
*   Do they have an active presence on social media (e.g. Twitter, Reddit, Instagram, …)?
    
*   Are they easy to contact (e.g. on Discord, Telegram, …)?
    
*   Do they have FET self-bonded to their node?
    
*   Are they active in the community?
    
*   Do they have a high uptime?
    
*   Do they offer slashing & double sign protection?
    
*   Do they participate and vote on proposals?
    
*   Do they have a mission or set of principles that align with yours?
    
    ℹ️
    
    Some of these questions can be answered via our [Native Block Explorer](https://explore-fetchhub.fetch.ai/)  or [Mintscan](https://www.mintscan.io/fetchai/) . Some of the others on this list will require you to reach out to validators for answers, which is a good opportunity to see if they are active or not.
    

Last updated on

May 14, 2025

[Registration and endpoints weighting](https://network.fetch.ai/docs/introduction/almanac/endpoints "Registration and endpoints weighting")</content>
</page>

<page>
  <title>IBC CUDOS Tokens Transfer</title>
  <url>https://network.fetch.ai/docs/guides/network/ibc-transfers</url>
  <content>Overview[](#overview)
---------------------

The Artificial Superintelligence Alliance (ASI) network facilitates CUDOS token reconciliation following the CUDOS network’s merger into the ASI Alliance network. This process allows users to migrate their CUDOS tokens to FET tokens based on a pre-agreed conversion rate via the [Agent Network Hub](https://hub.fetch.ai/fetchhub-4/reconciliation)  UI.

By following the appropriate steps for either claiming locked tokens or converting liquid tokens, users can securely complete their migration using the Agent Network Hub. Ensuring the correct wallet connection is essential for claiming tokens, while for conversion, it is simply a matter of having available liquid CUDOS tokens in the account.

Claim and Convert options[](#claim-and-convert-options)
-------------------------------------------------------

Users may face two different scenarios when migrating their tokens:

### 1\. Claiming locked CUDOS tokens[](#1-claiming-locked-cudos-tokens)

If CUDOS tokens were previously sent via IBC (Inter-Blockchain Communication) back to their native CUDOS Mainnet chain **after** it was decommissioned, then these tokens became locked forever. Users can claim these locked tokens as FET ones via the [Agent Network Hub](https://hub.fetch.ai/fetchhub-4/reconciliation) .

The most crucial aspect of claiming locked tokens is selecting the correct wallet account (with the correct ASI address) in the [ASI Alliance Web Wallet](https://network.fetch.ai/docs/guides/asi-wallet/web-wallet/get-started) extension, otherwise users won’t be able to see their claimable tokens in the Agent Network Hub UI and consequently claim them. The correct ASI account must be derived from the very same private key as the original sender’s account used to transfer CUDOS tokens from the source chain (e.g. Osmosis) to the already decommissioned CUDOS mainnet, which caused the tokens to become locked. Depending on how the original sender’s account was created (respectively how the user/owner is usually accessing it), there are two possible ways how to add it to the ASI Wallet Extension:

*   **Software wallet**: users will need to provide the same mnemonic seed phrase and HD Derivation path as when the user created the original sender’s account .
    
*   **Hardware wallet**: users will need to add the same Ledger Hardware Wallet and use the correct HD Derivation path. In this case, there is no need for a seed phrase, since it is represented by the Ledger Hardware Wallet itself.
    

If all parameters are correctly provided, the user will end up with the correct ASI wallet account in the ASI Wallet Extension.

#### Walk-through to claim locked CUDOS tokens[](#walk-through-to-claim-locked-cudos-tokens)

1.  Open the [Agent Network Hub](https://hub.fetch.ai/fetchhub-4/reconciliation) .
    
2.  Head over to the **Reconciliation** tab.
    
3.  Switch to the **CUDOS tokens** tab.
    
4.  Connect your ASI Web Wallet. If you do not have one, download it from [here](https://network.fetch.ai/docs/guides/asi-wallet/web-wallet/get-started).
    
5.  You need to ensure that you use the exact wallet address that was originally used to lock CUDOS tokens from the source network. You can add such a wallet within the ASI Wallet by clicking the 3 dots menu button:
    
    Then, click **Add a new wallet**.
    
    Click **Import existing wallet**.
    
    Choose to import a wallet based on a seed phrase (if you have a software wallet) or by connecting a hardware wallet.
    
    By using a _software wallet_, you need to import the wallet using the **same** seed phrase as the one related to the wallet you used to lock the CUDOS tokens on the source network.
    
    If you know the _HD derivation path_ for your original wallet address, provide it alongside the seed phrase, by clicking the **Advanced Options** button.
    
    ℹ️
    
    The **HD derivation path** presents multiple fields that need to be populated: **account**, **exchange** and **index**. These fields of HD path determine the private key of the account, which is going to be imported to the ASI wallet. If they (and seed phrase) are provided correctly, the resulting derived private key will be exactly the same, as the one used to derive the source account used to initially transfer CUDOS tokens from original source chain (e.g. Osmosis) to the decommissioned CUDOS Mainnet chain, thus effectively locking them.
    
    Click **Next**.
    
6.  Once you connect the new account successfully, the Agent Network Hub UI will refresh, and you should be able to check the **Claim** section with the available amount of CUDOS tokens that can be actually claimed.
    
7.  Check that the amount is displayed correctly, then proceed to submit the claim request by clicking the **Execute** button.
    
8.  Confirm the transaction within the ASI Wallet and wait for processing.
    
9.  The FET tokens will be credited to your connected ASI account upon successful claim processing.
    

### 2\. Converting liquid CUDOS tokens[](#2-converting-liquid-cudos-tokens)

If users hold liquid CUDOS tokens on IBC-supported networks, they can convert them to FET tokens using the Agent Network Hub.

First, they will need to transfer them via IBC to the ASI Alliance Network, and then convert them to FET tokens using the dedicated Agent Network Hub UI.

ℹ️

At the moment, _only_ CUDOS tokens on the **Osmosis** and **Archway** networks are supported. In addition, _CUDOS tokens on the Archway network will need to be first transferred over IBC to the Osmosis network, and then from there to the ASI Main network_.

During this process, the ASI account itself (its address) is not relevant for the conversion process (opposite to the claiming process described above). **_All that matters is the ownership of CUDOS tokens_**. The Agent Network Hub UI will automatically populate the **Convert** field based on the available balance of CUDOS tokens once the ASI account is connected to the app itself.

#### Walk-through to convert liquid CUDOS tokens[](#walk-through-to-convert-liquid-cudos-tokens)

1.  Open the [Agent Network Hub](https://hub.fetch.ai/fetchhub-4/reconciliation) .
    
2.  Head over to the **Reconciliation** tab.
    
3.  Connect your [ASI wallet](https://network.fetch.ai/docs/guides/asi-wallet/web-wallet/get-started). Ensure it holds liquid CUDOS tokens on any IBC-supported network. These can be transferred from the source wallet to the ASI wallet straightforwardly.
    
4.  Navigate to the **CUDOS** tab within the **Reconciliation** page.
    
    ℹ️
    
    The available balance of CUDOS tokens should be displayed automatically based on the amount available of liquid CUDOS tokens on your connected wallet.
    
5.  Select the amount you wish to convert.
    
6.  Press **Execute** button.
    
7.  Confirm the transaction on the wallet and wait for processing.
    
8.  The corresponding amount of FET tokens will be credited to your ASI wallet upon successful conversion.</content>
</page>

<page>
  <title>Reconciliation service</title>
  <url>https://network.fetch.ai/docs/guides/network/reconciliation-service</url>
  <content>The [Reconciliation service](https://hub.fetch.ai/fetchhub-4/reconciliation)  has been built to restore access of the migrated funds for affected users after the stake migration from Fetch Staking platform on Ethereum mainnet to the Fetch Mainnet.

In particular, this service is aimed at users, who used Hardware Wallets for staking of their ERC-20 FET tokens on Fetch Staking platform on Ethereum mainnet.

Due to limitations of Hardware Wallets, these users could not use their Hardware Wallets to access their funds migrated to Fetch mainnet without compromising the air-gap protection level Hardware Wallets offer.

This new reconciliation service resolves this issue, allowing all affected users with Hardware Wallets to regain access to their funds.

Requirements[](#requirements)
-----------------------------

First, make sure you have installed the [ASI Alliance Wallet](https://network.fetch.ai/docs/guides/asi-wallet/web-wallet/get-started) browser extension, and it has added an account, where you want the recovered funds to be sent to.\\

That account must have some funds on it to pay for transaction fee (`1 FET` should be way more than enough).  
You can buy FET from different centralized or decentralized exchanges.

Secondly, you also need to make sure you have the [Metamask](https://metamask.io/)  wallet browser extension installed, and it has added the account you originally used to stake your ERC-20 FET tokens on Fetch Staking platform on Ethereum mainnet.

Once you satisfy these two requirements, head over to the [Reconciliation page](https://hub.fetch.ai/fetchhub-4/reconciliation)  and follow the instructions step-by-step.

ℹ️

It is important to remember that your Metamask Wallet **must** be connected to the **Ethereum Mainnet**, and your ASI Alliance Wallet **must** be connected to the **Fetch Mainnet (fetchhub-4)**.

Walk-through[](#walk-through)
-----------------------------

Head over to the [Reconciliation page](https://hub.fetch.ai/fetchhub-4/reconciliation)  and click on **Next**.

### Step 1[](#step-1)

You need to connect your ASI Alliance Wallet in order to retrieve the **Recovery Address** where your reconciled funds will be sent to. Click the **Connect Wallet** button and provide the data needed to log in to your ASI Alliance Wallet.

A pop-up will show up; click **Approve**.

You will then be able to see the **Recovery Address** where your reconciled funds will be sent to.  
You can change the **Recovery Address** at any point via the ASI Alliance Wallet extension, by choosing any other account of choice.

You can then click on **Next**.

### Step 2[](#step-2)

Now it is necessary to select the Ethereum address you originally used for staking on Ethereum - the selected address **MUST** be the one you used to stake your tokens on Fetch Staking platform on **Ethereum** mainnet.

Open your Metamask extension and click on **Connect**

Once you do so, you will see that the fields in the page will be automatically populated based on account you selected in the Metamask.

You can switch between any of your Metamask accounts. The fields will be updated automatically based on account chosen in Metamask.

ℹ️

If you select address which was **never** used for staking on Fetch Staking platform on Ethereum mainnet, or if that address was already reconciled, then the Reconciliation dApp will display the following error message in red color: `"This address appears to not be affected by the staking migration issue"`, see the screenshot below.

Then it will be necessary to select **correct** account in the Metamask wallet extension in order to be able to continue in the reconciliation workflow.

Once you connected the correct Ethereum account to the Agent Network Hub UI, you will be able to see details about the **Staking Address** and the **Amount to Restore**.

Review the details and press the **Create Signature** button.

That will create Ethereum message associating destination target address on Fetch Mainnet with original Ethereum source address, and sends it to the **Metamask** wallet for signing.

ℹ️

This does **not** require any ETH gas, since all what is being done is generating an Ethereum signature for the message.

ℹ️

Note that amount of tokens displayed in the `Amount to Restore [afet]` box is presented in the `afet` denomination.

In order to get the amount in `FET` denomination, it is necessary to shift the decimal point by 18 orders of magnitude to the left, what means **dividing** the amount displayed by **1018**.

In the example above, the `30000000000000000000` amount displayed there represents `30 [FET]` tokens.

The Metamask pop-up will appear. Click **Confirm**.

Great! Now you will see all the fields fully populated:

The resulting signature serves dual purpose:

*   Primarily it is the proof of ownership of funds associated with original Ethereum address;
*   Secondarily it is proof of association between the Fetch destination recovery address and Ethereum source address.

ℹ️

**If** user needs to **switch** to a different Ethereum Staking address, then after selecting a new account in the Metamask wallet extension, it might be necessary to **connect** the newly selected account in Metamask in order to make the Reconciliation dApp UI aware of the account change - see the screenshot below.  
This will be necessary if the newly selected account was not connected to reconciliation url before.

User can switch the Ethereum staking address (or Fetch recovery address) at any point during the workflow before submitting the transaction.

Click **Next**.

### Step 3[](#step-3)

You will be redirected towards a summary page where you can view all details about the transaction. You can change any of the details you see, but you will be prompted back at the previous steps to reconnect your wallet/accounts. Make sure all details are correct and click **Submit**.

A pop-up will appear for your ASI Alliance Wallet extension. Click **Approve Transaction**.

Great! You successfully completed all the steps required. You now should be able to see your reconciled funds at the Recovery Address provided similarly to what depicted below:</content>
</page>

<page>
  <title>Agents Name Service</title>
  <url>https://network.fetch.ai/docs/guides/network/aname-service</url>
  <content>Overview[](#overview)
---------------------

A **domain** is a structured identifier that helps organize and address [Agents](https://uagents.fetch.ai/docs/)  within a network. It acts as a namespace, grouping Agents under a common label to make interactions more intuitive. In any Agent-based system, particularly in decentralized environments including the ASI network, Agents need a clear way to identify and communicate with each other. Instead of relying on long, complex addresses, domains provide a structured way to reference them.

In a system where different applications or organizations manage multiple Agents, domains help distinguish their roles effortlessly. For instance, a transport-related Agent could belong to the `transport.agent` domain, while a financial Agent might operate under `finance.agent`. Within these domains, Agents have unique names, ensuring that they can be addressed correctly. An Agent named `bob-0.transport.agent` could be responsible for a smart mobility service, whereas `alice.weather.agent` might provide weather updates.

Domains make Agents interactions more scalable and efficient by keeping their identities organized. As networks grow, having structured namespaces allows Agents to be categorized in a way that reduces confusion and improves communication. This structure also supports interoperability, enabling Agents from different domains to interact while maintaining distinct roles. By making it easier to discover and reference Agents, domains enhance both usability and system-wide coordination.

Agent Domains on the ASI Alliance Network[](#agent-domains-on-the-asi-alliance-network)
---------------------------------------------------------------------------------------

It is possible to explore Agents domains on the ASI Alliance Network using the [Agent Network Hub](https://hub.fetch.ai/fetchhub-4/blocks) . Open the App and connect your [ASI Alliance web wallet](https://network.fetch.ai/docs/guides/asi-wallet/web-wallet/get-started).

Once you connect it successfully, you will need to click the **Connect Wallet** button in the top right corner and select **Domain** from the drop-down menu.

You will be redirected to the **Domains** page.

Here, you can either **_get a new domain_** for your Agents or **_explore already existing domains_** attached to your Agents.

### Get a new domain[](#get-a-new-domain)

In the **Domains** page, select the **Get a new domain** tab.

Look for any domain you wish to buy and associate with an Agent by typing it in within the dedicated search bar (e.g., `billy.ai`). Once you click the **Check** button; a list of results will appear below showing all the results related to your search.

A particular domain could have already been bought by another user and in that case it won’t be available for purchase and marked as _Unavailable_. For any other available domain, check for the one you want to purchase and click the **Buy** button. A price in FET tokens per year will be displayed for each particular domain. The newly purchased domain is then associated and managed using the ASI Wallet Account you connected to the UI. This account becomes the **Administrator** of the domain, meaning that this account has full control over the domain’s settings.

ℹ️

An **Admin** has full control over domain settings, such as managing user roles and domain configurations, as well as performing tasks such as renewal and deletion of the domain itself. Admin permission is automatically granted to the account which purchased the domain in the first place. Once an administrator purchases a domain, it is possible to add all subdomains desired freely. Permissions within these subdomains are inherited from the top level domain permission configurations.

On the other hand, a **Writer** account has limited access, primarily focused on registration of Agents into domains, without the ability to modify domain configurations or manage user roles. This permission level is assigned to users by the Admin account. Depending on the user’s role, the UI will slightly change when it comes to domains’ details exploration. If a user has no role being granted, then the user will just be able to check the domain’s details, without the ability to perform any action.

You will then be able to see all details related to the domain you have chosen.

To complete the purchase, you must click **Confirm**, which will process the transaction on-chain. If you decide not to proceed, selecting **Cancel** will close the window without making any changes. If you go on with the purchase, you will need to **Approve** the transaction within your ASI Web Wallet pop-up window.

After successful confirmation, the domain will be linked to your account, allowing you to use it as a recognizable identifier for your Agent. Remember that **you will need to renew the domain annually to maintain ownership!**

### Explore your domains[](#explore-your-domains)

In the **Domains** page, select the **My domains** tab.

You will be able to see a full list of all domains you previously purchased and that are associated with the address of the ASI Wallet you connected to the Agent Network Hub UI. Each Domain has multiple information, including:

*   **Subdomains**: The number of subdomains associated with the domain.
*   **Domain/Agent mappings**: How many mappings are set up between agents and the domain.
*   **Expiration**: Helps to monitor this to renew domains before they expire.
*   **Role**: It is the user’s role associated with the domain based on permissions levels. We can distinguish 2 permission levels: _Admin_ and _Writer_.

If you click on one of your domains, you will be able to explore the particular domain’s details:

#### Administrator permissions[](#administrator-permissions)

**_If you have Admin permissions_** then you will be in full control of that particular domain configuration.

You will be able to explore the details of that specific domain (e.g., `billy.helper`), including the Agents mapped towards it, the subdomains and weights in case Agents share the same domain. You can also explore **Permissions** within the dedicated section and add an Admin or a Writer account to the domain itself. You can edit or remove permissions by clicking the dedicated buttons for each permission granted.

You are also able to add a particular Agent, using its address, to the domain by using the **Connect an Agent** section. You will need to provide the Agent Address and assign a weight to determine selection priority if multiple Agents share the same exact domain, with higher values indicating priority. You can optionally specify a subdomain (e.g., `foo.billy.helper`). Once you are satisfied, click **Add** to register the Agents and map it to that domain. Once an Agent is mapped to the domain, you can click the pencil icon to edit an existing Agent mapping, or, you can click the crossed-out link icon to remove an Agent’s association with the domain:

#### Writer permissions[](#writer-permissions)

**_If you have Writer permissions_**, then you will be just able to add/edit Agents mapped to that specific domain. It is at this point that the benefit of having Writer permission comes into play as this permission allows all manipulation with Agents and mapping to the domain. This is particularly helpful whenever you need someone to handle day-to-day registration of Agents into a particular domain configuration.</content>
</page>

<page>
  <title>The Almanac</title>
  <url>https://network.fetch.ai/docs/introduction/almanac/introduction</url>
  <content>The **Almanac** contract is a critical component within the ASI ecosystem, allowing direct access to registered [Agents](https://uagents.fetch.ai/docs)  and related information. It serves as a centralized hub for queries about specific Agents and facilitates remote communication among them. Agents must register within the Almanac to enable remote interactions and be found via the [Agentverse Marketplace](https://agentverse.ai/docs/marketplace) . You can register your Agents on the Almanac by following this [guide](https://network.fetch.ai/docs/introduction/almanac/register-in-almanac). You can also explore the [Communicating with other agents](https://uagents.fetch.ai/docs/guides/communication)  guide to understand how Agents leverage the Almanac to communicate remotely.

When an Agent is registered in the Almanac, it becomes accessible throughout the ASI ecosystem. This ensures the system, and tools like [ASI-1 Mini LLM](https://asi1.ai/)  to dynamically discover and engage with Agents based on user queries or requests from other Agents. This allows for straightforward task execution, smart delegation, and high-level coordination across the ecosystem. You can easily chat with any Agent integrated with ASI-1 Mini LLM via the Agentverse Marketplace (through the dedicated button available when opening the Agent’s details page) or via [chat.agentverse.ai](https://chat.agentverse.ai/) .

Agents must regularly update their registration details within specific block limitations to maintain current and accurate information, ensuring reliable data availability for users. Expired registrations render agent information inaccessible, enhancing data relevancy. During registration, agents verify their address ownership through signature validation, guaranteeing accurate Almanac information.

ℹ️

Head over to this [Agents guide](https://uagents.fetch.ai/docs/examples/asi-1)  for a better overview of how to integrate ASI-1 Mini LLM into Agents.

Public and private agents: the role of protocols and Almanac[](#public-and-private-agents-the-role-of-protocols-and-almanac)
----------------------------------------------------------------------------------------------------------------------------

Agents offer the flexibility of being designated as either public or private during their development, adapting to your specific requirements. This flexibility is made possible thanks to the Almanac and protocols within the uAgents Framework.

A [protocol](https://uagents.fetch.ai/docs/guides/protocols) , within the uAgents Framework, establishes the rules and message structures governing Agents’ interactions. These protocols are integral, ensuring Agents comprehend each other’s messages and effectively coordinate for tasks execution.

Contrarily, the Almanac operates as a decentralized directory in the ASI ecosystem, housing details about registered Agents and their capabilities, including the protocols’ manifest. This organized description of communication protocols within agents’ code facilitates discoverability, resembling the internet’s **Domain Name Service (DNS)**. Users can explore and interact with Agents via the [Agentverse Marketplace](https://agentverse.ai/docs/marketplace) , filtering Agents based on unique protocols’ digests.

ℹ️

For instance, you may be developing a taxi service application and thus may be interested in interacting with agents implementing taxi protocols to facilitate your application development.

ℹ️

For additional information on the Agentverse and its tools, visit our documentation website [page](https://agentverse.ai/docs/) .</content>
</page>

<page>
  <title>Setting up a Multisig Account</title>
  <url>https://network.fetch.ai/docs/guides/network/setting-up-a-multisig</url>
  <content>What is a Multisig account?[](#what-is-a-multisig-account)
----------------------------------------------------------

A multisig account, within the ASI Network, possesses a unique key that necessitates multiple signatures for transaction authorization. This feature serves to enhance account security and mandates the agreement of multiple parties for transaction execution. Multisig accounts are established by defining:

*   The threshold number of signatures necessary.
*   The public keys implicated in the signing process.

Signing with a multisig account involves individually signing the transaction with the specified keys assigned to the account. Subsequently, these signatures are aggregated into a multisignature, enabling transaction authorization. If the multisignature lacks the required number of signatures, it is deemed invalid.

Generating a Multisig Key[](#generating-a-multisig-key)
-------------------------------------------------------

    fetchd keys add --multisig=name1,name2,name3[...] --multisig-threshold=N new_key_name
    

`N` is the minimum number of private keys that must have signed a transaction for it to be valid.

The `--multisig` flag must contain **ALL** the names of the public keys that will make up the multisig account. In addition, all these names must have already been added to the local database

By default all the public keys that are provided are sorted to generate a consistent address. This would mean that the following commands would produce the same account.

    fetchd keys add --multisig=k1,k2,k3 --multisig-threshold=2 multisig_address
    fetchd keys add --multisig=k2,k3,k1 --multisig-threshold=2 multisig_address

If this behaviour is not desirable, then you can use the `--nosort` flag when creating the multisig to disable it.

### Adding public keys to the database[](#adding-public-keys-to-the-database)

You can add public keys to your local `fetchd` database using the following command:

    fetchd keys add msig-p2 --pubkey='{"@type":"/cosmos.crypto.secp256k1.PubKey","key":"AsMGc+Jz7bKpI0Q2MUlGYzE6MT1GEOAKsDFKltB18Rs0"}'

Signing a transaction[](#signing-a-transaction)
-----------------------------------------------

### Step 1: Generating the transaction[](#step-1-generating-the-transaction)

Since you will need multiple accounts to sign the transaction that you want to send from a multisig account, you first need to generate the transaction that you plan on send.

In the example below we send 1FET from the multisig to `fetch124rum7e4z8jdg7plxtp2d3f3um57cmr7vd8467`.

    fetchd tx bank send \
    	fetch1mzdu9kagyh38walpq4yh83mf99229nyyr4jxkw \
    	fetch124rum7e4z8jdg7plxtp2d3f3um57cmr7vd8467 \
    	1000000000000000000atestfet \
    	--chain-id fetchhub-4 \
    	--generate-only > unsigned-tx.json

The output file `unsigned-tx.json` contains the unsigned transaction payload as shown below:

    {
      "body": {
        "messages": [
          {
            "@type": "/cosmos.bank.v1beta1.MsgSend",
            "from_address": "fetch1mzdu9kagyh38walpq4yh83mf99229nyyr4jxkw",
            "to_address": "fetch124rum7e4z8jdg7plxtp2d3f3um57cmr7vd8467",
            "amount": [
              {
                "denom": "atestfet",
                "amount": "1000000000000000000"
              }
            ]
          }
        ],
        "memo": "",
        "timeout_height": "0",
        "extension_options": [],
        "non_critical_extension_options": []
      },
      "auth_info": {
        "signer_infos": [],
        "fee": {
          "amount": [],
          "gas_limit": "200000",
          "payer": "",
          "granter": ""
        }
      },
      "signatures": []
    }
    

Step 2: Individual Signing[](#step-2-individual-signing)
--------------------------------------------------------

Now that we have generated the transaction that we want to send, each account needs to sign the transaction individually.

In the example below we first sign with the `msig-p1` account:

    fetchd tx sign \
        unsigned-tx.json \
        --multisig=fetch1mzdu9kagyh38walpq4yh83mf99229nyyr4jxkw \
        --from=msig-p1 \
        --output-document=msig-p1.sig.json \
        --chain-id=fetchhub-4

Then we sign with the `msig-p2` account:

    fetchd tx sign \
        unsigned-tx.json \
        --multisig=fetch1mzdu9kagyh38walpq4yh83mf99229nyyr4jxkw \
        --from=msig-p2 \
        --output-document=msig-p2.sig.json \
        --chain-id=fetchhub-4

Step 3: Combining the Signatures together
-----------------------------------------

We now have both the unsigned transaction and two signature for the transaction. The final step is to combine all the signatures together and to generate a full transaction that can be broadcast to the network.

    fetchd tx multisign \
        unsigned-tx.json \
        multi \
        msig-p1.sig.json msig-p2.sig.json \
        --output-document=signed-tx.json \
        --chain-id=fetchhub-4

The final transaction is now generated in `signed-tx.json`.

Step 4: Broadcasting the transaction
------------------------------------

The final step, now that we have the full transaction is to be broadcast it to the network. This can be done with the following command:

    fetchd tx broadcast --broadcast-mode=block signed-tx.json

The flag `--broadcast-mode=block` is optional, however, in this mode the command will both broadcast the transaction and wait for the transaction to be included into a block.</content>
</page>

<page>
  <title>Setting up the ASI Alliance extension wallet with a Ledger hardware wallet</title>
  <url>https://network.fetch.ai/docs/guides/asi-wallet/asi-wallet-hardware-connection-guide</url>
  <content>If you own a Ledger hardware wallet and wish to enhance the security and functionality of your crypto assets, follow these steps to set up and perform your first transaction using the Fetch.ai browser extension wallet in combination with a ledger device.

1.  **Download and install the ASI Alliance browser extension wallet.**
    
    Visit the official website: [ASI Alliance Wallet](https://fetch.ai/get-fetch-wallet) . Follow the installation prompts to seamlessly integrate the extension into your browser. The wallet is supported on Chrome, Brave and Firefox.
    
2.  **Plug in your ledger and open the Ledger Live software.**
    
    Connect your ledger hardware wallet to your computer using the supplied USB cable. Launch the Ledger Live software if it’s not already running. Ensure that your Ledger device is properly connected and recognized by Ledger Live.
    
3.  **Download and install the Cosmos app.**
    
    Inside the Ledger Live software, navigate to the “Manager” section. Search for “Cosmos” or “ATOM” within the app catalog. Click on the Cosmos app, and then follow the on-screen instructions to install it onto your Ledger device.
    
4.  **Create a Cosmos address.**
    
    If you don’t already possess a Cosmos (ATOM) address, you can easily create one through Ledger Live. This is a mandatory step as Fetch is a cosmos-sdk based chain. In Ledger Live, access the “Accounts” section and choose “Add Account.” Select “Cosmos” as the cryptocurrency and follow the prompts to generate a new Cosmos address.
    
5.  **Open ASI Alliance browser Extension Wallet and Connect Ledger.**
    
    Launch the ASI Alliance browser extension wallet by clicking on its icon located in your browser’s toolbar. Locate and click the “Connect Ledger” option.
    
    *   For first-time setup, choose “Connect Ledger” at the beginning of the wallet setup.
    *   If you already possess a ASI Alliance wallet, navigate to the “Accounts” tab in the upper right corner and create a new account by selecting the “Connect Ledger” option.
    
    Once you’ve connected, ensure the cosmos app is open on your ledger.
    
6.  **Create a test transaction and sign it with the Ledger.**
    

To confirm that your Ledger hardware wallet is correctly linked to the ASI Alliance extension wallet, initiate a test transaction with a minimal amount of FET. Within the ASI Alliance extension wallet, access the **Send** section.

Enter the recipient’s address and specify the amount for the test transaction. Carefully follow the on-screen instructions to verify and sign the transaction using your Ledger device.

Review the transaction details on your Ledger device, and once satisfied, approve it. Wait for the transaction to process and gain confirmation. You can monitor its status within the [ASI Alliance extension wallet](https://network.fetch.ai/docs/guides/asi-wallet/web-wallet/get-started) or explore it further on a blockchain explorer such as [Mintscan](https://www.mintscan.io/fetchai) .

Last updated on

May 14, 2025

[Registration and endpoints weighting](https://network.fetch.ai/docs/introduction/almanac/endpoints "Registration and endpoints weighting")</content>
</page>

<page>
  <title>Registration and endpoints weighting</title>
  <url>https://network.fetch.ai/docs/introduction/almanac/endpoints</url>
  <content>Agents can communicate in a remote fashion with one another across different locations on the internet. This is achievable by using the **Agent address** to register into the [Almanac contract](https://network.fetch.ai/docs/introduction/almanac/introduction) (by first paying a small fee), and then _querying the Almanac to retrieve an HTTP endpoint_ of a recipient agent.

Whenever agents registers in the Almanac, they must specify the service **endpoints** it provides alongside a **weight parameter** for each endpoint provided. Then, when any agent tries to communicate with this agent, the service endpoint will be chosen using a weighted random selection.

For additional information on **Agents addresses**, have a look at our [addresses guide](https://uagents.fetch.ai/docs/getting-started/address) .

Endpoint weighting[](#endpoint-weighting)
-----------------------------------------

There exist _two format_ options when defining your agent’s endpoints:

*   **List format**: This defines the agent’s endpoints as a list of strings. The weights will be automatically assigned a value of 1.
    
        agent = Agent(
            name="alice",
            port=8000,
            seed="agent secret phrase",
            endpoint=["http://127.0.0.1:8000/submit","http://127.0.0.1:8001/submit"]
        )
    
*   **Dictionary format**: This defines the agent’s endpoints in a Dict format, specifying the weight for each endpoint. If the weight parameter is not specified, it will be assigned a value of 1.
    
        agent = Agent(
            name="alice",
            port=8000,
            seed="agent recovery seed phrase",
            endpoint={
                "http://127.0.0.1:8000/submit": {"weight": 2},
                "http://127.0.0.1:8001/submit": {}, # weight value = 1
            },
        )
    

You can now head towards the following dedicated guides showing you how to:

*   [Register in the Almanac contract](https://network.fetch.ai/docs/introduction/almanac/register-in-almanac).
*   [Communicating with other agents](https://uagents.fetch.ai/docs/guides/communication) .

Last updated on

May 14, 2025

[Setting up the ASI Alliance extension wallet with a Ledger hardware wallet](https://network.fetch.ai/docs/guides/asi-wallet/asi-wallet-hardware-connection-guide "Setting up the ASI Alliance extension wallet with a Ledger hardware wallet")</content>
</page>

<page>
  <title>Registering in Almanac Contract</title>
  <url>https://network.fetch.ai/docs/introduction/almanac/register-in-almanac</url>
  <content>Overview[](#overview)
---------------------

Agents participating in any system are required to register in the **[Almanac](https://network.fetch.ai/docs/introduction/almanac/introduction) contract**. The Almanac is a smart contract developed and deployed on the Fetch.ai blockchain which provides users with a direct way to query a particular agent’s information, as well as allowing other agents to retrieve information about any specific agents registered within the contract.

Agents registration in the Almanac contract requires agents to register using their **Agent Address** and pay a fee for registration to be found by other agents on the network.

ℹ️

Check out the [Communicating with other agents](https://uagents.fetch.ai/docs/guides/communication)  guide to better understand how Agents make use of the Almanac to accomplish remote communication.

The system employs strict time limitations for registrations, measured in **blocks**, to ensure the smooth operation of a large ecosystem of agents. This limitation addresses the liveness problem by encouraging agents to periodically re-register their information within the Almanac contract, thus keeping the registration details up to date for each one of them.

Indeed, once an agent’s registration information expires due to the time limit, queries for that agent will no longer return the previously registered information.

ℹ️

This mechanism promotes the accuracy and relevance of the agents information available to others.

During each registration process, agents must prove ownership of their address. This is achieved by signing a sequence number using their agent private key and subsequently submitting the signature to the contract for verification. The sequence number should increment with each successful registration and can also be queried. These steps are automated, ensuring a streamlined registration experience for agents.

By implementing these measures, the system **guarantees** that:

*   Agents are registered in the Almanac contract.
*   Users can query registered agents information.
*   Registration is up-to-date.
*   Ownership of agents addresses is verified through signature verification.

Agents registration process[](#agents-registration-process)
-----------------------------------------------------------

### Prerequisites[](#prerequisites)

Make sure you have read the following resources before going on with this guide:

*   [Quick Start Guide for uAgents Framework](https://uagents.fetch.ai/docs/quickstart) 
*   [Creating your first agent](https://uagents.fetch.ai/docs/getting-started/create) 
*   [Agents address](https://uagents.fetch.ai/docs/getting-started/address) 

### Imports needed[](#imports-needed)

*   [uAgents](https://pypi.org/project/uagents/) 

### Walk-through[](#walk-through)

1.  First of all, create a Python script and name it:
    
2.  Open your terminal and `registration.py` file in an editor of your choice. Let’s start by importing the `Agent` class from the `uagents` library to create our Agent. This function will check if you have enough tokens to register in the Almanac contract, if not it will add testnet tokens to your `ASI Network address`. Then, create an agent, `alice`, you need to provide the `name`, `seed`, `port` and `endpoint` parameters to correctly run it! The code will look similar to the following:
    

     
    from uagents import Agent, Context, Protocol
     
    agent = Agent(
        name="alice",
        port=8000,
        seed="alice secret phrase",
        endpoint=["http://127.0.0.1:8000/submit"],
    )
     
    @agent.on_interval(period=3)
    async def hi(ctx: Context):
        ctx.logger.info(f"Hello")
     
    agent.run()
     

There’s a few things happening in this script; we initialize Alice with an endpoint. An endpoint is the address in which other agents can send messages to where Alice will be listening. As highlighted in [Registration and Endpoints Weighting](https://network.fetch.ai/docs/introduction/almanac/endpoints), agents can communicate by querying the Almanac and retrieving an endpoint from the recipient agent. Therefore, we need to specify the service endpoints when defining our agents.

We also have to define `agent.run()`. This `.run()` function runs the agent, but more importantly this registers the agent to the Almanac when code is initialized.

Once you run your script, your agent will start the registration process automatically. Finally, it will try to register on the Almanac contract. Then, we will be ready to start to a remote communication with other agents registered within the Almanac contract. The output should be similar to:

    INFO:     [Alice]: Registration on Almanac API successful
    INFO:     [Alice]: Registering on almanac contract...
    INFO:     [Alice]: Registering on almanac contract...complete
    INFO:     [Alice]: Hello
    INFO:     [Alice]: Agent inspector available at https://agentverse.ai/inspect/?uri=http%3A//127.0.0.1%3A8000&address=agent1qfccl7xc2hrwzntx9rxgf56lh80kuf5av6h4nyk3ywvxyu846zqwyl3g0jf
    INFO:     [Alice]: Starting server on http://0.0.0.0:8000 (Press CTRL+C to quit)
    INFO:     [Alice]: Hello
    INFO:     [Alice]: Hello
    INFO:     [Alice]: Hello

The output for the above code would be similar to the following:

    INFO:     [alice]: Registration on Almanac API successful
    INFO:     [alice]: Registering on almanac contract...
    INFO:     [alice]: Registering on almanac contract...complete
    INFO:     [alice]: Agent inspector available at https://agentverse.ai/inspect/?uri=http%3A//127.0.0.1%3A8000&address=agent1q0c5m0ugjml6rwa05fwe8wecqnxjc8vk6grqwlylpp9h4nfzxm4cyaha7r8
    INFO:     [alice]: Starting server on http://0.0.0.0:8000 (Press CTRL+C to quit)
    INFO:     [alice]: Hello
    INFO:     [alice]: Hello
    INFO:     [alice]: Hello</content>
</page>

<page>
  <title>ASI Wallet Companion App</title>
  <url>https://network.fetch.ai/docs/guides/asi-wallet/companion-app</url>
  <content>Introduction[](#introduction)
-----------------------------

Within the ASI Network, an essential tool is the **Agent Network Hub** which works similarly to any block explorer, thus offering the opportunity for users to navigate and analyze the Fetch.ai blockchain network data and related information.

You can access the Agent Network Hub [here](https://hub.fetch.ai/fetchhub-4/blocks) .

Overall, an explorer provides a user-friendly interface for viewing and tracking on-chain activities, including transactions, blocks, smart contracts, wallet addresses and so on. By allowing users to search for and verify blockchain data, a block explorer serves as an essential resource for developers, researchers, and anyone looking to understand the workings of a blockchain ecosystem.

Agent Network Hub Functionalities[](#agent-network-hub-functionalities)
-----------------------------------------------------------------------

### Blocks Page[](#blocks-page)

The **Blocks** page of the Agent Network Hub UI provides a detailed breakdown of each specific block, making it easy for users to analyze individual transactions and understand the context of on-chain activities. It is useful for developers, network validators, and anyone looking to verify or trace transactions on the blockchain.

The Block Summary provides a high-level overview of recent network activity, including:

*   **Block Height**: it indicates the latest block number on the blockchain.
*   **Block Count (last 24h)**: it shows the number of blocks created in the past 24 hours.
*   **Transaction Count (last 24h)**: it displays the total number of transactions processed in the last 24 hours.
*   **Block Time**: it is the average time it takes to create a new block, measured in seconds.

On the other hand, the _Recent Blocks_ section provides a table that lists the most recent blocks added to the blockchain, thus making it easy for users to track historical block data. The page offers multiple data details, including:

*   **Block Number (Hash)**: it displays the unique block number and its associated hash. Clicking on the block number or hash may lead to a detailed block view.
*   **Created At**: it is the timestamp when the block was created, along with how long ago it occurred.
*   **Proposer**: it is the validator that proposed the block. Validators’ names (e.g., Kiln, Altruistic Automaton, Blockscope.net) are shown alongside their icons or logos.
*   **Transaction Count (Tx count)**: it is the number of transactions included within each block.

You can click on a specific Block, you can enter the _Block Details_ page. This page provides in-depth information about the specific block on the blockchain:

Here, you can explore multiple information about the specific Block you choose, including:

*   **Block Height**: it indicates the block’s position in the blockchain.
*   **Block Time**: it displays the time the block was created, with the timestamp and time elapsed. It also indicates if the block time is Expected or otherwise.
*   **Proposer**: it is the validator who proposed the block which is shown with a corresponding logo or icon.
*   **Transaction Count (Tx counts)**: it is the number of transactions included in the block.
*   **Gas Used / Wanted**: it is the amount of gas used by the block’s transactions compared to the total gas available.
*   **Hash**: it is the unique hash representing the block, which you can copy if needed.

In the _Transactions Section_, you have an overview of all details related to all transactions included in that specific block, including:

*   **Transaction Hash (Tx hash)**: it is the unique identifier for each transaction. Clicking on the hash leads to a detailed transaction view.
*   **Time**: it is the timestamp when the transaction was included in the block.
*   **Result**: it is the status of the transaction.
*   **Messages**: it describes the action taken.
*   **Height**: it is the block height where the transaction is recorded.

### Transactions Page[](#transactions-page)

The **Transactions** page provides a comprehensive view of the transactions activity on the Network. It allows users to monitor recent transactions, assess network activity over different time periods, and verify individual transaction details.

Then _Transactions Summary Section_ provides an overview of the transaction statistics:

*   **Total Transactions**: it is the cumulative number of transactions processed on the network.
*   **Transactions (last 30 days)**: Number of transactions processed over the past 30 days.
*   **Transactions (yesterday)**: Transactions that occurred on the previous day.
*   **TPS (Last 20 blocks)**: it is the average Transactions Per Second (TPS) calculated based on the most recent 20 blocks.

Within the Transactions table, you have a view of each individual transactions with the following details:

*   **Transaction Hash (Tx hash)**: It is the unique identifier for each transaction.
*   **Time**: it is the time at which the transaction was processed.
*   **Result**: it shows the status of the transaction.
*   **Messages**: it indicates the type of action performed.
*   **Height**: it indicates the block height in which the transaction was included.

By clicking on the _Transaction Hash_, you will be redirected to the _Transaction Details_ page where you will be able to find all needed information about that specific transaction, as shown below:

### Accounts Page[](#accounts-page)

The **Accounts** Summary page provides an overview of account data, including:

*   **Daily Active Accounts**: the number of accounts that were active in the last 24 hours.
*   **Monthly Active Accounts**: the amount of accounts active in the past month.
*   **90d Active Accounts**: the total number of accounts active in the last 90 days.

You can choose among multiple options to explore **Accounts**: _Rich List_, _Most Activators_ and _Trends_. Within the _**Rich List**_ option, you can view the top accounts ranked by their FET holdings with the multiple details, including the Accounts Address and amounts of FET being held by each account.

The _**Most Activators**_ tab displays the top accounts ranked by their transaction activity, and provides information about the total number of transactions initiated by each account.

On the other hand, the _**Trends**_ tab provides an interactive visualization of Accounts activity over time, thus offering insights into the dynamics of user engagement within the network. This helps to identify patterns (e.g., growth or decline in activity levels), and assist stakeholders in enhancing their understanding of user engagement on the network over time.

### Agents Page[](#agents-page)

The **Agents** page provides a comprehensive overview of the [Agents](https://uagents.fetch.ai/docs/)  currently active on the ASI Network. Agents are autonomous entities that can interact with each other and the broader digital economy. They play a crucial role in enabling decentralized applications and services.

On this page, you can find valuable information about the Agents available on the Network, including:

*   **Total Agents**: this is the total amount of Agents being registered on the Network.
*   **Active Registrations**: this is the number of Agents being currently active.
*   **Protocols**: the overall amount of [Protocols](https://uagents.fetch.ai/docs/guides/protocols)  being in use within the Network.
*   **Domains**: it is the number of Agents Domains being registered on the Network.

The pie chart offers a visual representation of the distribution of Agents based on their domain ownership and registration status.

By selecting a specific Agent, and by clicking on a specific Agent Address, you will be redirected to the Agents Details page:

Here, you are able to explore multiple details about any Agent, including the following:

*   **Agent Address**: the unique address of the Agent.
*   **Almanac Registration**: the current status of the Agent’s registration in the [Almanac Contract](https://network.fetch.ai/docs/introduction/almanac/introduction).
*   **Registration time** and **expiry date**.

In this page, you are also able to check for **Protocols** and **Domains** related to that particular Agent.

To learn more about how to create and manage Agents, check out our [documentation](https://uagents.fetch.ai/docs/)  and Agent guides. By understanding Agents, you can unlock the full potential of the ASI Network and build innovative decentralized applications.

### Validators Page[](#validators-page)

The **Validators** page of the Agent Network Hub UI provides an overview of the blockchain’s validators, helping users analyze their performance, participation, and overall contribution to network security. It is particularly useful for delegators, network participants, and developers who want to track validators’ statistics.

#### Validators Summary[](#validators-summary)

The **Validators Summary** section offers a high-level breakdown of validator activity, including:

*   **Active / Allocated Validators**: Displays the number of currently active validators compared to the total in the network.
*   **Onchain APR**: Shows the current annual percentage rate (APR) for staking rewards.
*   **Bonded Rate**: Shows the percentage of total staked tokens relative to the total supply.
*   **Avg. / weighted Commission**: Highlights the average commission rates taken by validators.

Once you connect your [ASI Wallet](https://network.fetch.ai/docs/guides/asi-wallet/web-wallet/get-started) to the Agent Network Hub UI, you will be able to see the refreshed table for Validators based on your Stakes amount:

The **Validators Table** provides a detailed list of active validators with key metrics, including:

*   **Rank**: Indicates the validator’s ranking based on voting power.
*   **Validator**: Displays the validator’s name, logo, and identity.
*   **Voting Power**: Shows the total stake delegated to the validator, representing their influence in consensus.
*   **Commission**: Displays the fee percentage charged by the validator on delegated rewards.
*   **Uptime & Missed Blocks**: Highlights validator reliability, showing uptime percentage and recent missed blocks.
*   **Participation**: Measures how actively the validator participates in the network.
*   **Delegators**: The number of users delegating stakes to each specific validator.
*   **Stake**: Amount payable to stake with a specific validator.

Each validator has a menu (… button) allowing users to manage their stakes:

*   **Stake**: Delegate FET tokens to the selected validator.
*   **Unstake**: Withdraw staked tokens from the validator.
*   **Claim Rewards**: Collect earned staking rewards.

#### Validators Details[](#validators-details)

Users can click on a specific validator to access the **Validator Details** Page, which provides an in-depth view of their performance and activity.

This page offers comprehensive information about a selected validator, including:

*   **Validator details**: Shows the validator’s name, logo, address, description and related website.
*   **Voting Power**: Displays the validator’s total stake and percentage of total network stake.
*   **Commission Rate**: Shows the fee structure for delegators.
*   **Expected APR**: Estimated annual percentage rate.
*   **Delegators**: the number of delegators supporting the validator and their respective stakes.
*   **Uptime History**: Provides a % indicating the validator’s reliability and availability performance.
*   **Bonded Tokens**: Indicated the total delegated stake.
*   **Self Bonded Tokens**: It is the amount staked by the validator itself.
*   **Start Height**: Indicates the block number at which the validator first became active on the network.
*   **Uptime / Block Miss**: Uptime refers to the validator’s availability and reliability in signing and proposing blocks. Block Miss stands as the number of blocks the validator failed to sign or propose within a given tracking period. The relationship between these two values indicates the amount of blocks being missed overall and stands as a measure of reliability into the specific validator.
*   **Window Block Miss**: It is the number of missed blocks in the current tracking window.

Within the Validator’s _Details_ page, users can interact with the specific validator through the dedicated buttons available in the UI:

*   **Claim rewards**: Collect earned staking rewards.
*   **Redelegate**: Transfer staked tokens to another validator without unstaking first.
*   **Unstake**: Withdraw FET tokens from the validator.
*   **Stake**: Delegate FET tokens to this validator.

##### Proposed Blocks tab[](#proposed-blocks-tab)

Within the **Proposed Blocks** tab available at the bottom of the validator’s Details page, users are able to see a list of blocks that this validator has proposed as part of its role in the network. Here, you can explore the following information:

*   **Height**: The block number in the blockchain. Higher number means a more recent block.
*   **Block Hash**: It is the unique cryptographic identifier for the block.
*   **Tx Count (Transaction Count)**: The number of transactions included in the block. Higher transaction counts indicate active participation in processing transactions.
*   **Created At**: The timestamp when the block was proposed.

These details and information helps users track if the validator is actively participating in block proposals, ensuring its reliability and trustworthiness.

##### Power Events tab[](#power-events-tab)

The **Power Events** tab provides a historical record of events that have impacted the validator’s voting power. Users can check the following information within this tab:

*   **Height**: This refers to the block height at which the power event occurred. It essentially pinpoints the event’s location within the blockchain’s timeline.
*   **Tx Hash**: This is the unique transaction hash associated with the power event. You can click on it to view the transaction details on the explorer.
*   **Amount**: This indicates the change in the validator’s voting power. A positive value signifies an increase in power, while a negative value represents a decrease.
*   **Time**: This is the timestamp of when the power event occurred.

##### Delegators tab[](#delegators-tab)

Lastly, within the **Delegators** tab, users can check out the information about those users who have delegated their tokens to the selected validator, including:

*   **Delegator**: This column lists the addresses of the users who have delegated their tokens to the validator.
*   **Amount**: This column indicates the amount of tokens each delegator has staked with the validator.
*   **Updated At**: This column shows the timestamp of when the delegation was last updated.

##### Claim rewards, Redelegate, Unstake and Stake[](#claim-rewards-redelegate-unstake-and-stake)

Within each specific validator’s details page, users have the options to manage rewards as well as staked/delegated tokens to that particular validator. They can do this by clicking on the dedicated buttons: **Claim rewards**, **Redelegate**, **Unstake** and **Stake**.

For instance, by clicking the **Stake** button, a side panel will appear showing you different data about the Stake operation:

This way, you can directly stake FET tokens with the validator of your choice. You will need to provide the Amount of tokens you wish to stake as well as the name of the Validator you want to stake your tokens with. You can also add a _memo_ field for information you wish to add to the transaction. Once you are satisfied, click on the **Stake** button. You will see a summary showing up for the operation. Then, click on **Confirm** and **Approve** the transaction within your ASI Wallet.

### Proposals Page[](#proposals-page)

The **Proposals** page of the Agent Network Hub UI provides an overview of the Governance Proposals taking place within the ASI network.

This page allows users to check out the total number of proposals, their status, and voting outcomes. Users can track past proposals along with their approval or rejection status. The page helps ensure transparency in network governance and allows users to stay informed about decisions affecting the ASI ecosystem.

#### Proposals summary and details[](#proposals-summary-and-details)

The **Proposals Summary** page provides an overview of all Proposals. It displays the Total amount of Proposals and current available ones under Voting Period Proposals. This page provides multiple details for each governance proposal:

*   Proposal ID
*   Title
*   Type
*   Your Vote
*   Status
*   Voting End On

By switching **My Votes** toogle on, you will be able to filter proposals and see just those for which you voted previously. By clicking on a particular proposal, you will be able to explore additional details through the **Proposal Details** page:

Through the details page, users are able to explore in a more detailed manner all the aspects of a specific proposal, starting with actual votes, voting details and description. You can check out the proposal’s description at the bottom within the **Description** section:

Instead, by clicking on the **Json** tab, you will be able to explore the Proposal’s details in json format:

#### How to vote for Proposals[](#how-to-vote-for-proposals)

Whenever you wish to participate in a Governance Proposals voting, you will need to open the related Proposal’s details page by clicking on the Proposal itself within the Proposals page in the Agent Network Hub. Once you open the proposal’s details page, if the proposal voting period hasn’t still ended, then you should be able to see a **Vote** button at the top of the page:

By clicking on this one, a drop-down menu will appear with multiple options:

By selecting one of the voting options displayed, you will have your vote being registered and the UI will refresh. You should be able to see something similar to the following:

### Reconciliation Page[](#reconciliation-page)

The **Reconciliation Service** enables users with Hardware Wallets to recover funds migrated from the Fetch Staking platform on Ethereum to the Fetch Mainnet. By linking their [ASI Alliance Wallet](https://network.fetch.ai/docs/guides/asi-wallet/web-wallet/get-started) and Metamask, users can securely associate their Ethereum staking address with a Fetch recovery address to restore access to their tokens. Within this tab you can also access the **CUDOS Tokens Transfer** UI if you have either Locked or Convertible CUDOS Tokens in your wallet.

You can access these services via the [Agent Network Hub](https://hub.fetch.ai/fetchhub-4/reconciliation)  and follow the steps provided. For a detailed overview, see the [Reconciliation](https://network.fetch.ai/docs/guides/network/reconciliation-service) or the [IBC CUDOS Tokens Transfers](https://network.fetch.ai/docs/guides/network/ibc-transfers) guides for a better understanding.</content>
</page>

<page>
  <title>ASI Alliance Wallet</title>
  <url>https://network.fetch.ai/docs/guides/asi-wallet/mobile-wallet/get-started</url>
  <content>Installation[](#installation)
-----------------------------

1.  Install the **ASI Alliance Wallet** app on your device. This wallet is compatible with all Android and iOS versions. You can find it by searching for **ASI Alliance Wallet** on the **Google Play Store** or the **App Store**, or by using the following link:
    *   [Play Store](https://play.google.com/store/apps/details?id=com.fetchai.wallet) 
    *   [App Store](https://apps.apple.com/in/app/fetch-ai-wallet/id1641087356) 

On Boarding[](#on-boarding)
---------------------------

Launch the ASI Alliance Wallet app, and you will see 2 options:

*   Create a new wallet
*   Import a wallet

### Create a new Wallet[](#create-a-new-wallet)

By choosing this option, you will have to choose across multiple options as shown below:

**Note**: Continue with Apple only available in iOS devices.

#### Continue with Google[](#continue-with-google)

1.  Choose **Continue with Google**.
2.  Pick the Google account you wish to use for continuing with this Fetch account.

#### Create New seed phrase[](#create-new-seed-phrase)

By choosing this option, you will be provided with a mnemonic seed phrase. Make sure to securely backup your mnemonic seed in a safe place.

You will be then asked to confirm the seed phrase. To confirm your mnemonic seed, reorder the mnemonic phrases by clicking on them in the proper sequence.

Last, you will need to provide a **Name** and **Password** for your account. The next time you wish to use the wallet or make significant changes to your account, this password will be required.

All ready! You now have everything set to begin your ASI Alliance Wallet journey.

### Import a wallet[](#import-a-wallet)

By choosing this option will be asked to choose across the following options:

#### Import From ASI Alliance extension[](#import-from-asi-alliance-extension)

1.  Whenever a user accesses the mobile app and already has an account created on the web extension, they can utilise the **Import from ASI Alliance extension** function to access all their extension accounts on their phone.

2.  To do this, the user needs to navigate to:
    
    1.  The **hamburger menu** on the web extension, select **Settings**.
    2.  Then, choose **Link ASI Alliance Wallet**.
    3.  After entering the password, they can scan the barcode to link all their accounts from the web extension to the mobile app.

#### Use a seed phrase or a private key[](#use-a-seed-phrase-or-a-private-key)

1.  When a user opens the mobile app and already has an account created on the web extension, they can import their existing account into the mobile app.
2.  Using **Mnemonic Seed** or **Private Key**. The user can choose to import their account by pasting the mnemonic seed (12 or 24 words) or the private key.

3.  And additionally, they can input the name of the account and set a password for it.

4.  After completing the import process and providing necessary details, the user’s existing account is successfully set up and ready to use in the mobile app.

#### Connect Ledger[](#connect-ledger)

If you use the ASI Alliance Wallet together with a Ledger hardware wallet and want to retain your key and mnemonics there.

1.  Select **Connect ledger**.
2.  Set a password for your account and give it a name. The next time you wish to use the wallet or make significant changes to your account, this password will be required. [Click here for More Details](https://network.fetch.ai/guides/fetch-network/asi-wallet/mobile-wallet/ledger-guide)

#### Migrate from ETH[](#migrate-from-eth)

1.  Select **Migrate from ETH**.
2.  On the next page, click **Migrate a Meta mask Private Key**.

3.  After that, You will then be taken to the main import screen, where you can name the key, specify the **ETH address** you are migrating from, which in this case is your Meta mask ETH address (this is used to ensure that the private key matches), and finally copy the private key from your Meta mask account.

4.  If this is your first key in the wallet, you will be prompted to create a global password for your wallet. The password will be required the next time you use the wallet or make changes to your account.
    
5.  After completing the import process and providing necessary details, the user’s existing account is successfully set up and ready to use in the mobile app.
    

Last updated on

May 14, 2025

[Registration and endpoints weighting](https://network.fetch.ai/docs/introduction/almanac/endpoints "Registration and endpoints weighting")</content>
</page>

<page>
  <title>How to use ASI Alliance Wallet</title>
  <url>https://network.fetch.ai/docs/guides/asi-wallet/mobile-wallet/home-screen</url>
  <content>Feature 1 - Dashboard[](#feature-1---dashboard)
-----------------------------------------------

When a user opens the mobile app for the first time, they are presented with the **Account Dashboard**.

Let’s explore the Dashboard features below.

### Dashboard Features[](#dashboard-features)

#### Network Selector Option[](#network-selector-option)

By clicking on **Network Selector** button, the user can change the network.

|  |  |
| --- | --- |

#### Scanner Button[](#scanner-button)

Clicking on the scanner button allows the user to scan **QR codes** of other accounts for transactions.

|  |  |
| --- | --- |

#### Chat Button[](#chat-button)

**This feature is upcoming and not available yet**. Through this feature, users will be able to communicate with other users and Agents registered register on the network. Users can chat with autonomous agent to ask questions and perform wallet functions.

#### Copy Address[](#copy-address)

By clicking on **Copy**, the user can copy their account’s address.

#### Three Dots (More Options)[](#three-dots-more-options)

You can access more functions and options by clicking on the 3 dots symbol as shown below:

##### Add New Account[](#add-new-account)

Allows the user to create a new account, as described earlier.

##### Change Account[](#change-account)

If the user has multiple accounts, they can switch between them here.

##### Rename Account[](#rename-account)

Enables the user to change the name of their account.

##### Delete Wallet[](#delete-wallet)

This provides the option to delete a wallet/account.

|  |  |
| --- | --- |

User can also backup their mnemonic seed of account before deleting it by using this functionality.

|  |  |
| --- | --- |

### Viewing Account Information[](#viewing-account-information)

#### Current Balance[](#current-balance)

The user can see their current balance in FET (Fetch tokens) and in USD.

#### Portfolio[](#portfolio)

By clicking on the **View Portfolio** button, users can view their portfolio’s performance over time as well as its composition.

|  |  |
| --- | --- |

Clicking on any **Token tab** would redirect users to the related token detail page.

**Stats** tab displays the staking information.

#### Portfolio Performance[](#portfolio-performance)

In the Home screen, the user can track their portfolio performance over various timeframes (from 24 hours to 1 year).

Last updated on

May 14, 2025

[Registration and endpoints weighting](https://network.fetch.ai/docs/introduction/almanac/endpoints "Registration and endpoints weighting")</content>
</page>

<page>
  <title>How to use ASI Alliance Wallet</title>
  <url>https://network.fetch.ai/docs/guides/asi-wallet/mobile-wallet/send-receive</url>
  <content>Feature 3 - Send/Receive Functionalities[](#feature-3---sendreceive-functionalities)
------------------------------------------------------------------------------------

### Send/Receive Button[](#sendreceive-button)

This button allows the user to perform transaction send and receive functions. By utilizing this feature, users can send and receive transactions seamlessly within the app.

Send Option[](#send-option)
---------------------------

### Initiate Transfer[](#initiate-transfer)

If a user wants to send money to another user, they should start by locating the transaction button.

### Select Send Option[](#select-send-option)

Once the transaction button is found, the user selects the option to send money.

### Enter Amount and Account[](#enter-amount-and-account)

After selecting the send option, the user needs to enter the amount they wish to send and choose the account from which the money will be transferred.

### Add Recipient’s Address[](#add-recipients-address)

Next, the user is prompted to add the recipient’s address. This can be done in two ways: either by **scanning the address** or by using the **Add to contact** option.

### Review Transaction[](#review-transaction)

After adding the recipient’s address, the user should review the transaction details to ensure accuracy.

### Optional: Add Memo[](#optional-add-memo)

If the user wishes to add a memo to the transaction, they can do so at this stage.

ℹ️

**Fetch transaction memo limits and storage details**

1.  **Character/size limitations**: the memo field is limited to _256 bytes_ by default. This is configurable and can be changed via a governance proposal if needed. To check the current value programmatically, you can query the `auth` module parameters [here ↗️](https://rpc-fetchhub.fetch.ai/abci_query?path=%22custom/auth/params%22)  and decode the response by copy-pasting there inner content of `value` (without quotes). You’ll receive a base64-encoded response containing the parameters, which you can decode to view the structure, including the `max_memo_characters`, `tx_sig_limit`, and `tx_size_cost_per_byte` parameters.
    
2.  **Limitations**: while you can add any data within the 256-byte limit, the memo field is intended for _short text_. Adding structured or binary data (e.g., blob attachments) is technically possible within the size constraint, but it isn’t recommended due to potential gas costs and inefficiency. If you wish to store larger or more complex data, consider using other data storage methods, as encoding this data in the memo could potentially exhaust gas and processing limits. The current **gas constraints** are set up:
    
    *   Each byte stored in a transaction costs 10 gas (as set by `tx_size_cost_per_byte`).
    *   The maximum gas per block is 3,000,000 gas, which limits the total data that can be stored in a block.
    *   While the block size limit is 300,000 bytes, the gas cost to store data near this size would max out the block’s gas limit. Therefore, block gas constraints often restrict the size of a transaction more than the byte limit alone.
3.  **On-chain storage and migrations**: once a transaction with a memo is added to a block, the memo data is stored permanently on-chain. During migrations, all transaction data, including the memo, should remain intact, as existing chain data should be preserved once migration is finalized.
    

**Approve Transaction**: once the user has reviewed the transaction and made any necessary additions, they can proceed by clicking on the **Approve transaction** button.

### Transaction Confirmation[](#transaction-confirmation)

Upon approval, a transaction ID is generated, confirming that the transaction has been successfully processed.

Receive Option[](#receive-option)
---------------------------------

### Initiate Transaction[](#initiate-transaction)

If a user wants to **Receive money** from another user, they should start by locating the transaction button.

### Select Receive Option[](#select-receive-option)

Once the transaction button is found, the user selects the option to Receive money.

### Choose Payment Method[](#choose-payment-method)

Determine the preferred method of payment, whether it’s scanning a QR code or fetching the recipient’s account address.

### Complete Transaction[](#complete-transaction)

Once the payment method is selected and the necessary details are provided, proceed to complete the transaction.</content>
</page>

<page>
  <title>How to use ASI Alliance Wallet</title>
  <url>https://network.fetch.ai/docs/guides/asi-wallet/mobile-wallet/stake</url>
  <content>Feature 2 - Stake[](#feature-2---stake)
---------------------------------------

### Stake Dashboard[](#stake-dashboard)

1.  By clicking on the **Stake** icon, users are redirected to the **Stake Dashboard** where they can see their available, staked, and claimable amounts. The dashboard also contains a list of validators in which users have staked.
2.  The **Stake more** button allows users to stake with a variety of other validators. For a detailed walk - through, refer to **Stake Functions** .
3.  **Staking rewards** provide information on the claimable amounts for all staked validators. Users can claim the entire amount or choose to claim from specific validators by clicking **View rewards**.
4.  **Staked balances** provide an overview of staked tokens amounts.

### Stake Functions[](#stake-functions)

1.  The dashboard view is dynamic, appearing differently when the user hasn’t staked yet. In this case, the user will see **Start Staking** or **Stake More**, both of which perform the same function. Clicking the button redirects to the **Validators List**, where users can filter validators by **APR**, **Voting Power**, and **Name**.
    
2.  Clicking on any validator box will redirect you to its details page; this allows the user to proceed with staking by providing the necessary transaction information. Once the transaction is completed, it will be displayed on the staking dashboard.
    

|  |  |  |
| --- | --- | --- |

### Unstake Functions[](#unstake-functions)

Unstaking involves withdrawing the staked amount from a validator. Follow these steps to unstake your tokens:

1.  Open the **Stake Dashboard** view.
2.  Scroll to the staked balances section and select the validator.
3.  Click the **Unstake** button.

If you withdraw the entire staked amount, you will see a _21-day unstaking process_ view for that token.

|  |  |  |  |
| --- | --- | --- | --- |

### Redelegate Functions[](#redelegate-functions)

Redelegating involves moving funds from one validator to another. Follow these steps to successfully redelegate your tokens:

1.  Open the **Stake Dashboard** view.
2.  Scroll to the staked balances section and select the validator.
3.  Click the **Redelegate** button.
4.  Select the new validator where you want to stake the balance.
5.  Fill in the necessary information and proceed with the transaction.

|  |  |
| --- | --- |

### Claim Rewards[](#claim-rewards)

**Staked rewards** can be claimed from multiple locations:

1.  Home Tab
2.  Portfolio
3.  Stake Tab
4.  Stake Token Detail

After successfully withdrawing rewards, they will be displayed on the staking dashboard.

|  |  |  |
| --- | --- | --- |

Last updated on

May 14, 2025

[Registration and endpoints weighting](https://network.fetch.ai/docs/introduction/almanac/endpoints "Registration and endpoints weighting")</content>
</page>

<page>
  <title>How to use ASI Alliance Wallet</title>
  <url>https://network.fetch.ai/docs/guides/asi-wallet/mobile-wallet/gov-proposal</url>
  <content>Feature - Gov Proposal[](#feature---gov-proposal)
-------------------------------------------------

Governance proposal is a system for managing and implementing changes to cryptocurrency blockchains. In this type of governance, voting systems for instituting changes are programmed into the blockchain. Developers propose changes, and each stakeholder votes on whether to accept or reject the proposed change. Blockchain stakeholders might be developers, validators, token holders, or anyone else the blockchain is designed to include.

*   Open ASI Alliance Wallet Dashboard.
*   Navigate to **More Tab**.
*   Look for and select the **Proposals** option.

|  |  |
| --- | --- |

*   Clicking on any proposal navigates the user to the detail page.
*   The detail page provides all the necessary information about the proposal.
*   Users can vote or change their vote if the proposal is in an active status.

Last updated on

May 14, 2025

[Registration and endpoints weighting](https://network.fetch.ai/docs/introduction/almanac/endpoints "Registration and endpoints weighting")</content>
</page>

<page>
  <title>Steps to Connect Ledger Hardware Wallet via Bluetooth</title>
  <url>https://network.fetch.ai/docs/guides/asi-wallet/mobile-wallet/ledger-guide</url>
  <content>Feature 7 - Ledger Guide[](#feature-7---ledger-guide)
-----------------------------------------------------

### Step 1 : Navigate to the Register Screen[](#step-1--navigate-to-the-register-screen)

*   Open the app and go to the **Home** screen.
*   Tap the three-dot icon and select **Add New Wallet**.

> **Note** : New users will be automatically redirected to the **Register** screen.

### Step 2 : Select Import a Wallet[](#step-2--select-import-a-wallet)

*   On the Register screen, tap **Import a Wallet**.
*   Choose **Connect Hardware Wallet** and fill in the required information.

|  |  |
| --- | --- |

### Step 3 : Enable Bluetooth & Location (If Required)[](#step-3--enable-bluetooth--location-if-required)

Depending on your device type, follow these instructions :

##### _**For iOS Users**_ :[](#for-ios-users-)

*   Navigate to **Settings > Bluetooth**.
*   Enable Bluetooth and **allow new connections**.

##### **For Android Users** :[](#for-android-users-)

*   Navigate to **Settings > Bluetooth** or **Location**.
*   Enable Bluetooth and Location, then **allow new connections**.

|  |  |
| --- | --- |

### Step 4 : Connect Ledger Device[](#step-4--connect-ledger-device)

*   Tap **Continue** on the app. A pop-up will appear.
*   The app will prompt you to:
*   **Unlock your Ledger device**.
*   **Open the Cosmos app** on the Ledger device.
*   Once detected, the app will display Ledger device details.
*   Tap **Device Info** to start the pairing process.
*   Follow on-screen instructions to complete the setup of your hardware account.

|  |  |  |  |
| --- | --- | --- | --- |

#### Additional Notes :[](#additional-notes-)

*   Ensure your Ledger device is sufficiently charged before pairing.
*   If you face connection issues, try restarting Bluetooth and reconnecting.
*   Refer to the [attached video](https://network.fetch.ai/guides/fetch-network/asi-wallet/mobile-wallet/get-started#connect-ledger) for a visual walkthrough of these steps.

* * *

Last updated on

May 14, 2025

[Registration and endpoints weighting](https://network.fetch.ai/docs/introduction/almanac/endpoints "Registration and endpoints weighting")</content>
</page>

<page>
  <title>How to use ASI Alliance Wallet</title>
  <url>https://network.fetch.ai/docs/guides/asi-wallet/mobile-wallet/more</url>
  <content>Feature 5 - More Options[](#feature-5---more-options)
-----------------------------------------------------

*   Open ASI Alliance Wallet Dashboard.
*   Navigate to **More Tab**.

### More Option - Currency[](#more-option---currency)

Within this section, you can set the currency configuration for your wallet. You can do so following these steps:

*   Access **Currency** option.
*   Within **More**, locate and select the **Currency** option.

*   Here, you can change the currency from USD to any other available currency.

### Manage Token[](#manage-token)

In the **Manage Tokens** section, you can view the tokens you’ve added and their details.

You can add new tokens by clicking on the **+** sign next to the tokens list.

### Address Book[](#address-book)

*   Access the **Address Book** section.

*   View **Existing** addresses.

### Add an Address[](#add-an-address)

You can **Add a new address** by clicking on the **+** sign button.

### Edit an Address[](#edit-an-address)

*   If you need to edit an address:
    *   Click on the **three dots** (…) next to the address.

*   Select **Rename** option.

*   From there, you can edit the address **Name**, **Memo**, and **Address** itself.

### Delete Address[](#delete-address)

*   To **Delete an address**:
    *   Click on the **three dots** (…) next to the address.

*   Select the **Delete Address** option to remove it.

*   Click on **Remove** option.

### Security and Privacy Options[](#security-and-privacy-options)

*   Explore the **Security and Privacy** section. Here, you can:
    
    *   View your mnemonic seed after entering your password.

*   Click on **View Mnemonic seed** option.

*   View your mnemonic seed after entering your password.

*   Users can copy the mnemonic seed by clicking **Copy to Clipboard**.

### ASI Alliance Wallet Version[](#asi-alliance-wallet-version)

You can check the version of the app under the **ASI Alliance Wallet** option.

|  |  |
| --- | --- |

Last updated on

May 14, 2025

[Registration and endpoints weighting](https://network.fetch.ai/docs/introduction/almanac/endpoints "Registration and endpoints weighting")</content>
</page>

<page>
  <title>ASI Alliance Wallet</title>
  <url>https://network.fetch.ai/docs/guides/asi-wallet/web-wallet/get-started</url>
  <content>Installation[](#installation)
-----------------------------

### How to install ASI Alliance Wallet[](#how-to-install-asi-alliance-wallet)

Install **ASI Alliance Wallet** (_version 0.19.2_). The ASI Alliance Wallet is supported by all Chromium-based web browsers, including **Chrome**, **Brave**, **Edge**, **Decentr** as well as **Firefox**. You can install it for your [Chrome or Chromium-based browser here](https://chromewebstore.google.com/detail/asi-alliance-wallet/ellkdbaphhldpeajbepobaecooaoafpg?pli=1)  or [Firefox](https://addons.mozilla.org/en-US/firefox/addon/asi-alliance-wallet/) .

To install the ASI Alliance Wallet, follow these steps:

1.  Open your web browser and go to Google.
2.  Type “ASI Alliance Wallet” in the search bar.
3.  From the search results, select the first option that appears (it should match the image provided).

4.  Click on **Add to Extension** to install ASI Alliance Wallet.

5.  To use ASI Alliance Wallet, click on the ASI Alliance Wallet button in your browser. This will redirect you to the ASI Alliance Wallet landing page.

6.  After opening the Wallet, you will see options like **Create new wallet** and **Import existing wallet**.

On Boarding[](#on-boarding)
---------------------------

### How to set up ASI Alliance Wallet[](#how-to-set-up-asi-alliance-wallet)

You can choose between **Create new wallet** and **Import existing wallet**.

### Create a new Wallet[](#create-a-new-wallet)

You will need to **Create a new seed phrase**. Make sure you do not lose it!

### Create New seed phrase[](#create-new-seed-phrase)

1.  Securely backup your mnemonic seed phrase. Also make sure to accept the Terms and Conditions as shown below.

2.  **Set a password** and a **name** for your account. The next time you wish to use the wallet or make significant changes to your account, this password will be required so make sure to save it properly!

3.  You will then need to confirm the mnemonic seed, by reordering the mnemonic phrases by clicking on them in the correct sequence.
4.  User is now all set to begin your ASI Alliance Wallet journey.

Import a wallet[](#import-a-wallet)
-----------------------------------

By choosing this option, you will need to choose among 3 different option to import an existing wallet.

Let’s dive into them here below.

### Use a seed phrase or a private key[](#use-a-seed-phrase-or-a-private-key)

1.  **Mobile app**: When a user opens the mobile app and already has an account created on the web, they can import their existing account into the mobile app.
2.  **Mnemonic Seed** or **Private Key**: The user can choose to import their account by pasting the mnemonic seed (12 or 24 words) or the private key.
3.  Additionally, you can input the name of the account and set a password for it.

4.  After completing the import process and providing the necessary details, the user’s existing account will be successfully set up and ready to use in the mobile app.

#### Connect Ledger[](#connect-ledger)

If you use the ASI Alliance Wallet together with a **Ledger Hardware Wallet** and want to retain your key and mnemonics there, then:

1.  Select **Connect ledger**.
2.  Set a **password** for your account and give it a **name**. The next time you wish to use the wallet or make significant changes to your account, this password will be required. [Click here for More Details](https://network.fetch.ai/docs/guides/asi-wallet/web-wallet/ledger-guide)

#### Migrate from ETH[](#migrate-from-eth)

If you already have a Metamask account, you can import an existing wallet following these steps:

1.  Select **Migrate from ETH**.
2.  On the next page, click **Migrate a Metamask Private Key**.

3.  You will be taken to the main import screen, where you can provide the **Account Name**, the **Ethereum Address** you are migrating from (i.e., in this case, your Metamask ETH address). This is used to ensure that the private key matches. Finally, copy the **Private Key** from your Metamask account.

4.  If this is your first key in the wallet, you will be prompted to create a **global password** for your wallet. The password will be required the next time you use the wallet or make changes to your account.
5.  After completing the import process and providing the necessary details, the user’s existing account is successfully set up and ready to use in the mobile app.

Last updated on

May 14, 2025

[Registration and endpoints weighting](https://network.fetch.ai/docs/introduction/almanac/endpoints "Registration and endpoints weighting")</content>
</page>

<page>
  <title>How to use ASI Alliance Wallet</title>
  <url>https://network.fetch.ai/docs/guides/asi-wallet/web-wallet/home-screen</url>
  <content>Feature 1 - Home Screen[](#feature-1---home-screen)
---------------------------------------------------

When a user opens the web extension for the first time, they are presented with the **Account Dashboard**.

Let’s explore the Dashboard features below.

### Account Dashboard Features[](#account-dashboard-features)

#### Network Selector Option[](#network-selector-option)

By clicking on **Network Selector** button located in the top left corner, the user can change the network.

*   On opening **Network Selector**, user gets a list of networks from which they can choose.
    
*   They also have 2 tabs **Cosmos** and **EVM** to select from.
    

|  |  |
| --- | --- |

*   User can use the **Show testnet** switch to show or hide testnets.

*   User can even enable/disable the networks they want to have in the list.
*   For that user can navigate to **Manage Networks** page.

*   User can toggle to enable or disable the network.

#### Copy Address[](#copy-address)

By clicking on **the area marked below** the user can copy their account’s address.

### Three Dots (More Options)[](#three-dots-more-options)

By clicking on these 3 dots button, user will see the following options to manage their wallet:

##### Add New Account[](#add-new-account)

This option allows the user to **Add a new wallet**, as described earlier.

##### Change Account[](#change-account)

If the user has multiple accounts, they can switch across them using this functionality.

##### Rename Account[](#rename-account)

This function enables users to change the name of their account.

##### Delete Wallet[](#delete-wallet)

This functionality provides the option to delete a wallet.

|  |  |
| --- | --- |

**User can also backup their mnemonic seed of account before deleting it by clicking on Back up mnemonic seed.**

|  |  |  |
| --- | --- | --- |

### Viewing Account Information[](#viewing-account-information)

#### Current Balance[](#current-balance)

The user can see their **Current Balance** in **Selected Network’s** token and in USD.

Portfolio[](#portfolio)
-----------------------

By clicking on the **View Portfolio** button, users can view their portfolio’s stats, performance and composition.

Here user will have 2 tabs: **Tokens** and **Stats**.

By clicking on **Token** tab, users have the ability to explore the tokens page.

*   Users will be able to see price graph at different timelines but also perform **Receive** or **Send** operations by clicking on token boxes.

|  |  |
| --- | --- |

On the other hand, the **Stats** tab displays the staking information, including **Available** tokens for staking, **Staked** tokens and **Staking rewards** accrued.

### Portfolio Performance[](#portfolio-performance)

In the home screen of the Wallet, users can track their portfolio performance over various timeframes (from 24 hours to 1 year).</content>
</page>

<page>
  <title>How to use ASI Alliance Wallet</title>
  <url>https://network.fetch.ai/docs/guides/asi-wallet/web-wallet/send-receive</url>
  <content>Feature 3 - Send/Receive Function[](#feature-3---sendreceive-function)
----------------------------------------------------------------------

### Send/Receive Button[](#sendreceive-button)

This button allows the user to perform **Send** and **Receive** token operations. By using this feature, users can send and receive transactions seamlessly within the wallet.

Send Option[](#send-option)
---------------------------

### Initiate Transfer[](#initiate-transfer)

If a user wants to send money to another user, they should start by locating the **Transaction** button.

### Select Send Option[](#select-send-option)

Once the **Transaction** button is found, the user selects the option to **Send** money.

### Enter Amount and Account[](#enter-amount-and-account)

After selecting the **Send** option, the user needs to enter the amount they wish to send and choose the account from which the money will be transferred. Be sure to select the correct account on your wallet.

### Add Recipient’s Address[](#add-recipients-address)

Next, the user is prompted to add the recipient’s address. This can be done in three ways: either by **manually entering it**, **scanning the address** or by using the **Add to contact** option.

### Optional: Add Memo[](#optional-add-memo)

If the user wishes to add a **Memo** to the transaction, they can do so at this stage.

ℹ️

**Fetch transaction memo limits and storage details**

1.  **Character/size limitations**: the memo field is limited to _256 bytes_ by default. This is configurable and can be changed via a governance proposal if needed. To check the current value programmatically, you can query the `auth` module parameters [here ↗️](https://rpc-fetchhub.fetch.ai/abci_query?path=%22custom/auth/params%22)  and decode the response by copy-pasting there inner content of `value` (without quotes). You’ll receive a base64-encoded response containing the parameters, which you can decode to view the structure, including the `max_memo_characters`, `tx_sig_limit`, and `tx_size_cost_per_byte` parameters.
    
2.  **Limitations**: while you can add any data within the 256-byte limit, the memo field is intended for _short text_. Adding structured or binary data (e.g., blob attachments) is technically possible within the size constraint, but it isn’t recommended due to potential gas costs and inefficiency. If you wish to store larger or more complex data, consider using other data storage methods, as encoding this data in the memo could potentially exhaust gas and processing limits. The current **gas constraints** are set up:
    
    *   Each byte stored in a transaction costs 10 gas (as set by `tx_size_cost_per_byte`).
    *   The maximum gas per block is 3,000,000 gas, which limits the total data that can be stored in a block.
    *   While the block size limit is 300,000 bytes, the gas cost to store data near this size would max out the block’s gas limit. Therefore, block gas constraints often restrict the size of a transaction more than the byte limit alone.
3.  **On-chain storage and migrations**: once a transaction with a memo is added to a block, the memo data is stored permanently on-chain. During migrations, all transaction data, including the memo, should remain intact, as existing chain data should be preserved once migration is finalized.
    

### Review Transaction[](#review-transaction)

After adding the recipient’s address, the user should Review the transaction details to ensure accuracy.

Then, the user will need to **Approve the Transaction**. Once the user has reviewed the transaction and made any necessary additions, they can proceed by clicking on the **Approve Transaction** button.

### Transaction Confirmation[](#transaction-confirmation)

Upon approval, a **Transaction ID** is generated, confirming that the transaction has been successfully processed.

Receive Option[](#receive-option)
---------------------------------

### Initiate Transaction[](#initiate-transaction)

If a user wants to **Receive** money from another user, they should start by locating the **Transaction** button.

### Select Receive Option[](#select-receive-option)

Once the **Transaction** button is found, the user selects the option to **Receive** money.

### QR Code and wallet address[](#qr-code-and-wallet-address)

User is redirected to the Receive page, where their QR Code and wallet address can be accessed.

*   QR Code can be scanned to send the tokens.
*   Wallet address can be copied.

Native Bridge[](#native-bridge)
-------------------------------

If users want to **Native Bridge** tokens from another blockchain, then they will need to choose this option as shown below and follow the needed steps.</content>
</page>

<page>
  <title>How to use ASI Alliance Wallet</title>
  <url>https://network.fetch.ai/docs/guides/asi-wallet/web-wallet/stake</url>
  <content>Feature 2 - Stake[](#feature-2---stake)
---------------------------------------

By choosing this option, you will be redirected to the **Staking Dashboard** where you can review all of the related information.

### Stake Dashboard[](#stake-dashboard)

1.  By clicking on the **Stake** icon, users are redirected to the **Stake Dashboard** where they can see their available, staked, and claimable amounts. The dashboard also contains a list of validators in which users have staked.
2.  The **Stake more** button allows users to stake with a variety of other validators. For a detailed walk - through, refer to **Stake Functions** .

3.  **Staking rewards** provide information on the claimable amounts for all staked validators. Users can claim the entire amount or choose to claim from specific validators by clicking **View rewards**.
4.  **Staked balances** provide an overview of staked tokens amounts.

### Stake Functions[](#stake-functions)

1.  The dashboard view is dynamic, appearing differently when the user hasn’t staked yet. In this case, the user will see **Start Staking** or **Stake More**, both of which perform the same function. Clicking the button redirects to the **Validators List**, where users can filter validators by **APR**, **Voting Power**, and **Name**.
    
2.  Clicking on any validator box will redirect you to its details page; this allows the user to proceed with staking by providing the necessary transaction information. Once the transaction is completed, it will be displayed on the staking dashboard.
    

|  |  |  |
| --- | --- | --- |

### Unstake Functions[](#unstake-functions)

Unstaking involves withdrawing the staked amount from a validator. Follow these steps to unstake your tokens:

1.  Open the **Stake Dashboard** view.
2.  Scroll to the staked balances section and select the validator.

3.  Click the **Unstake** button.

If you withdraw the entire staked amount, you will see a _21-day unstaking process_ view for that token.

|  |  |
| --- | --- |

### Redelegate Functions[](#redelegate-functions)

Redelegating involves moving funds from one validator to another. Follow these steps to successfully redelegate your tokens:

1.  Open the **Stake Dashboard** view.
2.  Scroll to the staked balances section and select the validator.
3.  Click the **Redelegate** button.

4.  Select the new validator where you want to stake the balance.
    
5.  Fill in the necessary information and proceed with the transaction.
    

### Claim Rewards[](#claim-rewards)

**Staked rewards** can be claimed from multiple locations:

1.  Home Tab

2.  Portfolio

3.  Stake Tab

4.  Stake Token Detail

After successfully withdrawing rewards, they will be displayed on the staking dashboard.

Last updated on

May 14, 2025

[Registration and endpoints weighting](https://network.fetch.ai/docs/introduction/almanac/endpoints "Registration and endpoints weighting")</content>
</page>

<page>
  <title>How to use ASI Alliance Wallet</title>
  <url>https://network.fetch.ai/docs/guides/asi-wallet/web-wallet/gov-proposal</url>
  <content>Feature 6 - Gov Proposal[](#feature-6---gov-proposal)
-----------------------------------------------------

Governance proposal is a system for managing and implementing changes to cryptocurrency blockchains. In this type of governance, voting systems for instituting changes are programmed into the blockchain. Developers propose changes, and each stakeholder votes on whether to accept or reject the proposed change. Blockchain stakeholders might be developers, validators, token holders, or anyone else the blockchain is designed to include.

*   Open ASI Alliance Wallet Dashboard.
*   Navigate to **More Tab**.
*   Look for and select the **Proposals** option.

|  |  |
| --- | --- |

*   Clicking on any proposal navigates the user to the detail page.
*   The detail page provides all the necessary information about the proposal.
*   Users can vote or change their vote if the proposal is in an active status.

Last updated on

May 14, 2025

[Registration and endpoints weighting](https://network.fetch.ai/docs/introduction/almanac/endpoints "Registration and endpoints weighting")</content>
</page>

<page>
  <title>Steps to Connect Ledger Hardware Wallet</title>
  <url>https://network.fetch.ai/docs/guides/asi-wallet/web-wallet/ledger-guide</url>
  <content>Feature 7 - Ledger Guide[](#feature-7---ledger-guide)
-----------------------------------------------------

### Step 1 : Open the Extensions and Navigate to the Register Screen[](#step-1--open-the-extensions-and-navigate-to-the-register-screen)

*   Launch the extensions and go to the **Home** screen.
    
*   Tap the **three-dot menu** and select **Add New Wallet**.
    

> **Note** : If you are a new user, you will be automatically redirected to the **Register** screen.

### Step 2 : Select Import Existing Wallet[](#step-2--select-import-existing-wallet)

*   On the **Register** screen, tap **Import Existing Wallet**.
    
*   Choose **Connect Hardware Wallet** and enter the required details.
    

|  |  |
| --- | --- |

### Step 3 : Connect and Pair Your Ledger Device[](#step-3--connect-and-pair-your-ledger-device)

*   Tap **Next** button. A pop-up will appear.
    
*   The extensions will detect your **Ledger device** connected through USB and display its details.
    
*   Tap **Device Info** to begin the pairing process.
    
*   Follow the on-screen instructions to complete the setup of your hardware wallet.
    

### Additional Tips for a Smooth Connection[](#additional-tips-for-a-smooth-connection)

✔ **Ensure Your Ledger Device is Charged** – Make sure it has sufficient battery before pairing.

✔ **Troubleshooting Connection Issues** :

*   Try **reconnecting** your device.
*   If the issue persists, **restart** your Ledger device and try again.

* * *

Ledger Transactions Errors - Troubleshooting Guide
--------------------------------------------------

Error 1 : Connect and unlock your Ledger device[](#error-1--connect-and-unlock-your-ledger-device)
--------------------------------------------------------------------------------------------------

#### **Description** : This error indicates that your Ledger device is not properly connected via **USB**.[](#description--this-error-indicates-that-your-ledger-device-is-not-properly-connected-via-usb)

**Troubleshooting Steps** :

1.  Ensure the device is properly connected via USB.
    
2.  Try using a different USB cable or port.
    
3.  If the connection is secure, attempt to click the **Approve Transaction** button twice.
    
4.  Doing so may reveal the actual error related to USB permissions.
    
5.  If the issue persists, regain USB permission by following the provided troubleshooting **hyperlink**.
    

|  |  |
| --- | --- |
|  |  |

Error 2 : Unlock your Ledger device[](#error-2--unlock-your-ledger-device)
--------------------------------------------------------------------------

#### **Description** : This error means that your Ledger device is in a **locked state** and must be **unlocked before proceeding**.[](#description--this-error-means-that-your-ledger-device-is-in-a-locked-state-and-must-be-unlocked-before-proceeding)

**Troubleshooting Steps** :

1.  Press the device buttons to unlock it.
    
2.  Ensure your Ledger device is powered on.
    
3.  If the device does not respond, restart it and try again.
    

Error 3 : Unlock the Cosmos/Ethereum app on Ledger and try again.[](#error-3--unlock-the-cosmosethereum-app-on-ledger-and-try-again)
------------------------------------------------------------------------------------------------------------------------------------

#### **Description** : This error suggests that you need to open the respective **Cosmos** or **Ethereum** app on your Ledger device before proceeding with the transaction.[](#description--this-error-suggests-that-you-need-to-open-the-respective-cosmos-or--ethereum-app-on-your-ledger-device-before-proceeding-with-the-transaction)

**Troubleshooting Steps** :

1.  Navigate to the **Cosmos/Ethereum app** on your Ledger device.
    
2.  Open the respective app and ensure it is running.
    
3.  If the app is not installed, download and install it via Ledger Live : [Ledger Live Download](https://www.ledger.com/ledger-live) 
    
4.  Retry the transaction after ensuring the app is open and active.
    

* * *

Last updated on

May 14, 2025

[Registration and endpoints weighting](https://network.fetch.ai/docs/introduction/almanac/endpoints "Registration and endpoints weighting")</content>
</page>

<page>
  <title>Fetch Ledger</title>
  <url>https://network.fetch.ai/docs/introduction/ledger/ledger-intro</url>
  <content>Introduction[](#introduction)
-----------------------------

A **ledger** refers to a decentralized and distributed digital book that records all transactions across a network. This is used to ensure transparency and security of transactions and operations undertaken on that network.

Within this context, the **Fetch Ledger** developed by Fetch.ai constitutes the underlying infrastructure for various decentralized applications and contracts. It employs a consensus mechanism where [validators](https://network.fetch.ai/docs/introduction/ledger/validators) are responsible for validating transactions and creating new blocks in the [blockchain](https://network.fetch.ai/docs/introduction/ledger/validators#overview-blockchains-consensus-and-validators). The ledger utilizes Fetch native cryptocurrency, FET, which is used for various activities within the network, including transaction fees and staking. The ledger also supports features such as [multi-signature keys](https://network.fetch.ai/docs/guides/cli/multisig-keys) , allowing users to control [keys](https://network.fetch.ai/docs/guides/cli/keys) in different configurations.

The fetchhub [mainnet](https://network.fetch.ai/docs/introduction/ledger/validators#test-network-testnet-vs-main-network-mainnet) forms the core of the ASI ecosystem. In here, you will find all information to set up your client and connect on the network.

This documentation covers the things you need to know in order to prepare yourself and start developing on the ASI network.

Test networks[](#test-networks)
-------------------------------

The starting point for most users is [the test network](https://network.fetch.ai/docs/guides/ledger/references/active-networks#test-nets). Our test network (testnet) provides you with test tokens with no value, that you can safely experiment with through the [faucet](https://network.fetch.ai/docs/guides/ledger/faucet).

⚠️

This documentation is currently under construction, and the content may not be up-to-date.

Last updated on

May 14, 2025

[Setting up the ASI Alliance extension wallet with a Ledger hardware wallet](https://network.fetch.ai/docs/guides/asi-wallet/asi-wallet-hardware-connection-guide "Setting up the ASI Alliance extension wallet with a Ledger hardware wallet")</content>
</page>

<page>
  <title>How to use ASI Alliance Wallet</title>
  <url>https://network.fetch.ai/docs/guides/asi-wallet/web-wallet/more</url>
  <content>Feature 5 - More Options[](#feature-5---more-options)
-----------------------------------------------------

*   Open ASI Alliance Wallet Home Page.
*   Click **More** option on the home page.

More Page[](#more-page)
-----------------------

### Currency[](#currency)

Within this section, you can set the currency configuration for your wallet. You can do so following these steps:

*   Select **Currency** box.

*   Here, you can change the wallet currency from USD to any other available currency.

### Manage Token[](#manage-token)

In the **Manage Tokens** tab, you can:

*   View the tokens you’ve added.

*   Add new tokens by clicking on the **+** button on the upper right side or by clicking on **Add Token** button.
*   You will need to provide the needed details for the token you wish to add.

### Address Book[](#address-book)

Click the **Address Book** box.

*   You will be able to perform operation on addresses saved within the wallet.

*   You will be able to see all existing addresses.

### Add an Address[](#add-an-address)

Add a **New address** by clicking on the **+** button on the upper right side or by clicking on **Add an Address** button.

### Edit an Address[](#edit-an-address)

If you need to **Edit an address**:

*   Click on the **Edit** button next to the address.

*   From there, you can edit the address **Name**, **Memo**, and **Address** itself.

### Delete Address[](#delete-address)

*   To **Delete** an address:
    
*   Click on the **Delete** button next to the address.
    

*   Confirm.

### Language[](#language)

User can change the wallet language using this option.

|  |  |
| --- | --- |

### Security and Privacy Options[](#security-and-privacy-options)

*   Click on the **Security and Privacy** box.
*   Here you will be able to perform multiple operations related to your account’s security and privacy settings.

Here, you can:

*   View **mnemonic seed / Private key** after entering your password.
    
*   Click on View **Mnemonic seed / Private key** option.
    

|  |  |
| --- | --- |

*   View your **mnemonic seed / Private key** after entering your password.
    
*   Users can copy the **mnemonic seed / Private key** by clicking **Copy to Clipboard**.
    

|  |  |  |
| --- | --- | --- |

### Wallet Access Permission[](#wallet-access-permission)

Here you can choose which websites can access addresses or signing.

### Chain List Access[](#chain-list-access)

Here you can set which websites can access your active chain list.

### Auto-lock Timer[](#auto-lock-timer)

User can set the **Auto-Lock Timer** by clicking on this box. This way, the wallet will lock when the device is in sleep mode after provided time.

|  |  |
| --- | --- |

Others[](#others)
-----------------

### IBC Transfer[](#ibc-transfer)

Here you can perform IBC Transfer operations.

To do so:

1.  Provide the transaction details:
    
    *   **Destination chain**: the destination blockchain is called **Destination Chain**.
    *   **Recipient**: the address you want to receive the tokens is the **Recipient**.
    *   **Memo**: a memo that is optional.
2.  Click Next.
    

### Guide[](#guide)

This option redirects user to guide page to seek help.

### Sign Out[](#sign-out)

User will be able to sign out from their account using this option.

Last updated on

May 14, 2025

[Registration and endpoints weighting](https://network.fetch.ai/docs/introduction/almanac/endpoints "Registration and endpoints weighting")</content>
</page>

<page>
  <title>Validators</title>
  <url>https://network.fetch.ai/docs/introduction/ledger/validators</url>
  <content>Overview: blockchains, consensus and validators[](#overview-blockchains-consensus-and-validators)
-------------------------------------------------------------------------------------------------

A **blockchain** is a series of data records that functions as a distributed, replicated digital ledger of transactions across a network of computer systems. On blockchains, the records of transactions are compiled into **blocks** which are linked together to form a chain. Thus, blockchains consists of a stable chain of blocks and each one of these blocks stores a list of previously confirmed transactions.

These transactions take place inside a peer-to-peer (P2P) global network, thus, blockchains are considered minimize and immune to censorship. A blockchain network serves as a decentralized ledger since it is maintained by several computers located all over the world. This implies that each participant, namely a **node**, keeps a copy of the blockchain data and interacts with other participants to make sure that everyone is aware of the same information stored in the block.

A blockchain, including the **Fetch.ai Ledger**, provides a secure and transparent way to record transactions, enabling trustless interactions between parties and removing the need for a central authority to overlook transactions.

ℹ️

This is especially crucial in decentralized systems in which multiple parties need to engage in secure and verifiable transactions. Despite the absence of a central authority to confirm and authenticate the transactions, every blockchain transaction is considered totally safe and validated.

Only the presence of a **consensus protocol** makes this feasible. A consensus algorithm allows every node in the blockchain network to agree on the distributed ledger’s current state. The consensus protocol ensures that all nodes in the network reach a common agreement on the order and validity of transactions.

More specifically, a **node** is any device or computer that participates in the network by maintaining a copy of the blockchain ledger, validating transactions, and broadcasting them to other nodes. Nodes can be categorized into different types, including **full** and **validator nodes**. These latter ones are specific type of node responsible for participating in the consensus process. These validate transactions, create new blocks, and contribute to the security and operation of the blockchain network. Validator nodes typically require a significant amount of cryptocurrency to be staked and which serves as collateral and as an incentive for them to act honestly.

**The most well-known consensus mechanisms** are:

*   **Proof of Work (PoW)**: this is the original consensus protocol used by Bitcoin. It requires nodes (i.e. miners) to perform computationally intensive tasks to validate transactions and create new blocks. The first miner to solve the mathematical puzzle gets to add a block to the blockchain.
    
*   **Proof of Stake (PoS)**: in this protocol, nodes (i.e. validators) are chosen based on the amount of cryptocurrency they hold and are willing to stake as collateral. Validators take turns proposing and validating blocks, and they earn rewards for their participation in the form of transaction fees and block.
    

**Compensation and incentives for validators** can take the form of:

*   **Block rewards**: in PoW and some PoS systems, validators are rewarded with newly created cryptocurrency tokens for successfully adding a new block to the blockchain.
    
*   **Transaction fees**: validators may receive transaction fees paid by users for including their transactions in a block.
    
*   **Delegation rewards**: in PoS networks, validators who receive delegated stakes from token holders may share a portion of the rewards with their delegators. This encourages token holders to delegate their stakes to reputable validators.
    
*   **Slashing penalties**: while not a form of compensation, validators can be penalized (i.e. slashed) for malicious behavior or violations of network rules. The penalties are typically deducted from the validator’s committed stake.
    

In this context, the Fetch.ai Ledger relies on a set of validators that are responsible for committing new blocks in the blockchain. These validators participate in the consensus protocol by broadcasting votes which contain cryptographic signatures signed by each validator’s private key. As previously highlighted, validator candidates can have FET delegated or staked to them by token holders. The validators are determined by who has the most stake delegated to them. The top validator candidates with the most stake become **active validators** within the network.

⚠️

If validators double sign, are frequently offline or do not participate in governance, their staked FET (including FET of users that delegated to them) can be slashed. The penalty depends on the severity of the violation.

### Test network (Testnet) vs Main Network (Mainnet)[](#test-network-testnet-vs-main-network-mainnet)

We can distinguish between:

*   **Testnet**: it is a separate blockchain environment that developers and users can use to test new features or applications without risking real tokens. It allows for experimentation in a controlled environment.
    
*   **Mainnet**: it is the actual production blockchain where real transactions occur with real tokens. It is the live version of the blockchain.
    

ℹ️

By setting up and experimenting on a testnet first, developers can ensure that everything works as intended before deploying it on the mainnet. This helps in avoiding potential issues or vulnerabilities in a live environment.

Set up a validator node[](#set-up-a-validator-node)
---------------------------------------------------

If you are willing to set up a validator node on the ASI network, visit our dedicated [guide](https://network.fetch.ai/docs/guides/ledger/setup-validator-node).

### Hardware requirements[](#hardware-requirements)

The hardware resources for running a validator node largely depend on the network load. As a _recommended configuration_, we suggest the following requirements:

*   2 x CPU, either Intel or AMD, with the SSE4.1, SSE4.2 and AVX flags (use lscpu to verify).
*   8 GB RAM.
*   500 GB SSD.
*   100 Mbit/s always-on internet connection.
*   Linux OS (Ubuntu 18.04 or 20.04 recommended)/MacOS.

Up-time is incredibly important for being a validator. It is expected that validators will have appropriate redundancies for compute, power, connectivity and so on. While the blockchain itself is highly replicated, it is also expected that validators will perform local storage backups in order to minimize validator down-time.

### Set up a website for your validator[](#set-up-a-website-for-your-validator)

Set up a dedicated validator’s website and signal your intention to become a validator on our [Discord](https://discord.gg/fetchai)  server. This is important since delegators will want to have information about the entity they are delegating their FET to.

This is not necessary, however, it is recommended given that as a validator on the network, you will want to get other community users to delegate stake to your validator. The higher the delegated stake to a specific validator, the greater the share of the block rewards it will take.

Community[](#community)
-----------------------

We highly recommend to check out the validator community on the discord channel for more information and to check the latest announcements about becoming a validator within the Fetch.ai network:

*   [Discord](https://discord.gg/fetchai) .</content>
</page>

<page>
  <title>How to use chain state snapshots</title>
  <url>https://network.fetch.ai/docs/guides/ledger/chain-state</url>
  <content>The synchronization process from the genesis block can take many hours, or even days to complete as blockchains get longer and longer over time.

In circumstances where a faster synchronization is required, various **snapshots** of the `fetchd` chain state data are available for download, to more quickly bootstrap a node.

**A snapshot refers to a specific point in time at which the state of a blockchain network is captured. It records the current state of all accounts, balances, smart contracts, and other data on the blockchain at that particular moment.**

Snapshots are available for both mainnet and the most recent testnet. The URLs for them can be obtained from the [active network](https://network.fetch.ai/docs/guides/ledger/references/active-networks) page of our documentation.

Our aim is to update snapshots on a daily basis!

The example below uses the _pruned mainnet snapshot_, but can be adapted as required for full or archive nodes.

Example: using a snapshot[](#example-using-a-snapshot)
------------------------------------------------------

### Stop your node[](#stop-your-node)

If you are already running `fetchd`, it is important that you stop it before proceeding.

If you have not already initialized your node, follow the instructions for [joining a testnet](https://network.fetch.ai/docs/guides/ledger/joining-testnet) then return to this page before starting `fetchd`.

⚠️️

Remember to modify the information for the mainnet as appropriate!

### Reset your node[](#reset-your-node)

*   **If using `fetchd` ≤ 0.10.3**: `fetchd unsafe-reset-all`
    
*   **If using `fetchd` ≥ 0.10.4**: `fetchd tendermint unsafe-reset-all`
    

⚠️️

This will irreversibly erase your node’s state database. Ensure you take whatever backups you deem appropriate before proceeding.

### Download and install the snapshot[](#download-and-install-the-snapshot)

**Many options are available here!**

ℹ️

The example below assumes a bash-like environment, uses a single connection for downloading, confirms the md5sum of the downloaded data against that of the original, and does not land the original compressed data to disk. This is a good starting point, but depending on your local environment you may wish to make adaptations that eg sacrifice disk space and extra md5sum complexity for the benefit of parallel downloads with aria2. **This is entirely up to you! Let us know how you get on in the process!**

    # (optional) show the timestamp of the latest available snapshot
    echo "Latest available snapshot timestamp : $(curl -s -I  https://storage.googleapis.com/fetch-ai-mainnet-snapshots/fetchhub-4-pruned.tgz | grep last-modified | cut -f3- -d' ')"
     
    # download, decompress and extract state database
    curl -v https://storage.googleapis.com/fetch-ai-mainnet-snapshots/fetchhub-4-pruned.tgz -o- 2>headers.out | tee >(md5sum > md5sum.out) | gunzip -c | tar -xvf - --directory=~/.fetchd
     
    # (optional, but recommended) compare source md5 checksum provided in the headers by google, with the one calculated locally
    [[ $(grep 'x-goog-hash: md5' headers.out | sed -z 's/^.*md5=\(.*\)/\1/g' | tr -d '\r' | base64 -d | od -An -vtx1 | tr -d ' \n') == $(awk '{ print $1 }' md5sum.out) ]] && echo "OK - md5sum match" || echo "ERROR - md5sum MISMATCH"
     
    # (optional) show the creation date of the downloaded snapshot
    echo "Downloaded snapshot timestamp: $(grep last-modified headers.out | cut -f3- -d' ')"

### Restart your node[](#restart-your-node)

Again, this entirely depends on your local installation, but a simple example for mainnet might be the following:

    fetchd start --p2p.seeds 17693da418c15c95d629994a320e2c4f51a8069b@connect-fetchhub.fetch.ai:36456,a575c681c2861fe945f77cb3aba0357da294f1f2@connect-fetchhub.fetch.ai:36457,d7cda986c9f59ab9e05058a803c3d0300d15d8da@connect-fetchhub.fetch.ai:36458`.</content>
</page>

<page>
  <title>Installation</title>
  <url>https://network.fetch.ai/docs/guides/ledger/installation</url>
  <content>Pre-requisites[](#pre-requisites)
---------------------------------

You can start using the Fetch Ledger by first installing the following:

*   **Go 1.18+**: installation instructions are available [here](https://golang.org/dl/) .
*   **Packages**: `make`, `gcc` (on Ubuntu, install them with `sudo apt-get update && sudo apt-get install -y make gcc`).

Building the code[](#building-the-code)
---------------------------------------

You can download the latest released version from GitHub and build the project using the running the following command:

    git clone https://github.com/fetchai/fetchd.git && cd fetchd

Then, you can **build the code** by running the following command:

This will generate the `./build/fetchd` binary.

For **non-developer users**, we recommend to install the binaries into their system. This can be done with the following command:

This will install the binaries in the directory specified by your `$GOBIN` environment variable (default to `~/go/bin`). To verify the correct installation, run the following command:

This should return a path such as `~/go/bin/fetchd` (might be different depending on your actual **Go** installation).

⚠️

If you get no output, or an error such as `which: no fetchd in ...`, possible cause can either be that `make install` failed with some errors or that your go binary folder (default: ~/go/bin) is not in your `PATH`. You can add the ~/go/bin folder to your PATH, by adding this line at the end of your `~/.bashrc`:

    export PATH=$PATH:~/go/bin

and then reload it with:

You can also **verify that you are running the correct version** by running the following command:

This would print a version number that must be compatible with the network you are connecting to. See the [network page](https://network.fetch.ai/docs/guides/ledger/references/active-networks) for the list of supported versions per available networks.

### FAQ[](#faq)

🚫

Error: failed to parse log level (main:info,state:info,:error): Unknown Level String: ‘main:info,state:info,:error’, defaulting to NoLevel.

This means that **you had a pre-stargate version of `fetchd` (≤ v0.7.x), and that you have just installed another stargate version (≥ v0.8.x)**.

You can solve the issue by removing the previous configuration files with the following:

    rm ~/.fetchd/config/app.toml ~/.fetchd/config/config.toml

Last updated on

May 14, 2025

[Registration and endpoints weighting](https://network.fetch.ai/docs/introduction/almanac/endpoints "Registration and endpoints weighting")</content>
</page>

<page>
  <title>State-synchronization (state-sync)</title>
  <url>https://network.fetch.ai/docs/guides/ledger/state-sync</url>
  <content>**State-sync** is a feature which allows you to quickly bootstrap a new node by allowing it to pull a _state snapshot_ taken by other nodes.

⚠️️

The state-sync feature is only available from `fetchd v0.10.6` and later on. Prior versions needed to either synchronize from scratch or restore a [chain snapshot](https://network.fetch.ai/guides/fetch-network/ledger/snapshots) , which both could take hours before having the node fully synchronized.

It now takes only a few minutes before having an operational node with state-sync,

Configuring the new node[](#configuring-the-new-node)
-----------------------------------------------------

If you want to instruct the node to sync itself using a state-sync snapshot, it need some configuration in the `~/.fetchd/config/config.toml` file. To configure the new node, open this file in an editor and look-up for the `statesync` section.

By default, it should look like this:

    #######################################################
    ###         State Sync Configuration Options        ###
    #######################################################
     
    [statesync]
    # State sync rapidly bootstraps a new node by discovering, fetching, and restoring a state machine
    # snapshot from peers instead of fetching and replaying historical blocks. Requires some peers in
    # the network to take and serve state machine snapshots. State sync is not attempted if the node
    # has any local state (LastBlockHeight > 0). The node will have a truncated block history,
    # starting from the height of the snapshot.
    enable = false
     
    # RPC servers (comma-separated) for light client verification of the synced state machine and
    # retrieval of state data for node bootstrapping. Also needs a trusted height and corresponding
    # header hash obtained from a trusted source, and a period during which validators can be trusted.
     
    # For Cosmos SDK-based chains, trust_period should usually be about 2/3 of the unbonding time (~2
    # weeks) during which they can be financially punished (slashed) for misbehavior.
    rpc_servers = ""
    trust_height = 0
    trust_hash = ""
    trust_period = "168h0m0s"
     
    # Time to spend discovering snapshots before initiating a restore.
    discovery_time = "15s"
     
    # Temporary directory for state sync snapshot chunks, defaults to the OS tempdir (typically /tmp).
    # Will create a new, randomly named directory within, and remove it when done.
    temp_dir = ""
     
    # The timeout duration before re-requesting a chunk, possibly from a different
    # peer (default: 1 minute).
    chunk_request_timeout = "10s"
     
    # The number of concurrent chunk fetchers to run (default: 1).
    chunk_fetchers = "4"

A few changes will be needed:

*   First, you will need to set `enable = true` to activate the state-sync engine.
    
*   Then, you need to provide **at least 2** rpc servers. A good place to find some is the [cosmos chain registry](https://github.com/cosmos/chain-registry/blob/master/fetchhub/chain.json#L62)  . Servers must be comma separated without space (i.e., `rpc_servers = "https://rpc-fetchhub.fetch.ai:443,https://fetch-rpc.polkachu.com:443"`). These servers will be used to verify the snapshots, so make sure you trust them enough for this.
    
*   You will also need a _recent_ `trust_height` and `trust_hash`. Recent means it must be contained in the `trust_period` (168 hours, or ~1 week old by default). These can be obtained from a RPC server **you trust to provide you correct data** (and the 2nd RPC server from `rpc_servers` will be charged of confirming that the data are correct).
    
*   And last, you need to set `chunk_request_timeout` to `60s` (the `10s` default value seems too short and can lead to “context deadline exceeded” timeout errors when verifying the hashes).
    

You can then retrieve the correct value for a **Fetch.ai RPC server**, and the current **network height**, using:

    curl https://rpc-fetchhub.fetch.ai:443/block | jq -r '{"trusted_hash": .result.block_id.hash, "trusted_height": .result.block.header.height}'
    {
      "trusted_hash": "...some hash...",
      "trusted_height": "...some height..."
    }

and set the `trusted_hash` and `trusted_height` values in the config file.

Once this is set, you will need to make sure you have the correct genesis by downloading it from the RPC node:

    curl https://raw.githubusercontent.com/fetchai/genesis-fetchhub/fetchhub-4/fetchhub-4/data/genesis_migrated_5300200.json --output ~/.fetchd/config/genesis.json

You can then start the node using the seeds from the chain-registry:

    fetchd start --p2p.seeds="17693da418c15c95d629994a320e2c4f51a8069b@connect-fetchhub.fetch.ai:36456,a575c681c2861fe945f77cb3aba0357da294f1f2@connect-fetchhub.fetch.ai:36457,d7cda986c9f59ab9e05058a803c3d0300d15d8da@connect-fetchhub.fetch.ai:36458"

After the node is initialized, it will start searching for available snapshots, and it should print log messages similar to the ones below:

    8:22AM INF Discovered new snapshot format=1 hash="� ݫ/��\r�F#C(pD�<��\x066��\x1f��\x1f<i�ݝ" height=2000 module=statesync
    8:22AM INF Discovered new snapshot format=1 hash="F�=\x05�Gh�{�|�����,�Q'�=]\x1a�$�b�ֿQ" height=1900 module=statesync

The node will select the one with the `height` value the closest to the tip of the chain, and it will then start restoring the state, and finish synchronizing the few blocks remaining. If it fails to verify any blocks or hash when restoring, it will attempt to restore the next available snapshot, and, if no more are available, it will fallback in discovery mode until an usable snapshot is made available.

Configure an existing node to provide snapshots[](#configure-an-existing-node-to-provide-snapshots)
---------------------------------------------------------------------------------------------------

You can configure existing nodes to create snapshot from which they can start on. This requires changes in the `~/.fetchd/config/app.toml` file, in the `state-sync` section:

    ###############################################################################
    ###                        State Sync Configuration                         ###
    ###############################################################################
    
    # State sync snapshots allow other nodes to rapidly join the network without replaying historical
    # blocks, instead downloading and applying a snapshot of the application state at a given height.
    [state-sync]
    
    # snapshot-interval specifies the block interval at which local state sync snapshots are
    # taken (0 to disable). Must be a multiple of pruning-keep-every.
    snapshot-interval = 0
    
    # snapshot-keep-recent specifies the number of recent snapshots to keep and serve (0 to keep all).
    snapshot-keep-recent = 2

Here, `snapshot-interval` must be set to a number of blocks between each snapshot creation and it must be a multiple of your node pruning settings (default is 100, so valid values are 100, 1000, 700…).

The number of snapshots to keep can be set with `snapshot-keep-recent`.</content>
</page>

<page>
  <title>How to set up a validator node</title>
  <url>https://network.fetch.ai/docs/guides/ledger/setup-validator-node</url>
  <content>Pre-requisites[](#pre-requisites)
---------------------------------

First of all, you need to have:

*   [installed](https://network.fetch.ai/docs/guides/ledger/installation) `fetchd`.
*   [Configured and connected](https://network.fetch.ai/docs/guides/ledger/joining-testnet) your validator to the desired network.

Also, it would be beneficial if you also explore the [CLI documentation](https://network.fetch.ai/docs/guides/cli/intro) to understand how to correctly interact with the Fetch Ledger.

Creating a validator[](#creating-a-validator)
---------------------------------------------

If you wish to create a validator, you will need to send a transaction to the network to stake your FET tokens. This process registers you as a validator, and if you are one of the chosen validators, you will start to produce blocks. If you want to create a validator using `fetchd` [Command Line Interface (CLI)](https://network.fetch.ai/docs/guides/cli/intro) you will need to send a `create-validator` transaction to the network as shown below:

    fetchd tx staking create-validator \
      --amount=<the amount to bond> \
      --pubkey=$(fetchd tendermint show-validator) \
      --moniker="choose a moniker" \
      --chain-id=<chain_id> \
      --commission-rate="0.10" \
      --commission-max-rate="0.20" \
      --commission-max-change-rate="0.01" \
      --min-self-delegation="<the min self delegation>" \
      --gas auto --gas-adjustment 1.5 --gas-prices "<network gas prices>" \
      --from=<key_name>

**Dorado example**

You should verify that you have some tokens available before trying to create a validator. The easiest way to do this is via the [CLI](https://network.fetch.ai/docs/guides/cli/tokens). Below, you can find an example of a typical CLI command that registers the node as running the validator:

    fetchd tx staking create-validator \
      --amount=1000000000000000000atestfet \
      --pubkey=$(fetchd tendermint show-validator) \
      --moniker="my-test-validator" \
      --chain-id=dorado-1 \
      --commission-rate="0.10" \
      --commission-max-rate="0.20" \
      --commission-max-change-rate="0.01" \
      --min-self-delegation="1000000000000000000" \
      --gas auto --gas-adjustment 1.5 --gas-prices 1000000000atestfet \
      --from=test-key

Edit a validator configuration[](#edit-a-validator-configuration)
-----------------------------------------------------------------

It is possible that validators will need to adjust various settings about their nodes over the time. This can be _simple things_, such as the associated website for a validator, or _more consequential actions_, like altering the commission rate. In either case, should a validator choose to make this update they would send an `edit-validator` transaction to the network.

These transactions can be created in a similar way to the `create-validator` transaction depicted above:

    fetchd tx staking edit-validator
      --moniker="choose a moniker" \
      --website="https://fetch.ai" \
      --details="To infinity and beyond!" \
      --chain-id=<chain_id> \
      --commission-rate="0.10" \
      --from=<key_name>

Unbonding a validator[](#unbonding-a-validator)
-----------------------------------------------

Whenever and if a validator wants to stop being a validator for any reason, they can unbond some or all of their staked tokens. **Unbonding refers to the process of withdrawing or removing a certain amount of staked tokens from a validator or a network after a defined waiting period**.

This operation is carried out with the following CLI command:

    fetchd tx staking unbond \
      <validator operator address> \
      <amount to remove> \
      --from <key name>

An instance of this command is given in the example below:

    fetchd tx staking unbond \
      fetchvaloper1jqqwdch3jmzlmj4tjfn67s3sqm9elkd3wrpspf \
      1000000000000000000000atestfet \
      --gas auto --gas-adjustment 1.5 --gas-prices 1000000000atestfet \
      --from test-key</content>
</page>

<page>
  <title>How to join a testnet</title>
  <url>https://network.fetch.ai/docs/guides/ledger/joining-testnet</url>
  <content>You can join a test network by first having the **correct version of the `fetchd` ledger available on your system**.

Using a local version[](#using-a-local-version)
-----------------------------------------------

If you have correctly followed the [installation](https://network.fetch.ai/docs/guides/ledger/installation) guide, then you should now have `fetchd` successfully installed in your path. You can check this by running the following command:

ℹ️

This should print a version number that must be compatible with the network you are connecting to.

You can check the [network page](https://network.fetch.ai/docs/guides/ledger/references/active-networks) for the list of supported versions for each network.

### Configuring the client `fetchd`[](#configuring-the-client-fetchd)

In general, you can configure the CLI to point at a given network it needs, as a minimum, the following configuration values:

    fetchd config chain-id <chain-id>
    fetchd config node <rpc url>

### Dorado example[](#dorado-example)

In the case of the **Dorado test network**, this would be as follows:

    fetchd config chain-id dorado-1
    fetchd config node https://rpc-dorado.fetch.ai:443

### Configuring the server `fetchd`[](#configuring-the-server-fetchd)

1.  You can initialize `fetchd` by running the following command:
    
        fetchd init <moniker-name> --chain-id <chain id>
    
    ℹ️
    
    This command setups a default/empty genesis configuration.
    
    ℹ️
    
    This will initialize default configuration files under the `FETCHD_HOME` folder, which default to `~/.fetchd/`.
    
2.  You will then need to execute the following command to **download the latest genesis file**:
    
        curl <rpc url>/genesis | jq '.result.genesis' > ~/.fetchd/config/genesis.json
    
3.  Finally, you will need to **connect `fetchd`** by getting it to connect to a seed node for the given network:
    
        fetchd start --p2p.seeds=<network seed peers>
    

**Dorado Example**

If you wish to connect to the **Dorado testnet** for example, you would need to follow the steps provided below:

1.  You would need to initialize a new Fetch.ai node (e.g., `my-first-fetch-node`) with the chain ID `dorado-1` using the following command:
    
        fetchd init my-first-fetch-node --chain-id dorado-1
    
2.  You would then need to get the genesis file, which contains the initial state of the blockchain. You can get it either from the RPC interface with:
    
        # genesis
        curl https://rpc-dorado.fetch.ai:443 | jq '.result.genesis' > ~/.fetchd/config/genesis.json
         
        # ...or, if that's too large to download from the rpc interface as a single file...
        curl https://storage.googleapis.com/fetch-ai-testnet-genesis/genesis-dorado-827201.json --output ~/.fetchd/config/genesis.json
    
3.  Then, you would need to start the Fetch.ai node with specific seed nodes on the Dorado testnet using the following command:
    
        # start
        fetchd start --p2p.seeds=eb9b9717975b49a57e62ea93aa4480e091ae0660@connect-dorado.fetch.ai:36556,46d2f86a255ece3daf244e2ca11d5be0f16cb633@connect-dorado.fetch.ai:36557,066fc564979b1f3173615f101b62448ac7e00eb1@connect-dorado.fetch.ai:36558
    
4.  Your local node will now synchronize with the network, replaying all blocks and transactions. This process may take some time depending on factors like the network’s age and your disk speed. Consider using [chain snapshots](https://network.fetch.ai/docs/guides/ledger/chain-state) to speed up this process.
    
5.  You can query your node’s status from its RPC API to know when it has finished syncing by running:
    
        curl -s 127.0.0.1:26657/status |  jq '.result.sync_info.catching_up'
        true # this will print "false" once your node is up to date
    
    If the response is `false`, your node is up-to-date.
    

Last updated on

May 14, 2025

[Registration and endpoints weighting](https://network.fetch.ai/docs/introduction/almanac/endpoints "Registration and endpoints weighting")</content>
</page>

<page>
  <title>How to run a single node test network</title>
  <url>https://network.fetch.ai/docs/guides/ledger/single-node-testnet</url>
  <content>It can be very useful to be able to run a single node network for testing purposes when undergoing contract development. This document outlines the steps required in order to configure a `fetchd` network of 1 node (i.e. **single node network**).

Network setup[](#network-setup)
-------------------------------

ℹ️

These steps only need to be carried out **once** to setup the local network correctly.

1.  **Build the ledger from source**: follow the [installation](https://network.fetch.ai/docs/guides/ledger/installation) instructions in order to compile the latest version of the Ledger.
    
2.  **Remove any existing networks**: since we are starting a new network, we need to remove any local files that we have in our system from a previous network. You can do so by running:
    
    `rm -Rf ~/.fetchd`
    
3.  **Create an initial genesis**: let’s now create the initial genesis file (`~/.fetchd/config/genesis.json`) with the following command:
    
    `fetchd init --chain-id localnet-1 my-local-node-name`
    
    ℹ️
    
    *   `localnet-1` is the chain id
    *   `my-local-node-name` is the moniker for the node
    
    If you want to make any updates to the genesis, it is a good time to make these updates now.
    
4.  **Create a validator key**: let’s now create a validator key which will be used as the public/private keypair for our node. Let’s create a new key called `validator` using the following command:
    
    `fetchd keys add validator`
    
    ℹ️
    
    `validator` is the name of the key in the keyring.
    
    For more information, checkout the complete [keys](https://network.fetch.ai/guides/fetch-network/ledger/cli/keys) documentation.
    
5.  **Add the validator to the network**: let’s now set the initial state for the network, allocating `100000000000000000000` `stake` tokens to the validator which can be bonded. This is performed with the following command:
    
    `fetchd add-genesis-account validator 100000000000000000000stake`
    
    ℹ️
    
    `stake` is the default test token denomination in the cosmos ecosystem, but you could use `afet`, `BTC`, and so on.
    
6.  **Generate a transaction**: now, let’s **generate a validator transaction**. You can get your validator to sign the genesis block, and to agree that this is the correct genesis starting point, using the following command:
    
    `fetchd gentx validator 100000000000000000000stake --chain-id localnet-1`
    
    ℹ️
    
    `validator` is the name that you have given to the key.
    
7.  **Build final genesis configuration**: finally, we would need to **build the complete and final genesis configuration** for the network by running the following command:
    
    `fetchd collect-gentxs`
    

After running this command, the network will be successfully configured and you have computed the final genesis configuration for the network.

Running the local node[](#running-the-local-node)
-------------------------------------------------

Let’s now run the network. We need to use the following command:

`fetchd start`

Resetting the network[](#resetting-the-network)
-----------------------------------------------

It may happen that you may want to clear out all the data from the network and start it again. You can do this in a local network, by simply running the following command:

`fetchd tendermint unsafe-reset-all`

This will reset the chain back to genesis configuration.

⚠️

You **DO NOT** need to perform the network setup steps again. After running this command, you can simply run the `fetchd start` command again.

Last updated on

May 14, 2025

[Registration and endpoints weighting](https://network.fetch.ai/docs/introduction/almanac/endpoints "Registration and endpoints weighting")</content>
</page>

<page>
  <title>How to get testnet tokens via the token faucet</title>
  <url>https://network.fetch.ai/docs/guides/ledger/faucet</url>
  <content>A **token faucet** is a service that provides free tokens to users for testing or development purposes on a blockchain network. It helps developers and users access a blockchain’s test network with a small amount of cryptocurrency without having to purchase it. This allows them to interact with the blockchain, test applications, and simulate real-world scenarios without using actual funds. It is a valuable resource for developers who want to experiment with blockchain applications in a risk-free environment.

For our [test networks](https://network.fetch.ai/docs/guides/ledger/references/active-networks#test-nets), we have a simple token faucet implemented to allow users to get started quickly. You can send the faucet an account address, and it will transfer some test tokens back to such address. Token faucets are network specific, depending on the network type they may or may not be deployed. Please check the [networks](https://network.fetch.ai/docs/guides/ledger/references/active-networks) page for specific details.

The testnet token faucet itself is available from the network block explorer available within the [active networks](https://network.fetch.ai/docs/guides/ledger/references/active-networks) page. You will be asked to enter your **Fetch Account address** (`fetch...`) and you will have to wait a few blocks for the transaction to be processed, and you should see it appearing alongside with some funds on your account.

Overall, you can obtain test tokens for your account in the following way:

1.  Copy your account’s address and paste it into the **token faucet** available within each [network](https://network.fetch.ai/docs/guides/ledger/references/active-networks) configuration. For the **Dorado testnet**, the faucet is available within the [block explorer](https://explore-dorado.fetch.ai/)  homepage.
2.  Within the block explorer homepage, press the **Get Funds** button.
3.  Paste the address you wish to top-up in the pop-up window and then press **Add Funds**.
4.  Then, you can return to your address page, via the person icon, and should be able to see that you have been allocated **1 TESTFET** token.

ℹ️

The tokens provided by a faucet do not have any real-world market value. These tokens are specifically created for testing and development purposes within the blockchain’s ecosystem. They are not intended for trading on cryptocurrency exchanges or for any commercial transactions. Therefore, while they have utility within the test network, they do not hold any value on the broader cryptocurrency market.

How to add funds to your wallet using faucet APIs
-------------------------------------------------

You can also request and get testnet tokens in your wallet using the APIs, by running the following commands:

For **Eridanus** testnet:[](#for-eridanus-testnet)
--------------------------------------------------

### Get `atestasi` tokens[](#get-atestasi-tokens)

    curl -X POST -H 'Content-Type: application/json' -d '{"address":"<address>"}' https://faucet-eridanus-1.fetch.ai/api/v3/claims

### Get nanomobx tokens[](#get-nanomobx-tokens)

    curl -X POST -H 'Content-Type: application/json' -d '{"address":"<address>"}' https://faucet-mobx-eridanus-1.fetch.ai/api/v3/claims

### Get ulrn tokens[](#get-ulrn-tokens)

    curl -X POST -H 'Content-Type: application/json' -d '{"address":"<address>"}' https://faucet-lrn-eridanus-1.fetch.ai/api/v3/claims

For **Dorado** testnet:[](#for-dorado-testnet)
----------------------------------------------

### Get atestfet tokens[](#get-atestfet-tokens)

    curl -X POST -H 'Content-Type: application/json' -d '{"address":"<address>"}' https://faucet-dorado.fetch.ai/api/v3/claims

### Get nanomobx tokens[](#get-nanomobx-tokens-1)

    curl -X POST -H 'Content-Type: application/json' -d '{"address":"<address>"}' https://faucet-mobx-dorado.fetch.ai/api/v3/claims

### Get ulrn tokens[](#get-ulrn-tokens-1)

    curl -X POST -H 'Content-Type: application/json' -d '{"address":"<address>"}' https://faucet-lrn-dorado.fetch.ai/api/v3/claims

Sample response for fund request to faucet API[](#sample-response-for-fund-request-to-faucet-api)
-------------------------------------------------------------------------------------------------

    {"status":"ok","uuid":"<uuid>","target":"<address>"}

Check the wallet balance[](#check-the-wallet-balance)
-----------------------------------------------------

If you want to check your wallet balance, you need to run the following command:

    fetchd query bank balances <address>

The output would be:

    balances:
    - amount: "<balance>"
      denom: atestfet
    pagination:
      next_key: null
      total: "0"</content>
</page>

<page>
  <title>Governance</title>
  <url>https://network.fetch.ai/docs/guides/ledger/governance</url>
  <content>Introduction[](#introduction)
-----------------------------

**Governance** is the mechanisms through which participants collectively make decisions about the rules, parameters, and policies that govern a given network. This can include things like protocol upgrades, parameter adjustments, and even more fundamental decisions about the network’s direction and purpose. Changes are requested through \*_governance proposals_ which represent formal suggestions or requests put forth by a member or participant of a network or community to make changes to that network. These proposals are typically submitted to a decentralized governance system, where participants in the network have the opportunity to review, discuss, and ultimately vote on the proposed changes.

The approval process and the required majority for a proposal to pass can vary depending on the specific governance model of the network. Once a proposal is approved, the changes outlined in the proposal are typically implemented according to the network’s governance mechanisms. This could involve deploying new smart contracts, updating software, or making adjustments to on-chain parameters.

How to take part in the governance mechanism[](#how-to-take-part-in-the-governance-mechanism)
---------------------------------------------------------------------------------------------

If you wish to take part in governance, you will either need to be running a **full validator node** or you need to **have delegated stake to an existing validator**.

For additional information, visit the [validators](https://network.fetch.ai/docs/introduction/ledger/validators) section of our documentation, or the [delegation](https://network.fetch.ai/docs/guides/cli/delegator#how-to-delegate-tokens) guide.

Stake delegation[](#stake-delegation)
-------------------------------------

If you want to delegate your stake to a validator, the following CLI command should be used:

    fetchd tx staking delegate <VALOPER_ADDRESS> <AMOUNT> --from <KEY_NAME>

where the `<VALOPER_ADDRESS>` begins with the prefix `fetchvaloper1...` and the `<AMOUNT>` field contains the currency denomination.

For instance:

    fetchd tx staking delegate fetchvaloper1cct4fhhksplu9m9wjljuthjqhjj93z0s97p3g7 1000atestfet --from agent

Check out our [delegation](https://network.fetch.ai/docs/guides/cli/delegator#how-to-delegate-tokens) guide for further information on how to delegate your tokens to a validator using the CLI.

Proposals overview[](#proposals-overview)
-----------------------------------------

There are **three types** of governance proposal:

1.  **Text proposals**: these are the most basic type of proposal. They can be used to get the opinion from participants of the network on a given topic.
    
2.  **Parameter proposals**: these proposals are used to update the value of an existing software parameter of the network.
    
3.  **Software upgrade proposals**: these are used to propose an upgrade of the `fetchd` software, particularly in cases where the software changes might not necessary be backwards compatible or in some way present a major update to the network.
    

The proposal process[](#the-proposal-process)
---------------------------------------------

**Any FET holder can submit a proposal**.

In order for the proposal to be open for voting, it needs to come with a deposit that is greater than a parameter called _minDeposit_. The deposit need not be provided in its entirety by the submitter. If the initial proposer’s deposit is not sufficient, the proposal enters the **deposit period** status. Then, any FET holder can increase the deposit by sending a _depositTx_ transaction to the network.

Once the deposit reaches _minDeposit_, the proposal enters the **voting period**, which lasts 5 days. Any bonded FET holder can then cast a vote on this proposal, by choosing one of the following options for voting:

*   Yes.
*   No.
*   NoWithVeto.
*   Abstain.

At the end of the voting period, the proposal is accepted if there are **more than 50% Yes votes** (excluding Abstain votes) and **less than 33.33% of NoWithVeto votes** (excluding Abstain votes).

Generating proposals[](#generating-proposals)
---------------------------------------------

When creating a proposal, you will create a proposal **JSON file** with all the relevant information.

An example of a **text proposal** is shown below:

    {
      "title": "Switch to semantic commit messages for fetchd",
      "description": "This proposal is advocating a switch to semantic commit messages. You can find the full discussion at: https://github.com/fetchai/fetchd/issues/231",
      "type": "Text",
      "deposit": "10000000000000000000atestfet"
    }

ℹ️

It is always recommended that the description of a text proposal has a link to a Github issue with the full proposal text along with the discussions about it.

After having created the JSON file, you can **generate the text proposal on chain** by running the following command:

`fetchd tx gov submit-proposal --proposal proposal.json --from <name of signing key>`

Increasing the deposit for a proposal[](#increasing-the-deposit-for-a-proposal)
-------------------------------------------------------------------------------

If you want to **increase the deposit of a proposal**, you could do this by running the following command:

`fetchd tx gov deposit <proposalID> 100atestfet --from <key name>`

For instance:

`fetchd tx gov deposit 2 100atestfet --from validator`

If you want to get the **proposalID**, you will need to use the **txhash** obtained when the proposal was submitted and run the following command:

`fetchd query tx <txhash>`

For additional information on how to create a governance proposal using CLI, have a look at our [dedicated guide](https://network.fetch.ai/docs/guides/cli/governance-proposals).

Listing current proposals[](#listing-current-proposals)
-------------------------------------------------------

Current proposals can be retrieved by using the **CLI** or from the **block explorer**.

If you wish to **get the list of current proposals** and their corresponding **proposal-ids**, then you need to run the following command:

`fetchd query gov proposals`

Voting on a proposal[](#voting-on-a-proposal)
---------------------------------------------

If you want to **vote for a proposal**, run the following command:

`fetchd tx gov vote <proposalID> <option> --from <delegatorKeyName>`

For instance:

`fetchd tx gov vote 5 yes --from validator`

ℹ️

When using CLI commands make sure that your CLI is pointing at the correct network. Check the [CLI introduction](https://network.fetch.ai/docs/guides/cli/intro) in our documentation for additional details on the topic.</content>
</page>

<page>
  <title>CLI - Introduction</title>
  <url>https://network.fetch.ai/docs/guides/cli/intro</url>
  <content>The Command Line Interface (CLI) client provides all the capabilities for interacting with the [Fetch ledger](https://network.fetch.ai/docs/introduction/ledger/ledger-intro) , such as creating addresses, sending transactions and the governance capabilities. Before starting with the Command Line client, you need to follow the [installation instructions](https://network.fetch.ai/docs/guides/ledger/installation) for the Fetch Ledger.

Connecting to a network[](#connecting-to-a-network)
---------------------------------------------------

Users have the choice to either synchronize an entire blockchain by connecting a node to the network or directly link to existing publicly accessible nodes.

### Connecting to fetchhub mainnet[](#connecting-to-fetchhub-mainnet)

To connect to the **Fetch Mainnet** run the following configuration steps:

    fetchd config chain-id fetchhub-4
    fetchd config node https://rpc-fetchhub.fetch.ai:443

### Connecting to Dorado Test Network[](#connecting-to-dorado-test-network)

To connect to the **Dorado Testnet** run the following configuration steps:

    fetchd config chain-id dorado-1
    fetchd config node https://rpc-dorado.fetch.ai:443

Checkout the [network information](https://network.fetch.ai/docs/guides/ledger/references/active-networks) page for more detailed information on the available networks.

Last updated on

May 14, 2025

[Registration and endpoints weighting](https://network.fetch.ai/docs/introduction/almanac/endpoints "Registration and endpoints weighting")</content>
</page>

<page>
  <title>CLI - Managing tokens</title>
  <url>https://network.fetch.ai/docs/guides/cli/tokens</url>
  <content>How to query your balance[](#how-to-query-your-balance)
-------------------------------------------------------

Once `fetchd` is configured for the desired [network](https://network.fetch.ai/docs/guides/cli/intro) . The user can query their balance using the following command:

    fetchd query bank balances fetch1akvyhle79nts4rwn075t85xrwmp5ysuqynxcn4

If the address exists on the network, then the user will expect to see an output in the following form:

    balances:
    - amount: "8000000000000000000"
      denom: atestfet
    pagination:
      next_key: null
      total: "0"

How to send funds[](#how-to-send-funds)
---------------------------------------

Before sending funds, make sure the sender address has tokens available by querying your balance as shown above. Checkout the [token faucet](https://network.fetch.ai/docs/guides/ledger/faucet) page for more information on how to add test tokens to your address.

If you wish to send funds from one address to another, then you would use the `tx send` subcommand as shown below:

    fetchd tx bank send <from address or key name> <target address> <amount>

In a more concrete example, if the user wanted to send `100atestfet` from `main` key/address to `fetch106vm9q6ezu9va7v7e0cvq0nedc54egjm692fcp`, then the following command would be needed:

    fetchd tx bank send main fetch106vm9q6ezu9va7v7e0cvq0nedc54egjm692fcp 100atestfet

When you run the command, you will get a similar output and prompt. The user can check the details of the transfer and then press `y` to confirm the transfer.

    {"body":{"messages":[{"@type":"/cosmos.bank.v1beta1.MsgSend","from_address":"fetch12cjntwl32dry7fxck8qlgxq6na3fk5juwjdyy3","to_address":"fetch1hph8kd54gl6qk0hy5rl08qw9gcr4vltmk3w02v","amount":[{"denom":"atestfet","amount":"100"}]}],"memo":"","timeout_height":"0","extension_options":[],"non_critical_extension_options":[]},"auth_info":{"signer_infos":[],"fee":{"amount":[],"gas_limit":"200000","payer":"","granter":""}},"signatures":[]}
    
    confirm transaction before signing and broadcasting [y/N]: y

Once the transfer has been made, a summary is presented to the user. An example is shown below:

    code: 0
    codespace: ""
    data: ""
    gas_used: "0"
    gas_wanted: "0"
    height: "0"
    info: ""
    logs: []
    raw_log: '[]'
    timestamp: ""
    tx: null
    txhash: 77C7382A0B1B9FE39257A6C16C7E3169A875CB3A87F2CE9D947D7C1335B53E76

On failure, the response will have a non-zero code, as well as some logs under the `raw_log` key:

    code: 4
    codespace: sdk
    data: ""
    gas_used: "0"
    gas_wanted: "0"
    height: "0"
    info: ""
    logs: []
    raw_log: 'signature verification failed; please verify account number (5815) and chain-id
      (dorado-1): unauthorized'
    timestamp: ""
    tx: null
    txhash: 23701B052B423D63EB4AC94773B5B8227B03A576692A57999E92F2554F2372D4</content>
</page>

<page>
  <title>CLI - Managing keys</title>
  <url>https://network.fetch.ai/docs/guides/cli/keys</url>
  <content>Managing keys is an essential part of working with the Ledger, since all interactions are authenticated with these keys.

How to add keys[](#how-to-add-keys)
-----------------------------------

If you want to **create a new local key**, you would need to run the following command:

    fetchd keys add <your_key_name>

ℹ️

These keys are stored locally on your system. By default, these keys will be stored in the OS level keychain, however, in general these keys are considered less secure than using a hardware device

After running the above command, `fetchd` will print out a summary of the new key being produced. An output example is shown below:

    - name: test
      type: local
      address: fetch142tawq2rj397mctc3jtw9dfzf03ns0ze4swat0
      pubkey: fetchpub1addwnpepqvtmze0ekffynnjx9n85g6sexzl49ze2vpgc2f52fteyyghjtvvqw682nkx
      mnemonic: ""
      threshold: 0
      pubkeys: []

This will be followed by a 24-word mnemonic that can be used to re-generate the private key and address for the account.want

⚠️

Keep this safe if ever use it to control Mainnet tokens!

How to look up for an address[](#how-to-look-up-for-an-address)
---------------------------------------------------------------

A common operation that you may want to carry out is to research the address related to specified key. This can be performed quickly, by running following command:

    fetchd keys show -a <name of key>

The expected output should be as shown below:

    fetch142tawq2rj397mctc3jtw9dfzf03ns0ze4swat0

A less common operation, but still useful, would be to look for the public key related to a specified key. This can be achieved with the following command:

    fetchd keys show -p <name of the key>

The expected output should be similar to what shown below:

    fetchpub1addwnpepqvtmze0ekffynnjx9n85g6sexzl49ze2vpgc2f52fteyyghjtvvqw682nkx

How to list keys[](#how-to-list-keys)
-------------------------------------

If you wish to research for more detailed information for all keys within your system, simply use the following command:

This will show all your keys information in a `yaml` format similar to the one generated when you first created the key:

    - name: test
      type: local
      address: fetch142tawq2rj397mctc3jtw9dfzf03ns0ze4swat0
      pubkey: fetchpub1addwnpepqvtmze0ekffynnjx9n85g6sexzl49ze2vpgc2f52fteyyghjtvvqw682nkx
      mnemonic: ""
      threshold: 0
      pubkeys: []

How to recover a key[](#how-to-recover-a-key)
---------------------------------------------

You can import a key from a 24-word mnemonic by running the following:

    fetchd keys add <name> --recover
    > Enter your bip39 mnemonic
    <type or paste your mnemonic>

You will be prompted to enter the **mnemonic phrase**, and it will then print the matching address and key details as when creating a new key.

Hardware wallets[](#hardware-wallets)
-------------------------------------

### Set up your hardware wallet[](#set-up-your-hardware-wallet)

**We recommend hardware wallets as a solution for managing private keys!**

The Fetch ledger is compatible with **Ledger Nano hardware wallets**. To use your Ledger Nano, you will need to go through the following steps:

1.  Set-up your wallet by creating a PIN and passphrase, which must be stored securely to enable recovery if the device is lost or damaged.
2.  Connect your device to your PC and update the firmware to the latest version using the Ledger Live application.
3.  Install the Cosmos application using the software manager (Manager > Cosmos > Install).

### How to add a new key[](#how-to-add-a-new-key)

To use the hardware wallet address with the CLI, the user must first add it via `fetchd`. This process only records the public information about the key. You can **import the key** by first plugging in the device and enter the device pin. Once you have unlocked the device, navigate to the Cosmos app on the device and open it.

Then, you can \*\*add the key using the following command:

    fetchd keys add <name for the key> --ledger --index 0

ℹ️

The `--ledger` flag tells the command line tool to talk to the ledger device and the `--index` flag selects which HD index should be used.

When running this command, the Ledger device will prompt you to verify the generated address. Once you have done this. you will get an output in the following form:

    - name: hw1
      type: ledger
      address: fetch1xqqftqp8ranv2taxsx8h594xprfw3qxl7j3ra2
      pubkey: fetchpub1addwnpepq2dulyd9mly3xqnvfgdsjkqlqzsxldpdhd6cnpm67sx90zhfw2ragk9my5h
      mnemonic: ""
      threshold: 0
      pubkeys: []</content>
</page>

<page>
  <title>Multisig keys</title>
  <url>https://network.fetch.ai/docs/guides/cli/multisig-keys</url>
  <content>This feature of `fetchd` allows users to securely control keys in a number of configurations. This involves setting a minimum number of keys required to sign a transaction out of a maximum of N keys, known as a threshold number K.

Creating a multisig key[](#creating-a-multisig-key)
---------------------------------------------------

To create a multisig key, use the following syntax:

    # Create a simple multisig key with a threshold of 1 as default
    fetchd keys add <multisig_key_name> --multisig <list_of_key_names>
    
    # Creating a multisig key with a higher threshold, K
    fetchd keys add <multisig_key_name> --multisig <list_of_key_names> --multisig-threshold <threshold integer K>

### Example instantiation of a multisig key: shared business multisig key[](#example-instantiation-of-a-multisig-key-shared-business-multisig-key)

Consider a scenario in which three account holders need to collectively authorize transactions. At least two out of the three (K=2) must sign off on each transaction:

    # Create the three keys owned by the separate account holders
    fetchd keys add fred
    fetchd keys add ted
    fetchd keys add ned
    
    # Create the multisig key from keys above
    fetchd keys add business_key --multisig fred,ted,ned --multisig-threshold 2

Importantly, remember to retrieve the address of `business_key` for future use:

    fetchd keys show -a business_key

Signing and broadcasting multisig transactions[](#signing-and-broadcasting-multisig-transactions)
-------------------------------------------------------------------------------------------------

Transactions must be signed and broadcasted before they can be executed.

In order to sign a multi signature transaction, the transaction itself must not be immediately broadcast. Instead, the key holders must each sign until a minimum threshold K signatures are present.

ℹ️

For this example, we will be performing the transaction on the [Dorado](https://explore-dorado.fetch.ai/)  network and therefore will be using `atestfet` as the denomination, and a gas price of 1000000000atestfet (this should be changed depending on the actual currency and network used).

### Example: Multisig transaction[](#example-multisig-transaction)

    # Create a key to represent a vendor that the business must pay
    fetchd keys add vendor
    
    # Generate a transaction as an output file to be signed by
    # the keyholders, 'ted' and 'fred' in this example
    fetchd tx bank send <business_key address> <vendor address> 1000atestfet --gas 90000 --gas-prices 1000000000atestfet --generate-only > transfer.json
    
    # you'll get "account <address of business_key> not found" error for missing funds
    # add funds to <address of business_key> using block explorer or by eg
    curl -X POST -H 'Content-Type: application/json' -d '{"address":"<address of business_key>"}' https://faucet-dorado.fetch.ai/api/v3/claims
    
    # This transaction file (transfer.json) is then made available for
    # the first keyholder to sign, 'fred'
    fetchd tx sign transfer.json --chain-id dorado-1 --from fred --multisig <address of business_key> > transfer_fredsigned.json
    
    # This is repeated for 'ted'
    fetchd tx sign transfer.json --chain-id dorado-1 --from ted --multisig <address of business_key> > transfer_tedsigned.json
    
    # These two files are then collated together and used as inputs to the
    # multisign command to create a fully signed transaction
    fetchd tx multisign transfer.json business_key transfer_fredsigned.json transfer_tedsigned.json > signed_transfer.json
    
    # Now that the transaction is fully signed, it may be broadcast
    fetchd tx broadcast signed_transfer.json
    
    # Now display the result of the transaction and confirm that the vendor has
    # received payment
    fetchd query bank balances <address of vendor>

It is important to note that this method of signing transactions can apply to all types of transaction, including staking and withdrawal transactions as shown below.

### Other multisig transaction examples[](#other-multisig-transaction-examples)

Other examples are provided below:

    # In order to create a staking transaction using a multisig key
    # the same process as above can be used with the output file of this command
    fetchd tx staking delegate <fetchvaloper address> 10000atestfet --from <address of business_key> --gas 200000 --gas-prices 1000000000atestfet --generate-only > stake.json
    
    # The following command can also be used to create a withdrawal transaction for the
    # rewards from staking when using a multisig key - this too must be signed as before
    fetchd tx distribution withdraw-all-rewards --from <address of business_key> --gas 150000 --gas-prices 1000000000atestfet --generate-only > withdrawal.json</content>
</page>

<page>
  <title>CLI - Delegation</title>
  <url>https://network.fetch.ai/docs/guides/cli/delegator</url>
  <content>Delegations refers to the act of assigning the responsibility of validating transactions and creating new blocks to a specific validator node. Below you can find different operations executable through the [CLI](https://network.fetch.ai/docs/guides/cli/intro) .

How to query the current staking holdings of validators[](#how-to-query-the-current-staking-holdings-of-validators)
-------------------------------------------------------------------------------------------------------------------

You can query the current staking holdings of validators using the `fetchd`CLI, and run the following command:

    fetchd query staking validators

This command will provide information about all the existing validators in the network, including details such as their operator address, consensus public key, status, tokens staked, commission rates, and more.

The output will be a list of validators, each represented in a block of information, similar to the example you provided earlier. This information gives an overview of each validator’s status and staked tokens.

On `dorado` test network, this command will produce an output similar to the following:

    - |
      operatoraddress: fetchvaloper1z72rph6l5j6ex83n4urputykawcqg6t98xul2w
      conspubkey: fetchvalconspub1zcjduepq3urw6c6u0zvqmde4vr4gmy56nnq57shdhg56jynpu8n3s74hrm0q0mzqrx
      jailed: false
      status: 2
      tokens: "1000000000000000000000"
      delegatorshares: "1000000000000000000000.000000000000000000"
      description:
        moniker: validator5
        identity: ""
        website: ""
        security_contact: ""
        details: ""
      unbondingheight: 0
      unbondingcompletiontime: 1970-01-01T00:00:00Z
      commission:
        commission_rates:
          rate: "0.050000000000000000"
          max_rate: "0.100000000000000000"
          max_change_rate: "0.010000000000000000"
        update_time: 2021-02-12T12:41:25.579730119Z
      minselfdelegation: "1000000000000000000000"
      producingblocks: true
    - |
      operatoraddress: fetchvaloper1ysc8n5uspv4698nyk8u75lx98uu92zt7m3udw8
      conspubkey: fetchvalconspub1zcjduepqmxr8gmcs6pwuxpsma264ax59wxtxd3vchrcv2c06deq9986kwt3s0wsk6n
      jailed: false
      status: 2
      tokens: "1000000000000000000000"
      delegatorshares: "1000000000000000000000.000000000000000000"
      description:
        moniker: validator2
        identity: ""
        website: ""
        security_contact: ""
        details: ""
      unbondingheight: 0
      unbondingcompletiontime: 1970-01-01T00:00:00Z
      commission:
        commission_rates:
          rate: "0.050000000000000000"
          max_rate: "0.100000000000000000"
          max_change_rate: "0.010000000000000000"
        update_time: 2021-02-03T13:00:00Z
      minselfdelegation: "1000000000000000000000"
      producingblocks: true
    ...

Similarly, if you wish to retrieve the same information but now for a **single validator**, use the following command, by providing the `operator_address` of the specific validator:

    fetchd query staking validator operator_address

For instance:

    fetchd query staking validator fetchvaloper1z72rph6l5j6ex83n4urputykawcqg6t98xul2w

This command will provide detailed information about the specific validator, including their commission rates, minimum self-delegation, and other relevant details.

A delegator will be particularly interested in the following keys:

*   `commission/commission_rates/rate`: the commission rate on revenue charged to any delegator by the validator.
*   `commission/commission_rates/max_change_rate`: the maximum daily increase of the validator’s commission. This parameter cannot be changed by the validator operator.
*   `commission/commission_rates/max_rate`: the maximum commission rate this validator can charge. This parameter cannot be changed by the validator operator.
*   `minselfdelegation`: minimum amount of `atestfet` the validator need to have bonded at all time. If the validator’s self-bonded stake falls below this limit, their entire staking pool (i.e. all its delegators) will unbond. This parameter exists as a safeguard for delegators. Indeed, when a validator misbehaves, part of their total stake gets slashed. This includes the validator’s self-delegateds stake as well as their delegators’ stake. Thus, a validator with a high amount of self-delegated `atestfet` has more skin-in-the-game than a validator with a low amount. The minimum self-bond amount parameter guarantees to delegators that a validator will never fall below a certain amount of self-bonded stake, thereby ensuring a minimum level of skin-in-the-game. This parameter can only be increased by the validator operator.

### How to query the delegations made to a validator[](#how-to-query-the-delegations-made-to-a-validator)

You can **query the list of delegations made to a specific validator** using the `fetchd` command-line interface, and run the following command:

    fetchd query staking delegations-to fetchvaloper1z72rph6l5j6ex83n4urputykawcqg6t98xul2w

Here, replace `VALIDATOR_OPERATOR_ADDRESS` with the actual operator address of the validator you are interested in. For instance:

    fetchd query staking delegations-to VALIDATOR_OPERATOR_ADDRESS

This command will provide information about the delegations made to the specified validator, including details such as the delegator’s address, the validator’s address, and the amount of shares and tokens delegated.

Below, you can find an example of delegations to `validator2` received on `dorado` testnet:

    - delegation:
        delegator_address: fetch1z72rph6l5j6ex83n4urputykawcqg6t9zzruef
        validator_address: fetchvaloper1z72rph6l5j6ex83n4urputykawcqg6t98xul2w
        shares: "1000000000000000000000.000000000000000000"
      balance:
        denom: atestfet
        amount: "1000000000000000000000"
    - delegation:
        delegator_address: fetch15fn3meky8ktfry3qm73xkpjckzw4dazxpfx34m
        validator_address: fetchvaloper1z72rph6l5j6ex83n4urputykawcqg6t98xul2w
        shares: "100000.000000000000000000"
      balance:
        denom: atestfet
        amount: "100000"

This output shows two delegations made to the validator, along with the delegator’s address, the validator’s address, the number of shares, and the amount of tokens delegated.

### How to query re-delegations[](#how-to-query-re-delegations)

Re-delegation is the process of transferring already delegated tokens from one validator to another. This allows participants to change their delegation strategy without having to unbond and wait for the unbonding period to complete.

Delegators can choose to re-delegate the tokens they already delegated from one validator to another at any time. Re-delegation takes effect immediately, without any waiting period. However, the tokens can not be re-delegated until the initial re-delegation transaction has completed its 21 day completion time. The unlocking time is indicated by the `redelegationentry/completion_time` field in the outputs below.

You can **query the list of re-delegations made from a validator** by using the `fetchd` command-line interface and run the following command:

    fetchd query staking redelegations-from VALIDATOR_OPERATOR_ADDRESS

Replace `VALIDATOR_OPERATOR_ADDRESS` with the actual operator address of the validator you are interested in. For instance:

    fetchd query staking redelegations-from fetchvaloper1z72rph6l5j6ex83n4urputykawcqg6t98xul2w

This command will provide information about the re-delegations made from the specified validator, including details such as the delegator’s address, the source validator’s address, the destination validator’s address, and information about the re-delegation entries. The output will be a list of re-delegations, each represented in a block of information. Below you can find an example output:

    fetchd query staking redelegations-from fetchvaloper1z72rph6l5j6ex83n4urputykawcqg6t98xul2w
    - redelegation:
        delegator_address: fetch15fn3meky8ktfry3qm73xkpjckzw4dazxpfx34m
        validator_src_address: fetchvaloper1z72rph6l5j6ex83n4urputykawcqg6t98xul2w
        validator_dst_address: fetchvaloper122veneudkzyalay6gusvrhhpp0560mparpanvu
        entries: []
      entries:
      - redelegationentry:
          creation_height: 291037
          completion_time: 2021-03-24T14:24:38.973444629Z
          initial_balance: "50000"
          shares_dst: "50000.000000000000000000"
        balance: "50000"
      - redelegationentry:
          creation_height: 291133
          completion_time: 2021-03-24T14:33:43.425472866Z
          initial_balance: "10000"
          shares_dst: "10000.000000000000000000"
        balance: "10000"

Here, delegator `fetch15fn3meky8ktfry3qm73xkpjckzw4dazxpfx34m` issued 2 re-delegations from `fetchvaloper1z72rph6l5j6ex83n4urputykawcqg6t98xul2w` to `fetchvaloper122veneudkzyalay6gusvrhhpp0560mparpanvu`:

Similarly, you can obtain the list of re-delegations issued by a delegator by running the following command:

    fetchd query staking redelegations fetch15fn3meky8ktfry3qm73xkpjckzw4dazxpfx34m

### How to query rewards[](#how-to-query-rewards)

Once you have delegated tokens to a validator, you will be eligible to a share of the rewards the validator collects.

If you wish to **retrieve all the outstanding rewards for a specific address**, run the following command using the `fetchd` command-line interface, :

    fetchd query distribution rewards DELEGATOR_ADDRESS

You will need to replace `DELEGATOR_ADDRESS` with the actual address of the delegator whose rewards you want to query. For instance:

    fetchd query distribution rewards fetch15fn3meky8ktfry3qm73xkpjckzw4dazxpfx34m

This command will provide information about the rewards earned by the specified delegator, including details such as the validator addresses and the amount of rewards in different denominations. The output will be a list of rewards, each represented in a block of information. Below you can find an example output:

    rewards:
    - validator_address: fetchvaloper1z72rph6l5j6ex83n4urputykawcqg6t98xul2w
      reward:
      - denom: atestfet
        amount: "0.000000000000200000"
    - validator_address: fetchvaloper1ysc8n5uspv4698nyk8u75lx98uu92zt7m3udw8
      reward:
      - denom: atestfet
        amount: "0.000000000001000000"
    total:
    - denom: atestfet
      amount: "0.000000000001200000"

In this example, the delegator at `DELEGATOR_ADDRESS` has earned rewards from two different validators on `dorado` test network. The rewards are listed in different denominations, such as `atestfet`.

You can also **filter rewards for a given validator**. For instance, you can filter rewards for `validator5` (`fetchvaloper1z72rph6l5j6ex83n4urputykawcqg6t98xul2w`) as shown below:

    fetchd query distribution rewards fetch15fn3meky8ktfry3qm73xkpjckzw4dazxpfx34m fetchvaloper1z72rph6l5j6ex83n4urputykawcqg6t98xul2w

In the output, we get the rewards from this specific validator:

    - denom: atestfet
      amount: "0.000000000000200000"

Delegator operations[](#delegator-operations)
---------------------------------------------

### How to delegate tokens[](#how-to-delegate-tokens)

If you want to delegate `1000000 atestfet` tokens to the `fetchvaloper1z72rph6l5j6ex83n4urputykawcqg6t98xul2w` validator from the account `myKey`, then you will need to use the following command:

    fetchd tx staking delegate fetchvaloper1z72rph6l5j6ex83n4urputykawcqg6t98xul2w 1000000atestfet --from myKey

This will require a confirmation before issuing a transaction. After the transaction gets processed, it should appear under the delegations of the `fetchvaloper1z72rph6l5j6ex83n4urputykawcqg6t98xul2w` validator.

ℹ️

Once delegated, tokens can only be _re-delegated_ to another validator, or _unbond_ in order to be returned to their original account. It is important to note that those two operations take **21 days to complete**, period in which the involved tokens will be unavailable.

### Re-delegating tokens[](#re-delegating-tokens)

**Re-delegating tokens allows you to transfer already delegated tokens from one validator to another**.

From the above example where you delegated `1000000 atestfet` to `fetchvaloper1z72rph6l5j6ex83n4urputykawcqg6t98xul2w`, you can now re-delegate parts or all of those tokens to another validator. For instance, you can re-delegate `400000 atestfet` from `fetchvaloper1z72rph6l5j6ex83n4urputykawcqg6t98xul2w` to `fetchvaloper122veneudkzyalay6gusvrhhpp0560mparpanvu` by running the following command:

    fetchd tx staking redelegate fetchvaloper1z72rph6l5j6ex83n4urputykawcqg6t98xul2w fetchvaloper122veneudkzyalay6gusvrhhpp0560mparpanvu 400000atestfet --from myKey

This will prompt for confirmation and issue a new transaction once accepted.

From here, if you inspect the delegations from our account, you will be able to see that your delegated tokens are now:

*   `600000atestfet` to validator `fetchvaloper1z72rph6l5j6ex83n4urputykawcqg6t98xul2w` (our initial 1000000 minus the 400000 re-delegated).
*   `400000atestfet` to validator `fetchvaloper122veneudkzyalay6gusvrhhpp0560mparpanvu`.

Now, those `400000 atestfet` you re-delegated can not be re-delegated anymore for 21 days (the exact date can be found by querying the re-delegation transaction, under the `completion_time` key).

ℹ️

It is still possible to unbond those tokens if needed.

### How to unbond tokens[](#how-to-unbond-tokens)

**Bonding** refers to the act of locking up a certain amount of cryptocurrency tokens in a wallet or smart contract to participate in the network’s consensus mechanism. These tokens are often referred to as the **stake**. Conversely, **unbonding** is the process of withdrawing or releasing the previously bonded tokens. When a user initiates an unbonding transaction, they are indicating that they want to take back their tokens from the staking mechanism.

You can transfer parts or all of our delegated tokens back to your account at any time by running the following command:

    fetchd tx staking unbond fetchvaloper1z72rph6l5j6ex83n4urputykawcqg6t98xul2w 300000atestfet --from myKey

Once again, this will prompt for confirmation and issue a transaction, initiating the transfer of `300000 atestfet` from our stake on `fetchvaloper1z72rph6l5j6ex83n4urputykawcqg6t98xul2w` validator address back to your account. Those tokens will then be available **after a 21 day period** (the exact date can be found by querying the re-delegation transaction, under the `completion_time` key).

### How to withdraw rewards[](#how-to-withdraw-rewards)

In order **to transfer rewards to the wallet**, run the following command:

    fetchd tx distribution withdraw-rewards validator_address --from myKey

It requires the validator address from where the reward is withdrawn, and the name of the account private key having delegated tokens to the validator. For instance:

    fetchd tx distribution withdraw-rewards fetchvaloper1z72rph6l5j6ex83n4urputykawcqg6t98xul2w --from myKey

You can **claim all rewards when you have delegated tokens to multiple validators**, by running the following command:

    fetchd tx distribution withdraw-all-rewards --from myKey

The rewards will appear on the account as soon as the transaction is being processed.</content>
</page>

<page>
  <title>Governance proposals</title>
  <url>https://network.fetch.ai/docs/guides/cli/governance-proposals</url>
  <content>Within any decentralized network, any significant change or adjustment should be proposed and subsequently agreed upon by the community or stakeholders involved. This process ensures that decisions are made collectively, helping to maintain transparency, fairness, and the overall integrity of the network.

Hence, **a governance proposal must be submitted to change any attribute of a network**. This could be a simple poll, a software update or a governing parameter change. Whether it is a minor parameter tweak or a major software update, the proposal process is a crucial step in decentralized systems.

For further information on governance within the Fetch Ledger, have a look at the following [documentation](https://network.fetch.ai/docs/guides/ledger/governance)

### Parameter change[](#parameter-change)

This is an example of the process in which network parameters may be changed through the use of a governance proposal.

The values within this code can be changed in order to alter the minimum deposited fund threshold for a proposal to enter the voting phase, and the length of the deposit stage in which the minimum deposit threshold must be met.

    # A JSON file containing the following code should be created to instantiate the proposal.
    # The two variables of interest are the "amount" which is set from 10000000stake to 1000stake
    # and the "max_deposit_period" which is changed from the default value to 7200000000000
    # equal to 2 hours, instead of the standard 2 days (in nanoseconds).
    
    {
      "title": "Staking Param Change",
      "description": "Update max validators",
      "changes": [
        {
          "subspace": "staking",
          "key": "MaxValidators",
          "value": 105
        }
      ],
      "deposit": "1000000000000000000atestfet"
    }

    # Create initial proposal by uploading the JSON file
    # this is signed by a key 'proposer' that provides a portion of the current threshold deposit
    fetchd tx gov submit-proposal --proposal ~/json_path/proposal.json --from proposer
    
    # In order to later refer to this proposal, the proposal_id can be determined
    fetchd query gov proposals

### Proposal deposit phase[](#proposal-deposit-phase)

The characteristics of the deposit phase are described by a set of network governance parameters, where the deposit period is two days from the initial proposal deposit until expiration, and a minimum threshold of 10000000 denom as default. The minimum threshold must be met during this deposit period in order to proceed to the voting phase. The proposer may provide all of this threshold, or just some. In which case, supporters of the proposal may donate additional funding towards the goal of meeting the threshold.

At any point of the deposit stage, the deposit pot can be queried:

    # To get the proposal ID, use the txhash obtained when the proposal was submitted and run the following command:
    fetchd query tx <txhash>
    
    # This command returns a text representation of the current total deposit value of a proposal
    fetchd query gov deposits <proposal_id>
    
    # Other users may contribute to funding the proposal using
    fetchd tx gov deposit <proposal_id> <deposit_amount> --from contributor

### Proposal voting and querying[](#proposal-voting-and-querying)

After the deposit period has passed, there are two outcomes:

*   The current minimum threshold is met.
*   The value is not met and the funds are returned.

In the first case this proposal is submitted and to be voted on, returning a tally at the end of the voting period.

In order to submit a vote on a proposal that has passed into the voting phase, all staked users except the proposer may do so using this command.

    # Submit a vote from a key 'voter' with the desired outcome of the voter
    fetchd tx gov vote <proposal_id> <yes|no|no_with_veto|abstain> --from voter

The current voting turnout and tally can be queried, which displays a list of all voters and their choice:

    # The current voting statistics can be printed using
    fetchd query gov votes <proposal_id>

#### Example output[](#example-output)

    votes:
    - option: VOTE_OPTION_YES
      proposal_id: "1"
      voter: fetch1dmehhhvul8y7slqs3zu2z3fede9kzlnyupd9rr
    - option: VOTE_OPTION_NO
      proposal_id: "1"
      voter: fetch1064endj5ne5e868asnf0encctwlga4y2jf3h28
    - option: VOTE_OPTION_YES
      proposal_id: "1"
      voter: fetch1k3ee923osju93jm03fkfmewnal39fjdbakje1x

### Voting outcome[](#voting-outcome)

Once the voting period has ended, the results are used to determine the next step of the proposal. The potential outcomes include:

*   **Majority _yes_ vote**
    
    *   The proposal passes through and the users act according to the proposal type - e.g. A Software update proposal passes, and users begin uptake of the new version.
*   **Majority _no_ vote**
    
    *   The funds deposited to pass into the voting stage are returned, and there is no governance change.
*   **Majority _no with veto_ vote**
    
    *   This outcome is indicative of a proposal which may undermine the current governance system, e.g. a proposal to set the deposit threshold or voting period to an absurd value.
    *   All funds deposited in the proposal are to be burned subject to this outcome, and there is no governance change.</content>
</page>

<page>
  <title>Installation</title>
  <url>https://network.fetch.ai/docs/guides/cosmpy/installation</url>
  <content>Welcome to **CosmPy**, the Python-based library that streamlines your interactions with Cosmos SDK based blockchain networks.

System Requirements[](#system-requirements)
-------------------------------------------

The [CosmPy](https://pypi.org/project/cosmpy/)  package is a Python library running on Ubuntu/Debian, and MacOS systems.

On your computer, you may need to install:

*   [Python](https://www.python.org/downloads/)  3.8, 3.9 or 3.10.
*   [PIP](https://pypi.org/project/pip/)  (Python Installs Packages).
*   [Poetry](https://python-poetry.org/)  for virtual environments (optional).
*   [CosmPy](https://pypi.org/project/cosmpy/) .

Walk-through[](#walk-through)
-----------------------------

Install with Pip[](#install-with-pip)
-------------------------------------

1.  First of all, create a directory for cosmpy related projects: `mkdir directory_name`
    
2.  Within the directory, let’s create and open a virtual environment using Poetry: `poetry init -n && poetry shell` (Optional)
    
3.  Then, install CosmPy with the following command: `pip install cosmpy`
    
4.  Finally, check if installation was successful: `pip show cosmpy`
    

Once installed, you should see the following output on your terminal:

    Name: cosmpy
    Version: 0.9.0
    Summary: A library for interacting with the cosmos networks
    Home-page: https://github.com/fetchai/cosmpy
    Author: Fetch.AI Limited
    Author-email:
    License: Apache-2.0
    Requires: bech32, ecdsa, grpcio, jsonschema, protobuf, pycryptodome, python-dateutil, requests

Install from source code[](#install-from-source-code)
-----------------------------------------------------

1.  First of all, download the latest released version from Github and navigate to the cosmpy directory:
    
        git clone https://github.com/fetchai/cosmpy.git
        cd cosmpy
    
2.  Then install the required dependencies:
    
3.  Lastly, open the virtual environment:
    

For more information on CosmPy, visit our dedicated [GitHub](https://github.com/fetchai/cosmpy)  repository.

Last updated on

May 14, 2025

[Registration and endpoints weighting](https://network.fetch.ai/docs/introduction/almanac/endpoints "Registration and endpoints weighting")</content>
</page>

<page>
  <title>Connecting to a blockchain</title>
  <url>https://network.fetch.ai/docs/guides/cosmpy/connect-blockchain</url>
  <content>Once you have installed CosmPy, you can **connect and begin interacting with Cosmos-based blockchains**. You can do so by running the following command:

    import cosmpy
    from cosmpy.aerial.client import LedgerClient, NetworkConfig
     
    # Connecting to the Fetch.ai mainnet
    ledger_client = LedgerClient(NetworkConfig.fetch_mainnet())

In the code snippet above, we are using the `LedgerClient` as a client object which takes a `NetworkConfig` as an argument. For ease of use, network configurations are provided automatically. For instance, `NetworkConfig.fetch_mainnet()` is the configuration for the [Fetch ledger](https://network.fetch.ai/docs/introduction/ledger/ledger-intro). However, CosmPy allows you to customize the network configuration and interact with other chains.

ℹ️

You can explore a full list of chain identifiers, denominations and endpoints at [chain registry](https://github.com/cosmos/chain-registry/) .

Below, you can find an example of a custom network configuration:

    cfg = NetworkConfig(
        chain_id="cosmoshub-4",
        url="grpc+https://grpc-cosmoshub.blockapsis.com:429",
        fee_minimum_gas_price=1,
        fee_denomination="uatom",
        staking_denomination="uatom",
    )
     
    ledger_client = LedgerClient(cfg)

Last updated on

May 14, 2025

[Registration and endpoints weighting](https://network.fetch.ai/docs/introduction/almanac/endpoints "Registration and endpoints weighting")</content>
</page>

<page>
  <title>Querying balances</title>
  <url>https://network.fetch.ai/docs/guides/cosmpy/querying-address-balances</url>
  <content>Once you have established a [connection to a network node](https://network.fetch.ai/docs/guides/cosmpy/connect-blockchain), you can use the `LegderClient` object to perform many useful operations, such as **querying balances**. In particular the `LedgerClient` object allows you to:

1.  Query all balances associated with a **particular address**.
2.  Query all balances associated with a **particular denomination**.

Let’s explore how to achieve both.

1.  We start by importing CosmPy as well as the relevant modules.
    
2.  Then, we connect to the chain we want to perform the query on.
    
3.  Once connected, we specify the address we want to query. In our example we will connect to the Fetch.ai mainnet and we query all balances associated with a particular address:
    
        import cosmpy
        from cosmpy.aerial.client import LedgerClient, NetworkConfig
         
        ledger_client = LedgerClient(NetworkConfig.fetch_mainnet())
         
        address: str = 'fetch12q5gw9l9d0yyq2th77x6pjsesczpsly8h5089x'
        balances = ledger_client.query_bank_all_balances(address)
        print(balances)
    

Whenever **querying all balances associated with a _particular address_** returns a `List` of `Coin` objects that contain `amount` and `denom` variables that correspond to all the funds held at the address and their denominations.

ℹ️

This list includes all natively defined coins along with any tokens transferred using the inter-blockchain communication [IBC](https://ibcprotocol.org/)  protocol.

Once completed, you will see the following output in your terminal:

    [Coin(amount='1616060698998992698400', denom='afet'), Coin(amount='10', denom='ibc/605C5B80A8253543F8038F96F56BA13BDD8D300E12F1B32A3FA2E1EB2A933FA1'), Coin(amount='5000000', denom='ibc/B58E6786772640EC4B538AFC4393F742C326734B74CCAFAFBF7EFDC7D435B428')]

In order to \*\*query all balances associated with a _particular denomination_\*+, we can run the same script but substitute the final balance command we used in the snippet above, with:

    balance = ledger_client.query_bank_balance(address, denom='afet')

This will return the value of the (integer) funds held by the address with the specified denomination. If the `denom` argument is omitted the function will return the fee denomination specified in the `NetworkConfig` object used to initialize the `LedgerClient`.

Last updated on

May 14, 2025

[Registration and endpoints weighting](https://network.fetch.ai/docs/introduction/almanac/endpoints "Registration and endpoints weighting")</content>
</page>

<page>
  <title>Wallets and private keys</title>
  <url>https://network.fetch.ai/docs/guides/cosmpy/creating-wallet</url>
  <content>Introduction[](#introduction)
-----------------------------

**Wallets** allow individuals to manage, store and transact across blockchain networks. Wallets are composed of a public and private key pair. The private key is a unique and secret cryptographic code that provides ownership and control over the wallet and allows individuals to authorize transactions signing. The public address is a cryptographic identifier that allows individuals to receive and view transactions.

Changes to the state of a network are achieved by broadcasting transactions. To accomplish this, we can use CosmPy in a straightforward way to create and manage private keys and addresses. In this guide, you will learn how to both generate a **new private key** as well as **recover a previously generated one**.

The examples below outlines how to achieve both of these operations.

Generate a new private key[](#generate-a-new-private-key)
---------------------------------------------------------

First of all, import the needed modules and then use the `PrivateKey` class to create your `private_key`:

    # Import necessary classes
    from cosmpy.aerial.wallet import LocalWallet
    from cosmpy.crypto.keypairs import PrivateKey
     
    # Creating a random private key
    private_key = PrivateKey()

Recover an existing private key[](#recover-an-existing-private-key)
-------------------------------------------------------------------

Let’s start by extracting the private key and convert it into a base64 encoded string. You can do this on macOS or Linux for the Fetch.ai network using the FetchD CL.

An example is provided in the code snippet below:

    # Extract the private key and convert it into a base64 encoded string
    fetchd keys export mykeyname --unsafe --unarmored-hex | xxd -r -p | base64

Once you have extracted and converted the key into a base64 encoded string you can recover to an existing private key by following along the provided example below:

    # Import necessary classes
    from cosmpy.aerial.wallet import LocalWallet
    from cosmpy.crypto.keypairs import PrivateKey
     
    # Recovering an existing private key
    private_key = PrivateKey('<base64 encoded private key>') # Here is where you provide the base64 encoded private key string

The `PrivateKey` object is one of CosmPy’s low level primitives. This is why it is generally paired with a `Wallet` object. You can now create a local wallet using the `LocalWallet` class from the CosmPy library and initialize it with the `private_key` you generated or recovered earlier. The `LocalWallet` class is used to manage a local wallet associated with a private key for interacting with the Cosmos blockchain.

With this wallet object, you can perform various operations, such as generating the corresponding public address associated with the private key and signing transactions. You can also query useful information such as the address from the wallet directly. The example below showcases how to achieve both of these outlined operations:

    wallet = LocalWallet(private_key)
    print(wallet.address()) # will print the address for the wallet

From mnemonic[](#from-mnemonic)
-------------------------------

You can also use an account’s mnemonic phrase to get the associated private key. The example provided below showcases how to achieve that:

    from cosmpy.aerial.wallet import LocalWallet
     
    mnemonic = "person knife december tail tortoise jewel warm when worry limit reward memory piece cool sphere kitchen knee embody soft own victory sauce silly page"
     
    wallet = LocalWallet.from_mnemonic(mnemonic)</content>
</page>

<page>
  <title>Sending funds</title>
  <url>https://network.fetch.ai/docs/guides/cosmpy/transaction-broadcast</url>
  <content>CosmPy allows for simplification of transactions broadcasting. After [creating a wallet](https://network.fetch.ai/docs/guides/cosmpy/creating-wallet) you can send transactions by following the below provided example. In it, we first connect to the desired network then provide the desired destination address. The transaction is then broadcast using the `Ledger_client.send_tokens()` function:

    from cosmpy.aerial.client import LedgerClient, NetworkConfig
     
    # Establishing connection to the network
    ledger_client = LedgerClient(NetworkConfig.fetch_mainnet())
     
    # Providing destination address
    destination_address = 'fetch1h2l3cnu7e23whmd5yrfeunacez9tv0plv5rxqy'
     
    # Broadcasting the transaction
    tx = ledger_client.send_tokens(destination_address, 10, "atestfet", wallet)
     
    # block until the transaction has been successful or failed
    tx.wait_to_complete()

In this example, we want to send 10 atestfet tokens to the `destination_address`. The `send_tokens()` method is called on the `ledger_client` object, which is an instance of the `LedgerClient` class used to interact with the Fetch.ai blockchain network. The parameter wallet is the local wallet used to sign the transaction and provide the necessary credentials. The code then waits for the transaction to complete (either successfully or failed) before proceeding further.

Sending and verifying a transaction[](#sending-and-verifying-a-transaction)
---------------------------------------------------------------------------

For a more comprehensive example, we will use the **testnet** and submit a transaction then verify its completion by exploring the output on the terminal. For transactions made on the mainnet it is advisable to use our [block explorer](https://explore.fetch.ai/)  or any other block explorer, such as [Mintscan](https://www.mintscan.io/fetchai) . The following code snippet shows you how to create two wallets, namely for `alice` and `bob`.

Once created, the next step is to establish a connection to Fetch.ai’s testnet. We then query `alice`’s balance and include a while function to make sure `alice` has a positive balance and can perform the transaction. In this case `alice` will send `bob` 10 atestfet. As a final step, we will print the transaction hash, as well as `bob`’s and `alice`’s related balances:

     
    # Import the required libraries and modules
    from cosmpy.aerial.client import LedgerClient, NetworkConfig  # Required to establish a connection to the network
    from cosmpy.aerial.faucet import FaucetApi  # Required to fund Alice's wallet if she has a 0 balance
    from cosmpy.aerial.wallet import LocalWallet  # Required to create Alice and Bob's local wallets
     
     
    def main():
        """Run main."""
        # Create Alice and Bob's wallets
        alice = LocalWallet.generate()
        bob = LocalWallet.generate()
     
        # Establish a connection to the testnet
        ledger = LedgerClient(NetworkConfig.fetchai_stable_testnet())
        faucet_api = FaucetApi(NetworkConfig.fetchai_stable_testnet())
     
        # Query Alice's Balance
        alice_balance = ledger.query_bank_balance(bob.address())
     
        # Should alice have no funds in her wallet, add funds
        while alice_balance < (10 ** 18):
            print("Providing wealth to alice...")
            faucet_api.get_wealth(alice.address())
            alice_balance = ledger.query_bank_balance(alice.address())
     
        # Print Alice and Bob's getting-uagent-address and balances
        print(
            f"Alice Address: {alice.address()} Balance: {ledger.query_bank_balance(alice.address())}"
        )
     
        print(
            f"Bob   Address: {bob.address()} Balance: {ledger.query_bank_balance(bob.address())}"
        )
     
        # Broadcast the transaction and print the outputs on the terminal
        tx = ledger.send_tokens(bob.address(), 10, "atestfet", alice)
        print(f"TX {tx.tx_hash} waiting to complete...")
     
        tx.wait_to_complete()
     
        print(f"TX {tx.tx_hash} waiting to complete...done")
     
        print(
            f"Alice Address: {alice.address()} Balance: {ledger.query_bank_balance(alice.address())}"
        )
     
        print(
            f"Bob   Address: {bob.address()} Balance: {ledger.query_bank_balance(bob.address())}"
        )
     
     
    if __name__ == "__main__":
        main()
     

Once you have executed the script, you will notice the console output is consistent with the code. At first, we see a print of the starting balance of both addresses. Then, we see the transaction hash along with the new balances for both `alice` and `bob`:

    Alice Address: fetch1kfsarzv8s0kl7pcznjgyc6mnaz96akl79kzttv Balance: 10000000000000000000
    Bob   Address: fetch1ww8gsxk4usmq0tdjyele4nqyxcmc3zquu3fc52 Balance: 0
    TX 25E8F5D9F101DB5AC57DC5FF2566BA4F290609B6AADBFF1D566B398BA5FFAF48 waiting to complete...
    TX 25E8F5D9F101DB5AC57DC5FF2566BA4F290609B6AADBFF1D566B398BA5FFAF48 waiting to complete...done
    Alice Address: fetch1kfsarzv8s0kl7pcznjgyc6mnaz96akl79kzttv Balance: 9999416775000000512
    Bob   Address: fetch1ww8gsxk4usmq0tdjyele4nqyxcmc3zquu3fc52 Balance: 10

Last updated on

May 14, 2025

[Registration and endpoints weighting](https://network.fetch.ai/docs/introduction/almanac/endpoints "Registration and endpoints weighting")</content>
</page>

<page>
  <title>Staking</title>
  <url>https://network.fetch.ai/docs/guides/cosmpy/staking</url>
  <content>Introduction[](#introduction)
-----------------------------

**Staking** is a crucial mechanism for Proof-of-Stake (PoS) based blockchains, empowering users to actively participate in securing the network while earning rewards. Staked (delegated) funds are bonded to validator nodes. These validator nodes validate transactions and maintaining the network’s integrity. By bonding funds to validators, individuals earn governance rights and actively contribute to the network’s security and decentralization.

ℹ️

Bonding is the process of telling the network of your choice that you want to stake tokens on it. The bonding period is the lapse of time the blockchain delegator waits before his asset are bonded. Conversely, unbonding is the action of telling the network you want to unlock those assets. The unbonding period is the designated amount of time that a blockchain delegator waits before having access to move or sell their tokens.

Delegating[](#delegating)
-------------------------

Considering CosmPy, the `Ledgerclient` object provides utilities for interacting with the staking component of the network. As you continue to explore this guide, you will notice that the `LedgerClient` object plays a part in all stake related processes. To begin with, we will start with one example to showcase how to use CosmPy to delegate 20 FET to a validator, using a `wallet` object:

    validator_address = 'fetchvaloper1e4ykjwcwhwtasqxq50d4m7xz9hh7a86e9y8h87'
     
    tx = ledger_client.delegate_tokens(validator_address, 20, wallet)
     
    # block until the transaction has been successful or failed
    tx.wait_to_complete()

Re-delegating[](#re-delegating)
-------------------------------

Similarly to the delegate option, re-delegating is the process of unbonding staked funds from one validator node and bonding them to another. This is highly useful in cases where a better validator option has arisen or in crisis management situations where a rapid re-delegation is needed. In the example below, you will learn how to re-delegate 10 tokens from an existing `validator_address` to another `alternative_validator_address`:

    validator_address = 'fetchvaloper1e4ykjwcwhwtasqxq50d4m7xz9hh7a86e9y8h87'
    alternate_validator_address = 'fetchvaloper1e4ykjwcwhwtasqxq50d4m7xz9hh7a86e9y8h87'
     
    tx = ledger_client.redelegate_tokens(validator_address, alternate_validator_address, 10, wallet)
     
    # block until the transaction has been successful or failed
    tx.wait_to_complete()

Undelegating[](#undelegating)
-----------------------------

Undelegated funds go through an **unbonding period** (i.e., typically 14 to 21 days for Cosmos sdk based projects) and once their unbonding period is complete funds become transferable. The code snippet we have shared, showcases how to use the `LedgerClient` object to invoke the undelegation (in this case 5 tokens) and start the cool down process.

Importantly, the cool down is tracked for each undelegation invocation. For instance, if you trigger 3 undelegate actions on 3 consecutive days the first batch of tokens will become available 3 days before the final batch. In the snippet below, we provide the command needed to undelegate your tokens:

    tx = ledger_client.undelegate_tokens(validator_address, 5, wallet)
     
    # block until the transaction has been successful or failed
    tx.wait_to_complete()

Claiming Rewards[](#claiming-rewards)
-------------------------------------

**Delegated funds accrue rewards**. Rewards can be collected at any time and unlike delegations become immediately available.

You can claim rewards from a specific validator using the following commands:

    tx = ledger_client.claim_rewards(validator_address, wallet)
     
    # block until the transaction has been successful or failed
    tx.wait_to_complete()

Stake queries[](#stake-queries)
-------------------------------

Additionally, CosmPY allows you to perform useful **stake queries** and **summaries**. You can query the stake information on any particular address at any point using the `LedgerClient` as shown in the example below:

    address = 'fetch1h2l3cnu7e23whmd5yrfeunacez9tv0plv5rxqy'
     
    s = ledger_client.query_staking_summary(address)
    print(f"Summary: Staked: {s.total_staked} Unbonding: {s.total_unbonding} Rewards: {s.total_rewards}")</content>
</page>

<page>
  <title>Smart contracts</title>
  <url>https://network.fetch.ai/docs/guides/cosmpy/smart-contracts</url>
  <content>Deploy a smart contract[](#deploy-a-smart-contract)
---------------------------------------------------

CosmPy offers the possibility to easily deploy **smart contracts** using the `LedgerContract` object. For this, you will need the **path** to where the contract is stored (in this case `simple.wasm`), a [`LedgerClient`](https://network.fetch.ai/docs/guides/cosmpy/connect-blockchain) and a [Wallet](https://network.fetch.ai/docs/guides/cosmpy/creating-wallet).

The example below shows how to achieve this:

    from cosmpy.aerial.contract import LedgerContract
     
    PATH = "contracts/simple/simple.wasm"
     
    contract = LedgerContract(PATH, ledger_client)
    contract.deploy({}, wallet)

Interact with smart contracts[](#interact-with-smart-contracts)
---------------------------------------------------------------

We can now start interacting with any smart contract in different ways by executing one of the following operations.

### Retrieve contract address[](#retrieve-contract-address)

After deployment, you can obtain the address of the deployed contract on the network using the `address` method in the following way:

    print(f"Contract deployed at: {contract.address}")

### Query contract’s state variables[](#query-contracts-state-variables)

We can also query the values of the contract’s state variables using the `query` method and provide a dictionary specifying the query information:

    result = contract.query({"get": {"owner": wallet}})
    print("Initial state:", result)

### Set contract’s state variables[](#set-contracts-state-variables)

We can update the contract’s state variables by using the `execute` method and by providing a dictionary specifying the update wanted. Use the `wait_to_complete()` method to wait for the execution to finish.

The following code sets the state variable `value` to `foobar`:

    contract.execute({"set": {"value": "foobar"}}, wallet).wait_to_complete()

Once you set a state variable to its updated value, you can query it again to confirm such changes took place effectively. Considering the example above, we can check if changes were set correctly in the following way:

    result = contract.query({"get": {"owner": wallet)}})
    print("State after set:", result)

### Clear state variables[](#clear-state-variables)

We can clear the contract’s state variables using the `execute` method in the following way:

    contract.execute({"clear": {}}, wallet).wait_to_complete()

Then, we can check if the operation was correctly executed by running what follows:

    result = contract.query({"get": {"owner": wallet}})
    print("State after clear:", result)</content>
</page>

<page>
  <title>Stake auto-compounder</title>
  <url>https://network.fetch.ai/docs/guides/cosmpy/use-cases/stake-auto-compounder</url>
  <content>Introduction[](#introduction)
-----------------------------

The Stake Auto-Compounder is a CosmPy based use case developed using Python and designed to automate the process of staking tokens in a blockchain network, claiming rewards, and compounding those rewards by re-delegating them to a validator. When an account delegates tokens to a network’s validator, it will start generating rewards proportionally to the amount of [`Stake`](https://network.fetch.ai/docs/guides/cosmpy/staking) delegated. But since rewards are not automatically added to your stake and therefore do not contribute to future rewards, we can perform a compounding strategy to generate exponential rewards.

Delegate your tokens[](#delegate-your-tokens)
---------------------------------------------

The first thing we need to do is delegate some tokens to a `validator`. You can do so by using a [`Wallet`](https://network.fetch.ai/docs/guides/cosmpy/creating-wallet) and specifying the validator address and amount. you can delegate tokens to a specific validator by using the `delegate_tokens` method of the `ledger_client` object and specifying the validator’s address, the amount of tokens and the wallet from which the delegation is made:

    validators = ledger_client.query_validators()
     
    # choose any validator
    validator = validators[0]
     
    key = PrivateKey("FX5BZQcr+FNl2usnSIQYpXsGWvBxKLRDkieUNIvMOV7=")
    wallet = LocalWallet(key)
     
    # delegate some tokens to this validator
    tx = ledger_client.delegate_tokens(validator.address, 9000000000000000000, wallet)
    tx.wait_to_complete()

Auto-compounder[](#auto-compounder)
-----------------------------------

We can write a script helping us to claim rewards and delegating the rewarded tokens back to the `validator` of choice. This way we keep growing our `Stake` given the generated compounded rewards on such staked amount. We first need to define the `time limit` and the compounding `period`.

Importantly, bear in mind that each time an account performs a claim or a delegate a transaction, it has to pay certain fees. Therefore, the compounding period has to be long enough to generate sufficient rewards to exceed the fees that will be paid in each transaction and generate a profit.

After having defined such parameters, we can then start a timer that claims rewards and delegates them in each time period:

    time_check = 0
    start_time = time.monotonic()
    time.sleep(period)
     
    # query, claim and delegate rewards after time period
    while time_check < time_limit:
     
        begin = time.monotonic()
     
        summary = ledger_client.query_staking_summary(wallet.address())
        print(f"Staked: {summary.total_staked}")
     
        balance_before = ledger_client.query_bank_balance(wallet.address())
     
        tx = ledger_client.claim_rewards(validator.address, wallet)
        tx.wait_to_complete()
     
        balance_after = ledger_client.query_bank_balance(wallet.address())
     
        # reward after any fees
        true_reward = balance_after - balance_before
     
        if true_reward > 0:
     
            print(f"Staking {true_reward} (reward after fees)")
     
            tx = ledger_client.delegate_tokens(validator.address, true_reward, wallet)
            tx.wait_to_complete()
     
        else:
            print("Fees from claim rewards transaction exceeded reward")
     
        end = time.monotonic()
     
        time.sleep(period-(end-begin))
        time_check = time.monotonic() - start_time

In the code snippet above we defined a while loop running until the timer exceeds the `time limit`. Each loop will last the time specified in `period`. We query the balance before and after claiming rewards to get the value of the reward after any fees. If the true reward value is positive, we delegate those tokens to the validator, if it is negative, it means that the fees from claiming and delegating transactions exceeded the rewards, and therefore we will not delegate.

Walk-through[](#walk-through)
-----------------------------

Below we provide a step-by-step guide to create an auto-compounder using the `cosmpy.aerial` package.

1.  First of all, create a Python script and name it:
    
        echo. > aerial_compounder.py
    
2.  We need to import the necessary modules, including `argparse`, `time`, and various modules from the `cosmpy.aerial` package:
    

     
    import argparse
    import time
     
    from cosmpy.aerial.client import LedgerClient
    from cosmpy.aerial.config import NetworkConfig
    from cosmpy.aerial.faucet import FaucetApi
    from cosmpy.aerial.wallet import LocalWallet
     

3.  We now need to define a `_parse_commandline()` function responsible for parsing command-line arguments when the script is being executed:

     
    def _parse_commandline():
        parser = argparse.ArgumentParser()
        parser.add_argument(
            "initial_stake",
            type=int,
            nargs="?",
            default=9000000000000000000,
            help="Initial amount of atestfet to delegate to validator",
        )
        parser.add_argument(
            "time_limit",
            type=int,
            nargs="?",
            default=600,
            help="total time",
        )
        parser.add_argument(
            "period",
            type=int,
            nargs="?",
            default=100,
            help="compounding period",
        )
     
        return parser.parse_args()
     

We first create a `parser` instance of the `ArgumentParser` class using the `argparse` module. Argument parsers are used to specify and parse command-line arguments. The `add_argument()` method is used to specify the arguments that the script will accept. It takes several parameters, including:

*   `name`: the name of the argument.
*   `type`: the type to which the argument should be converted (in this case, `int`).
*   `nargs`: the number of arguments expected (in this case, `"?"` means zero or one argument).
*   `default`: the default value if the argument is not provided.
*   `help`: a brief description of the argument, which will be displayed if the user asks for help with the script.

Three arguments are defined in this function:

*   `initial_stake`: the initial amount of tokens to delegate to a validator. It expects an integer and has a default value of `9000000000000000000`.
*   `time_limit`: the total time limit for the compounder. It expects an integer (representing seconds) and has a default value of `600` seconds (10 minutes).
*   `period`: the compounding period, which is the interval between each compounding operation. It expects an integer (also in seconds) and has a default value of `100` seconds.

The last line of the snippet above, `parser.parse_args()`, parses the command-line arguments provided when the script is executed. The function returns the parsed arguments object.

4.  We are now ready to define our `main()` function:

     
    def main():
        """Run main."""
        args = _parse_commandline()
     
        ledger = LedgerClient(NetworkConfig.fetchai_stable_testnet())
        faucet_api = FaucetApi(NetworkConfig.fetchai_stable_testnet())
     
        # get all the active validators on the network
        validators = ledger.query_validators()
     
        # choose any validator
        validator = validators[0]
     
        alice = LocalWallet.generate()
     
        wallet_balance = ledger.query_bank_balance(alice.address())
        initial_stake = args.initial_stake
     
        while wallet_balance < (initial_stake):
            print("Providing wealth to wallet...")
            faucet_api.get_wealth(alice.address())
            wallet_balance = ledger.query_bank_balance(alice.address())
     
        # delegate some tokens to this validator
        tx = ledger.delegate_tokens(validator.address, initial_stake, alice)
        tx.wait_to_complete()
     
        # set time limit and compounding period in seconds
        time_limit = args.time_limit
        period = args.period
     
        time_check = 0
        start_time = time.monotonic()
        time.sleep(period)
     
        # query, claim and stake rewards after time period
        while time_check < time_limit:
     
            begin = time.monotonic()
     
            summary = ledger.query_staking_summary(alice.address())
            print(f"Staked: {summary.total_staked}")
     
            balance_before = ledger.query_bank_balance(alice.address())
     
            tx = ledger.claim_rewards(validator.address, alice)
            tx.wait_to_complete()
     
            balance_after = ledger.query_bank_balance(alice.address())
     
            # reward after any fees
            true_reward = balance_after - balance_before
     
            if true_reward > 0:
     
                print(f"Staking {true_reward} (reward after fees)")
     
                tx = ledger.delegate_tokens(validator.address, true_reward, alice)
                tx.wait_to_complete()
     
            else:
                print("Fees from claim rewards transaction exceeded reward")
     
            print()
     
            end = time.monotonic()
            time.sleep(period - (end - begin))
            time_check = time.monotonic() - start_time
     
     
    if __name__ == "__main__":
        main()
     

The first line calls the `_parse_commandline()` function we defined earlier. It returns an object with the parsed command-line arguments. We then create two objects:

*   A `ledger` instance of the `Ledger Client` class configured for the Fetch.ai stable testnet. This client will be used to interact with the blockchain network.
*   A `faucet_api` instance of the `Faucet API` class configured for the Fetch.ai stable testnet. This API is used for providing additional funds to the wallet if needed.

We then need to get all the active validators on the network by using the `query_validators()` method. After this, we choose a validator and create a new wallet named `alice` using `LocalWallet.generate()` and check the balance of the `alice` wallet. If the balance is less than the initial stake, it enters a loop to provide wealth to the wallet using the faucet API until the balance reaches the specified initial stake. We can now delegate the initial stake of tokens to the chosen validator using the `delegate_tokens()` method.

We proceed by setting time limits and periods. `time_limit = args.time_limit` sets the time limit based on the command-line argument, whereas `period = args.period` sets the compounding period based on the command-line argument. After this, we define the compounding loop, similar to what was described in the first part of this guide: it iterates over a specified time period, queries staking summary, claims rewards, and either stakes the rewards or skips if fees exceed rewards. Time management is important here: indeed, the loop keeps track of time using `time.monotonic()` to ensure it does not exceed the specified time limit. It waits for the specified period before starting the next compounding cycle.

5.  Save the script.

The overall script should look as follows:

     
    import argparse
    import time
     
    from cosmpy.aerial.client import LedgerClient
    from cosmpy.aerial.config import NetworkConfig
    from cosmpy.aerial.faucet import FaucetApi
    from cosmpy.aerial.wallet import LocalWallet
     
     
    def _parse_commandline():
        parser = argparse.ArgumentParser()
        parser.add_argument(
            "initial_stake",
            type=int,
            nargs="?",
            default=9000000000000000000,
            help="Initial amount of atestfet to delegate to validator",
        )
        parser.add_argument(
            "time_limit",
            type=int,
            nargs="?",
            default=600,
            help="total time",
        )
        parser.add_argument(
            "period",
            type=int,
            nargs="?",
            default=100,
            help="compounding period",
        )
     
        return parser.parse_args()
     
     
    def main():
        """Run main."""
        args = _parse_commandline()
     
        ledger = LedgerClient(NetworkConfig.fetchai_stable_testnet())
        faucet_api = FaucetApi(NetworkConfig.fetchai_stable_testnet())
     
        # get all the active validators on the network
        validators = ledger.query_validators()
     
        # choose any validator
        validator = validators[0]
     
        alice = LocalWallet.generate()
     
        wallet_balance = ledger.query_bank_balance(alice.address())
        initial_stake = args.initial_stake
     
        while wallet_balance < (initial_stake):
            print("Providing wealth to wallet...")
            faucet_api.get_wealth(alice.address())
            wallet_balance = ledger.query_bank_balance(alice.address())
     
        # delegate some tokens to this validator
        tx = ledger.delegate_tokens(validator.address, initial_stake, alice)
        tx.wait_to_complete()
     
        # set time limit and compounding period in seconds
        time_limit = args.time_limit
        period = args.period
     
        time_check = 0
        start_time = time.monotonic()
        time.sleep(period)
     
        # query, claim and stake rewards after time period
        while time_check < time_limit:
     
            begin = time.monotonic()
     
            summary = ledger.query_staking_summary(alice.address())
            print(f"Staked: {summary.total_staked}")
     
            balance_before = ledger.query_bank_balance(alice.address())
     
            tx = ledger.claim_rewards(validator.address, alice)
            tx.wait_to_complete()
     
            balance_after = ledger.query_bank_balance(alice.address())
     
            # reward after any fees
            true_reward = balance_after - balance_before
     
            if true_reward > 0:
     
                print(f"Staking {true_reward} (reward after fees)")
     
                tx = ledger.delegate_tokens(validator.address, true_reward, alice)
                tx.wait_to_complete()
     
            else:
                print("Fees from claim rewards transaction exceeded reward")
     
            print()
     
            end = time.monotonic()
            time.sleep(period - (end - begin))
            time_check = time.monotonic() - start_time
     
     
    if __name__ == "__main__":
        main()</content>
</page>

<page>
  <title>Stake optimizer</title>
  <url>https://network.fetch.ai/docs/guides/cosmpy/use-cases/stake-optimizer</url>
  <content>Getting started[](#getting-started)
-----------------------------------

Whenever we delegate tokens to a validator for a determined period, you can use the [`auto-compounder`️](https://network.fetch.ai/docs/guides/cosmpy/use-cases/stake-auto-compounder) to get increasing rewards. You can maximize your rewards for a given staking period by selecting an optimal compounding period. To do this, you will need to follow these steps:

*   **Set and query variables**: when calculating staking rewards, you need to set and query variables such as staking parameters, transaction fees, and network parameters.
*   **Calculate reward rate**: after you select and query all the variables needed, you will calculate the reward rate.
*   **Calculate optimal compounding period**: you will calculate the optimal compounding period that will maximize your rewards.

First of all, we need to define a network to work with:

    from cosmpy.aerial.client import LedgerClient
    from cosmpy.aerial.config import NetworkConfig
     
    ledger = LedgerClient(NetworkConfig.fetchai_stable_testnet())

Set and query variables[](#set-and-query-variables)
---------------------------------------------------

### Staking variables[](#staking-variables)

First, we need to define the desired amount and the total period that we would like to stake in: `initial_stake` and `total_period` variables. Here we will stake 50 TESTFET for 60000 minutes. For this guide, we will work with minutes as a time unit:

    initial_stake = 50000000000000000000
    total_period = 60000

### Validator selection and variables[](#validator-selection-and-variables)

We are now ready to select a validator to delegate our tokens. We can do this by analyzing which one has the lowest commission and a reasonable amount of stake delegated compared to the total stake.

    from cosmpy.protos.cosmos.staking.v1beta1.query_pb2 import QueryValidatorsRequest
     
    req = QueryValidatorsRequest()
    resp = ledger.staking.Validators(req)
     
    # Calculate the total stake currently in the testnet
    # Status = 3 means that the validator is bonded
    validators_stake = [int(validator.tokens) for validator in resp.validators if validator.status == 3]
    total_stake = sum(validators_stake)
     
    # For every bonded validator, we print commission and percentage of total stake
    print("MONIKER      COMMISSION   % of TOTAL STAKE")
    for validator in resp.validators:
        if validator.status == 3:
            moniker = validator.description.moniker
            commission = int(validator.commission.commission_rates.rate)/1e18*100
            print(moniker[:10]," ", commission,"%     ", round(int(validator.tokens)/total_stake*100,3),"%")

Once you run the code above, you will observe each validator commission rate and its percentage delegated of the total stake. The most important parameter to observe in each validator is the commission it takes from rewards. We should always select a validator with the lower commission as long as it has a reasonable stake compared with the total stake.

    # get all the active validators on the network
    validators = ledger.query_validators()
     
    # Query info of selected validator
    selected_validator = "validator0"
    validator = [v for v in validators if v.moniker == selected_validator][0]
    query_validator = [v for v in resp.validators if v.description.moniker == selected_validator][0]
     
    # Set the commission %
    commission = int(query_validator.commission.commission_rates.rate)/1e18
     
    # Set percentage delegated of total stake
    pct_delegated = initial_stake/total_stake

In this case, at the moment the code is run, all validators have the same commission, therefore, we simply select the validator with the highest stake, which is validator0. Feel free to select the most convenient validator when you run the code above. We will save the variables `commission` and the fraction `pct_delegated` of our `initial_stake` to the `total_stake` to use them both later on.

### Estimate transaction fees[](#estimate-transaction-fees)

We now need to know an estimate of the transaction fees we will face every time we claim rewards and delegate tokens. For that, both claim rewards and delegate tokens transactions were combined into a single multi-msg transaction to simulate the total fees.

    from cosmpy.aerial.client.distribution import create_withdraw_delegator_reward
    from cosmpy.aerial.client.staking import create_delegate_msg
    from cosmpy.aerial.tx import SigningCfg
    from cosmpy.aerial.wallet import LocalWallet
    from cosmpy.crypto.keypairs import PrivateKey
    from cosmpy.crypto.address import Address
    from cosmpy.aerial.tx import Transaction
     
    # Use any address with at least the amount of initial_stake available
    key = PrivateKey("XZ5BZQcr+FNl2usnSIQYpXsGWvBxKLRDkieUNIvMOV7=")
    alice = LocalWallet(key)
    alice_address = Address(key)._display
     
    tx = Transaction()
     
    # Add delegate msg
    tx.add_message(create_delegate_msg(alice_address,validator.address,initial_stake,"atestfet"))
     
    # Add claim reward msg
    tx.add_message(create_withdraw_delegator_reward(alice_address, validator.address))
     
    account = ledger.query_account(alice.address())
    tx.seal(SigningCfg.direct(alice.public_key(), account.sequence),fee="",gas_limit=0)
    tx.sign(alice.signer(), ledger.network_config.chain_id, account.number)
    tx.complete()
     
    # simulate the fee for the transaction
    _, str_tx_fee = ledger.estimate_gas_and_fee_for_tx(tx)

Since the output of this function is a string, we need to convert it to an int and round it up to get a more conservative estimate for the `fee`.

    denom = "atestfet"
    tx_fee = str_tx_fee[:-len(denom)]
     
    # Add a 20% to the fee estimation to get a more conservative estimate
    fee = int(tx_fee) * 1.20

### Query network variables[](#query-network-variables)

There are three network variables that we need to query since they will contribute to the staking rewards calculation: `total_supply`, `inflation`, and `community_tax`.

    # Total Supply of tokens
    req = QueryTotalSupplyRequest()
    resp = ledger.bank.TotalSupply(req)
    total_supply = float(json.loads(resp.supply[0].amount))
     
    # Inflation
    req = QueryParamsRequest(subspace="mint", key="InflationRate")
    resp = ledger.params.Params(req)
    inflation = float(json.loads(resp.param.value))
     
    # Community Tax
    req = QueryParamsRequest(subspace="distribution", key="communitytax")
    resp = ledger.params.Params(req)
    community_tax = float(json.loads(resp.param.value))

### Calculate reward rate[](#calculate-reward-rate)

We can now proceed to calculate a theoretical staking rewards rate using the variables gathered above. These are: `inflation`, `total_supply`, `pct_delegated`, `community_tax` and `commission`:

    # Calculate annual reward
    annual_reward = (inflation * total_supply) *pct_delegated* (1- community_tax)*(1- commission)
     
    # Convert from annual reward to minute reward
    minute_reward = annual_reward/360/24/60
     
    # Set the rate
    rate = minute_reward/initial_stake

### Calculate optimal compounding period[](#calculate-optimal-compounding-period)

We can calculate the optimal compounding period that maximizes our staking rewards analytically by using the following formula:

Where:

*   M = Total stake at time D
*   S = Initial Stake
*   f = Transaction Fee
*   k = Reward Rate
*   m = Number Of Compounding Transactions
*   n = Compounding Period
*   D = m x n = Total Staking Time

We will now find the value that maximizes reward by taking the first derivative with respect to _n_ and finding the root in the interval _(0,D\]_:

    import numpy as np
    from sympy.utilities.lambdify import lambdify, implemented_function
    from sympy import *
    from scipy.optimize import brentq
     
    f = fee
    S = initial_stake
    k = rate
    D = total_period
     
    # x will represent n
    x = Symbol("x")
     
    # Define the function
    M = (S*(1+(k*x))**(D/x))+((1-((1+(k*x))**(D/x)))/(k*x))*f
    Mx = lambdify(x,M)
     
    # Take the first derivative with respect to x
    M_prime = M.diff(x)
    Mx_prime = lambdify(x,M_prime)
     
    # Find the maximum reward value by finding the root of the function
    optimal_period = brentq(Mx_prime, 0.1, D)
     
    print("optimal_period: ", analytical_optimal_period, " minutes")

You can make use of the `optimal_period` value in the staking [`auto-compounder`️](https://network.fetch.ai/docs/guides/cosmpy/use-cases/stake-auto-compounder) to maximize your rewards.

You can also plot the function along with the optimal period to observe the results in the following manner:

    import matplotlib.pyplot as plt
     
    plot = plt.figure(0,figsize=(6,4), dpi=100)
     
    y = np.linspace(1,300, 100)
    plt.plot(y,Mx(y),"k", label = 'analytical function')
    plt.axvline(x = optimal_period, color = 'g', linewidth = 2, label = f'optimal period: {round(optimal_period)}')
    plt.legend()
     
    plt.xlabel("Compounding periods")
    plt.ylabel('Total Reward')
    plt.title('Maximizing Rewards')
    plt.grid()

Finally, we can compare the compounding staking rewards to a simple non-compounding strategy:

    # Compounding Strategy
    comp_rewards = []
    rewards = 0
    period = optimal_period
    S = initial_stake
    for i in range(total_period):
        rewards = rewards + (S*rate)
        if i%period == 0:
            S = S + rewards - fee
            rewards = 0
        comp_rewards.append(S)
    S = S + rewards - (fee/2)
    comp_rewards.append(S)
     
    # Simple Strategy
    s_reward = initial_stake*rate
    simple_rewards = [initial_stake+(s_reward*i) for i in range(comp_period)]
     
    # Plots
    plot = plt.figure(0,figsize=(12,4), dpi=100)
     
    plt.subplot(1,2,1)
    plt.plot(comp_rewards, label = "Compounded Rewards")
    plt.plot(simple_rewards, label = "Simple Rewards")
    plt.xlabel("time in minutes")
    plt.ylabel('Reward')
    plt.title('Staking Rewards')
    plt.legend()
     
    plt.subplot(1,2,2)
     
    plt.plot(total_rewards, label = "Compounded Rewards")
    plt.plot(simple_rewards, label = "Simple Rewards")
    plt.xlabel("time in minutes")
    plt.ylabel('Reward')
    plt.title('Staking Rewards (log scale)')
    plt.legend()
     
    plt.yscale('log')

Now that we have presented the concepts and ideas behind the stake optimizer, have a look at the abbreviated version of the code provided below:

aerial\_stake\_optimizer.py

     
    import json
     
    from cosmpy.aerial.client import LedgerClient, NetworkConfig
    from cosmpy.aerial.client.distribution import create_withdraw_delegator_reward
    from cosmpy.aerial.client.staking import create_delegate_msg
    from cosmpy.aerial.faucet import FaucetApi
    from cosmpy.aerial.tx import SigningCfg, Transaction
    from cosmpy.aerial.wallet import LocalWallet
    from cosmpy.protos.cosmos.bank.v1beta1.query_pb2 import QueryTotalSupplyRequest
    from cosmpy.protos.cosmos.params.v1beta1.query_pb2 import QueryParamsRequest
    from cosmpy.protos.cosmos.staking.v1beta1.query_pb2 import QueryValidatorsRequest
     
     
    # This function returns the total reward for given:
    # * f -> fee
    # * S -> Initial Stake
    # * k -> Reward Rate
    # * D -> Total staking period
    # * x -> Compounding Period
    def M(x, f, S, k, D):
        """
        Calculate the total reward.
     
        :param x: Compounding Period
        :param f: fee
        :param S: Initial Stake
        :param k: Reward Rate
        :param D: Total staking period
     
        :return: Total reward
        """
        return (S * (1 + (k * x)) ** (D / x)) + (
                (1 - ((1 + (k * x)) ** (D / x))) / (k * x)
        ) * f
     
     
    def main():
        """Run main."""
        ledger = LedgerClient(NetworkConfig.fetchai_stable_testnet())
        faucet_api = FaucetApi(NetworkConfig.fetchai_stable_testnet())
     
        # Set initial stake and desired stake period
        initial_stake = 50000000000000000000
        total_period = 60000
     
        req = QueryValidatorsRequest()
        resp = ledger.staking.Validators(req)
     
        # Calculate the total staked in the testnet
     
        total_stake = 0
        # validator.status == 3 refers to bonded validators
        validators_stake = [
            int(validator.tokens) for validator in resp.validators if validator.status == 3
        ]
        total_stake = sum(validators_stake)
     
        # Get validators commissions
        validators_commission = [
            int(validator.commission.commission_rates.rate)
            for validator in resp.validators
            if validator.status == 3
        ]
     
        validators = ledger.query_validators()
        validator = "not_selected"
     
        # Choose a threshold for a validators minimum percentage of total stake delegated
        stake_threshold = 0.10
     
        for _i in range(len(validators_commission)):
     
            # Choose validator with lower commission
            validator_index = validators_commission.index(min(validators_commission))
     
            # Verify that it meets the minimum % threshold
            validator_stake_pct = validators_stake[validator_index] / total_stake
            if validator_stake_pct >= stake_threshold:
                # Set the selected validator
                validator = validators[validator_index]
                break
     
            # We omit this validator by setting his commission to infinity
            validators_commission[validator_index] = float("inf")
     
        if validator == "not_selected":
            # Restart validators_commission list with original values
            validators_commission = [
                int(validator.commission.commission_rates.rate)
                for validator in resp.validators
                if validator.status == 3
            ]
     
            print("No validator meets the minimum stake threshold requirement")
     
            # Proceed to select the validator with the lowest commission
            validator_index = validators_commission.index(min(validators_commission))
            validator = validators[validator_index]
     
        # Query validator commission
        commission = float(resp.validators[0].commission.commission_rates.rate) / 1e18
     
        # Set percentage delegated of total stake
        pct_delegated = initial_stake / total_stake
     
        # Estimate fees for claiming and delegating rewards
     
        alice = LocalWallet.generate()
        alice_address = str(alice.address())
     
        alice_balance = ledger.query_bank_balance(alice.address())
     
        while alice_balance < initial_stake:
            print("Providing wealth to alice...")
            faucet_api.get_wealth(alice.address())
            alice_balance = ledger.query_bank_balance(alice.address())
     
        tx = Transaction()
     
        # Add delegate msg
        tx.add_message(
            create_delegate_msg(alice_address, validator.address, initial_stake, "atestfet")
        )
     
        # Add claim reward msg
        tx.add_message(create_withdraw_delegator_reward(alice_address, validator.address))
     
        account = ledger.query_account(alice.address())
     
        tx.seal(
            SigningCfg.direct(alice.public_key(), account.sequence), fee="", gas_limit=0
        )
        tx.sign(alice.signer(), ledger.network_config.chain_id, account.number)
        tx.complete()
     
        # simulate the fee for the transaction
        _, str_tx_fee = ledger.estimate_gas_and_fee_for_tx(tx)
     
        denom = "atestfet"
        tx_fee = str_tx_fee[: -len(denom)]
     
        # Add a 20% to the fee estimation to get a more conservative estimate
        fee = int(tx_fee) * 1.20
     
        # Query chain variables
     
        # Total Supply of tokens
        req = QueryTotalSupplyRequest()
        resp = ledger.bank.TotalSupply(req)
        total_supply = float(json.loads(resp.supply[0].amount))
     
        # Inflation
        req = QueryParamsRequest(subspace="mint", key="InflationRate")
        resp = ledger.params.Params(req)
        inflation = float(json.loads(resp.param.value))
     
        # Community Tax
        req = QueryParamsRequest(subspace="distribution", key="communitytax")
        resp = ledger.params.Params(req)
        community_tax = float(json.loads(resp.param.value))
     
        # Annual reward calculation
        annual_reward = (
                (inflation * total_supply)
                * pct_delegated
                * (1 - community_tax)
                * (1 - commission)
        )
     
        # Convert from annual reward to minute reward
        minute_reward = annual_reward / 360 / 24 / 60
        rate = minute_reward / initial_stake
     
        # Compute optimal period
        f = fee
        S = initial_stake
        k = rate
        D = total_period
     
        # List of compounding periods
        X = list(range(1, D))
     
        # Evaluate function M on each compounding period
        R = [M(x, f, S, k, D) for x in X]
     
        # Fnd the period that maximizes rewards
        optimal_period = R.index(max(R)) + 1
     
        # These values can be used in aerial_compounder.py to maximize rewards
        print("total period: ", total_period, "minutes")
        print("optimal compounding period: ", optimal_period, "minutes")
     
     
    if __name__ == "__main__":
        main()</content>
</page>

<page>
  <title>Oracles</title>
  <url>https://network.fetch.ai/docs/guides/cosmpy/use-cases/oracles</url>
  <content>Introduction[](#introduction)
-----------------------------

**Oracles** are entities that can update state variables in smart contracts and whose goal is usually to accurately estimate or predict some real world quantity or quantities. These quantities can then be used in the logic of other smart contracts. This guide shows how to write a CosmPy script that deploys and updates an oracle contract with a coin price, and another script that deploys a contract that queries this coin price.

Walk-through[](#walk-through)
-----------------------------

Here we provide an overview guide for setting up your own aerial oracle in few steps.

We initially need to download the binaries for both contracts, which can be done as follows:

    wget https://raw.githubusercontent.com/fetchai/agents-aea/develop/packages/fetchai/contracts/oracle/build/oracle.wasm
    wget https://raw.githubusercontent.com/fetchai/agents-aea/develop/packages/fetchai/contracts/oracle_client/build/oracle_client.wasm

### Aerial oracle[](#aerial-oracle)

1.  First of all, create a Python script and name it:
    
2.  We would then also require the following imports:
    

     
    import argparse
    from time import sleep
     
    import requests
     
    from cosmpy.aerial.client import LedgerClient, NetworkConfig
    from cosmpy.aerial.contract import LedgerContract
    from cosmpy.aerial.faucet import FaucetApi
    from cosmpy.aerial.wallet import LocalWallet
    from cosmpy.crypto.address import Address
     

3.  We then need to choose a data source for the coin price, the update interval, the decimal precision, and the decimal timeout for the oracle value:

     
    COIN_PRICE_URL = (
        "https://api.coingecko.com/api/v3/simple/price?ids=fetch-ai&vs_currencies=usd"
    )
    UPDATE_INTERVAL_SECONDS = 10
    ORACLE_VALUE_DECIMALS = 5
    DEFAULT_TIMEOUT = 60.0
     

4.  We then proceed and define a `_parse_commandline()` function by first importing the `argparse` module, which is a standard Python module for parsing command-line arguments:

     
    def _parse_commandline():
        parser = argparse.ArgumentParser()
        parser.add_argument(
            "contract_path", help="The path to the oracle contract to upload"
        )
        parser.add_argument(
            "contract_address",
            nargs="?",
            type=Address,
            help="The address of the oracle contract if already deployed",
        )
        return parser.parse_args()
     

This first creates an argument `parser` object. The `ArgumentParser` class provides a way to specify the arguments your script should accept and automatically generates help messages and error messages. We then use `add_argument()` to add a positional argument named `contract_path`. This argument is required and should be a path to the oracle contract that you want to upload. The help argument provides a description of what this argument does. We further add another positional argument named `contract_address`. This argument is optional (`nargs="?"` allows it to be omitted), and it should be of type `Address`. The `type` argument specifies the type of the argument. In this case, `Address` is a custom type or class used to represent addresses. The `help` argument provides a description of what this argument does. At the end, we parse the command-line arguments provided when the script is executed. It returns an object that contains the values of the parsed arguments.

5.  We then need to proceed and define our `main()` function:

     
    def main():
        """Run main."""
        args = _parse_commandline()
     
        wallet = LocalWallet.generate()
     
        ledger = LedgerClient(NetworkConfig.fetchai_stable_testnet())
        faucet_api = FaucetApi(NetworkConfig.fetchai_stable_testnet())
     
        wallet_balance = ledger.query_bank_balance(wallet.address())
     
        while wallet_balance < (10 ** 18):
            print("Providing wealth to wallet...")
            faucet_api.get_wealth(wallet.address())
            wallet_balance = ledger.query_bank_balance(wallet.address())
     
        contract = LedgerContract(args.contract_path, ledger, address=args.contract_address)
     
        if not args.contract_address:
            instantiation_message = {"fee": "100"}
            contract.deploy(instantiation_message, wallet, funds="1atestfet")
     
        print(f"Oracle contract deployed at: {contract.address}")
     
        grant_role_message = {"grant_oracle_role": {"address": wallet}}
        contract.execute(grant_role_message, wallet).wait_to_complete()
     
        print(f"Oracle role granted to address: {wallet}")
     
        while True:
            resp = requests.get(COIN_PRICE_URL, timeout=DEFAULT_TIMEOUT).json()
            price = resp["fetch-ai"]["usd"]
            value = int(price * 10 ** ORACLE_VALUE_DECIMALS)
     
            update_message = {
                "update_oracle_value": {
                    "value": str(value),
                    "decimals": str(ORACLE_VALUE_DECIMALS),
                }
            }
            contract.execute(update_message, wallet).wait_to_complete()
     
            print(f"Oracle value updated to: {price} USD")
            print(f"Next update in {UPDATE_INTERVAL_SECONDS} seconds...")
            sleep(UPDATE_INTERVAL_SECONDS)
     
     
    if __name__ == "__main__":
        main()
     

This defines our `main()` function. When we run the script, the code inside `main()` will be executed. `args = _parse_commandline()` calls the `_parse_commandline()` function that we defined earlier. It parses the command-line arguments and returns an object (`args`) containing the values of the parsed arguments. We then generate a new local wallet, and then create a client for interacting with a blockchain ledger, using `LedgerClient()` class. We configured it to use the Fetch.ai stable testnet. We then create a client for interacting with a faucet API and query the balance of the wallet’s address using the `query_bank_balance()` method. We also define an initial `while` loop which continues as long as the `wallet_balance` is less than `10**18`. Inside this first loop: it prints a message indicating that wealth is being provided to the wallet, then it calls the faucet API to get wealth for the wallet, and it updates the `wallet_balance` by querying the bank balance again.

After this, we create a `contract` object using `LedgerContract()`: this takes the path to the oracle contract file, the ledger client, and optionally, the contract address. `if not args.contract_address:` condition checks if `args.contract_address` is not provided. If it has not been provided, it means the contract has not been deployed yet. We then set up an instantiation message with a fee of 100. We can then deploy the contract using the provided instantiation message, the wallet, and a specified fund source (`"1atestfet"` in this case).

The `print()` function prints the address of the deployed oracle contract. After this, we define a `grant_role_message` object which sets up a message to grant the oracle role to the address associated with the wallet, and execute the message to grant the oracle role and wait for the transaction to complete. The following `print()` function prints a message indicating that the oracle role has been granted to the address associated with the wallet.

We can finally define a second `while` loop which runs indefinitely: it sends a GET request to a URL (`COIN_PRICE_URL`) to retrieve coin prices, then extracts the price in USD. It then calculates a value based on the price and the specified decimal precision (`ORACLE_VALUE_DECIMALS`), and sets up an update message with the new oracle value. Lastly, it executes the update message, waits for the transaction to complete, prints the updated oracle value and indicates when the next update will occur.

This script let us interact with a blockchain ledger, deploy a contract, and perform oracle-related tasks such as updating values based on external data.

6.  Save the script.

The overall script should be as follows:

     
    import argparse
    from time import sleep
     
    import requests
     
    from cosmpy.aerial.client import LedgerClient, NetworkConfig
    from cosmpy.aerial.contract import LedgerContract
    from cosmpy.aerial.faucet import FaucetApi
    from cosmpy.aerial.wallet import LocalWallet
    from cosmpy.crypto.address import Address
     
    COIN_PRICE_URL = (
        "https://api.coingecko.com/api/v3/simple/price?ids=fetch-ai&vs_currencies=usd"
    )
    UPDATE_INTERVAL_SECONDS = 10
    ORACLE_VALUE_DECIMALS = 5
    DEFAULT_TIMEOUT = 60.0
     
     
    def _parse_commandline():
        parser = argparse.ArgumentParser()
        parser.add_argument(
            "contract_path", help="The path to the oracle contract to upload"
        )
        parser.add_argument(
            "contract_address",
            nargs="?",
            type=Address,
            help="The address of the oracle contract if already deployed",
        )
        return parser.parse_args()
     
     
    def main():
        """Run main."""
        args = _parse_commandline()
     
        wallet = LocalWallet.generate()
     
        ledger = LedgerClient(NetworkConfig.fetchai_stable_testnet())
        faucet_api = FaucetApi(NetworkConfig.fetchai_stable_testnet())
     
        wallet_balance = ledger.query_bank_balance(wallet.address())
     
        while wallet_balance < (10 ** 18):
            print("Providing wealth to wallet...")
            faucet_api.get_wealth(wallet.address())
            wallet_balance = ledger.query_bank_balance(wallet.address())
     
        contract = LedgerContract(args.contract_path, ledger, address=args.contract_address)
     
        if not args.contract_address:
            instantiation_message = {"fee": "100"}
            contract.deploy(instantiation_message, wallet, funds="1atestfet")
     
        print(f"Oracle contract deployed at: {contract.address}")
     
        grant_role_message = {"grant_oracle_role": {"address": wallet}}
        contract.execute(grant_role_message, wallet).wait_to_complete()
     
        print(f"Oracle role granted to address: {wallet}")
     
        while True:
            resp = requests.get(COIN_PRICE_URL, timeout=DEFAULT_TIMEOUT).json()
            price = resp["fetch-ai"]["usd"]
            value = int(price * 10 ** ORACLE_VALUE_DECIMALS)
     
            update_message = {
                "update_oracle_value": {
                    "value": str(value),
                    "decimals": str(ORACLE_VALUE_DECIMALS),
                }
            }
            contract.execute(update_message, wallet).wait_to_complete()
     
            print(f"Oracle value updated to: {price} USD")
            print(f"Next update in {UPDATE_INTERVAL_SECONDS} seconds...")
            sleep(UPDATE_INTERVAL_SECONDS)
     
     
    if __name__ == "__main__":
        main()
     

### Oracle client[](#oracle-client)

Now, we will write a script that deploys a contract that can request the oracle value in exchange for the required fee.

1.  Let’s first create a Python script and name it:
    
        echo. > aerial_oracle_client.py
    
2.  We start by importing the needed classes and define a `REQUEST_INTERVAL_SECONDS` variable:
    

     
    import argparse
    from time import sleep
     
    from cosmpy.aerial.client import LedgerClient, NetworkConfig
    from cosmpy.aerial.contract import LedgerContract
    from cosmpy.aerial.faucet import FaucetApi
    from cosmpy.aerial.wallet import LocalWallet
    from cosmpy.crypto.address import Address
     
    REQUEST_INTERVAL_SECONDS = 10
     

3.  Like before, we proceed and define a `_parse_commandline()` function:

     
    def _parse_commandline():
        parser = argparse.ArgumentParser()
        parser.add_argument(
            "contract_path", help="The path to the oracle client contract to upload"
        )
        parser.add_argument(
            "oracle_contract_address",
            type=Address,
            help="The address of the oracle contract",
        )
        parser.add_argument(
            "contract_address",
            nargs="?",
            type=Address,
            help="The address of the oracle client contract if already deployed",
        )
        return parser.parse_args()
     

This `_parse_commandline()` function is designed to parse command-line arguments. We first create a `parser` object. This object is used to specify what command-line arguments the program should expect. We then use the `add_argument()` method to define the arguments that the program expects. In this function, there are three arguments being defined:

*   `contract_path`: this is a required argument. It expects a string representing the path to the oracle client contract to upload.
*   `oracle_contract_address`: this is also a required argument. It expects an `Address` object representing the address of the oracle contract.
*   `contract_address`: this is an optional argument. It expects an `Address` object and is used to specify the address of the oracle client contract if it has already been deployed. The `nargs="?"` indicates that this argument is optional.

The function returns an object containing the parsed values.

4.  We can now define our `main()` function.

     
    def main():
        """Run main."""
        args = _parse_commandline()
     
        wallet = LocalWallet.generate()
     
        ledger = LedgerClient(NetworkConfig.fetchai_stable_testnet())
        faucet_api = FaucetApi(NetworkConfig.fetchai_stable_testnet())
     
        wallet_balance = ledger.query_bank_balance(wallet.address())
     
        while wallet_balance < (10**18):
            print("Providing wealth to wallet...")
            faucet_api.get_wealth(wallet.address())
            wallet_balance = ledger.query_bank_balance(wallet.address())
     
        contract = LedgerContract(args.contract_path, ledger, address=args.contract_address)
     
        if not args.contract_address:
            instantiation_message = {
                "oracle_contract_address": str(args.oracle_contract_address)
            }
            contract.deploy(instantiation_message, wallet)
     
        print(f"Oracle client contract deployed at: {contract.address}")
     
        while True:
            request_message = {"query_oracle_value": {}}
            contract.execute(
                request_message, wallet, funds="100atestfet"
            ).wait_to_complete()
     
            result = contract.query({"oracle_value": {}})
            print(f"Oracle value successfully retrieved: {result}")
     
            sleep(REQUEST_INTERVAL_SECONDS)
     
    if __name__ == "__main__":
        main()
     

The first line calls the `_parse_commandline()` function that we defined earlier. It will parse the command-line arguments and return an object (`args`) containing the parsed values. We proceed and generate a new local wallet, `wallet`, and then create a new `ledger` object for interacting with the blockchain or ledger system, using `LedgerClient()`. Afterwards, we create a `FaucetApi` object, `faucet_api`, which is used for interacting with the faucet service. We use the `query_bank_balance()` method to query the balance associated with the wallet’s address. We then define a `while` loop which will continue as long as the `wallet_balance` is less than `10**18`. This is to ensure the wallet has a sufficient balance. Afterwards, we use the `get_wealth()` method to add wealth to the wallet, and then create a new `LedgerContract()` object which takes the `contract_path`, the `ledger` object, and an optional `contract_address`. `if not args.contract_address:` checks if `args.contract_address` is not provided. If it has not been provided, it means that the contract has not been deployed yet. We then create an `instantiation_message`, which contains the data needed for deploying the contract. `contract.deploy()` deploys the contract with the provided `instantiation_message` and the `wallet`. The code then prints out the address of the deployed contract. Finally, we define a second loop starting with `while True:` which repeatedly executes the following steps:

*   It creates a request message, which is used to query the oracle value.
*   It executes the contract function call with the request message, using the wallet for authorization. The funds argument is set to `"100atestfet"`.
*   It queries the contract for the oracle value.
*   It prints out the retrieved oracle value.
*   It finally waits for a specified number of seconds (defined by `REQUEST_INTERVAL_SECONDS`) before the next iteration. This is likely to prevent overloading the system with requests.

5.  Save the script.

The overall script should be as follows:

     
    import argparse
    from time import sleep
     
    from cosmpy.aerial.client import LedgerClient, NetworkConfig
    from cosmpy.aerial.contract import LedgerContract
    from cosmpy.aerial.faucet import FaucetApi
    from cosmpy.aerial.wallet import LocalWallet
    from cosmpy.crypto.address import Address
     
    REQUEST_INTERVAL_SECONDS = 10
     
    def _parse_commandline():
        parser = argparse.ArgumentParser()
        parser.add_argument(
            "contract_path", help="The path to the oracle client contract to upload"
        )
        parser.add_argument(
            "oracle_contract_address",
            type=Address,
            help="The address of the oracle contract",
        )
        parser.add_argument(
            "contract_address",
            nargs="?",
            type=Address,
            help="The address of the oracle client contract if already deployed",
        )
        return parser.parse_args()
     
    def main():
        """Run main."""
        args = _parse_commandline()
     
        wallet = LocalWallet.generate()
     
        ledger = LedgerClient(NetworkConfig.fetchai_stable_testnet())
        faucet_api = FaucetApi(NetworkConfig.fetchai_stable_testnet())
     
        wallet_balance = ledger.query_bank_balance(wallet.address())
     
        while wallet_balance < (10**18):
            print("Providing wealth to wallet...")
            faucet_api.get_wealth(wallet.address())
            wallet_balance = ledger.query_bank_balance(wallet.address())
     
        contract = LedgerContract(args.contract_path, ledger, address=args.contract_address)
     
        if not args.contract_address:
            instantiation_message = {
                "oracle_contract_address": str(args.oracle_contract_address)
            }
            contract.deploy(instantiation_message, wallet)
     
        print(f"Oracle client contract deployed at: {contract.address}")
     
        while True:
            request_message = {"query_oracle_value": {}}
            contract.execute(
                request_message, wallet, funds="100atestfet"
            ).wait_to_complete()
     
            result = contract.query({"oracle_value": {}})
            print(f"Oracle value successfully retrieved: {result}")
     
            sleep(REQUEST_INTERVAL_SECONDS)
     
    if __name__ == "__main__":
        main()
     

Bear in mind that specific data related to the oracle’s address and contract need to be provided by hand based on your personalized information!</content>
</page>

<page>
  <title>Liquidity pool</title>
  <url>https://network.fetch.ai/docs/guides/cosmpy/use-cases/liquidity-pool</url>
  <content>Introduction[](#introduction)
-----------------------------

This Liquidity pool interaction guide provides a practical demonstration of interacting with a liquidity pool on the Fetch.ai network. This script showcases various operations, including swapping assets, providing liquidity, and withdrawing liquidity, utilizing smart contracts and local wallets.

Walk-through[](#walk-through)
-----------------------------

1.  Let’s start by creating a Python script for this and name it:
    
        echo. > aerial_liquidity_pool.py
    
2.  Let’s then import the needed modules:
    

     
    import argparse
    import base64
    from cosmpy.aerial.client import LedgerClient, NetworkConfig
    from cosmpy.aerial.contract import LedgerContract
    from cosmpy.aerial.faucet import FaucetApi
    from cosmpy.aerial.wallet import LocalWallet
     

3.  We need to define a `_parse_commandline()` function:

     
    def _parse_commandline():
        parser = argparse.ArgumentParser()
        parser.add_argument(
            "swap_amount",
            type=int,
            nargs="?",
            default=10000,
            help="atestfet swap amount to get some cw20 tokens on wallet's address",
        )
        parser.add_argument(
            "cw20_liquidity_amount",
            type=int,
            nargs="?",
            default=100,
            help="amount of cw20 tokens that will be provided to LP",
        )
        parser.add_argument(
            "native_liquidity_amount",
            type=int,
            nargs="?",
            default=2470,
            help="amount of atestfet tokens that will be provided to LP",
        )
        return parser.parse_args()
     

The function expects and processes three command-line arguments:

*   `swap_amount`: this argument specifies the amount of atestfet tokens to swap in order to receive some cw20 tokens on the wallet’s address. It is an optional argument, and if not provided, it defaults to `10000`.
*   `cw20_liquidity_amount`: this argument sets the amount of cw20 tokens that will be provided to the liquidity pool. It is also optional and defaults to `100` if not provided.
*   `native_liquidity_amount`: this argument represents the amount of atestfet tokens that will be provided to the liquidity pool. Like the others, it is optional and defaults to `2470` if not specified.

The `help` parameter for each argument provides a description of what it is used for. The function then uses `parser.parse_args()` to process the command-line arguments provided by the user and return them as an object containing the values for `swap_amount`, `cw20_liquidity_amount`, and `native_liquidity_amount`.

4.  We are now ready to define our `main()` function, which orchestrates the interaction with a liquidity pool using the provided command-line arguments. We define it in multiple parts, as follows:

     
    def main():
        """Run main."""
        args = _parse_commandline()
     
        # Define any wallet
        wallet = LocalWallet.generate()
     
        # Network configuration
        ledger = LedgerClient(NetworkConfig.latest_stable_testnet())
     
        # Add tokens to wallet
        faucet_api = FaucetApi(NetworkConfig.latest_stable_testnet())
        faucet_api.get_wealth(wallet.address())
     
        # Define cw20, pair and liquidity token contracts
        token_contract_address = (
            "fetch1qr8ysysnfxmqzu7cu7cq7dsq5g2r0kvkg5e2wl2fnlkqss60hcjsxtljxl"
        )
        pair_contract_address = (
            "fetch1vgnx2d46uvyxrg9pc5mktkcvkp4uflyp3j86v68pq4jxdc8j4y0s6ulf2a"
        )
        liq_token_contract_address = (
            "fetch1alzhf9yhghud3qhucdjs895f3aek2egfq44qm0mfvahkv4jukx4qd0ltxx"
        )
     
        token_contract = LedgerContract(
            path=None, client=ledger, address=token_contract_address
        )
        pair_contract = LedgerContract(
            path=None, client=ledger, address=pair_contract_address
        )
        liq_token_contract = LedgerContract(
            path=None, client=ledger, address=liq_token_contract_address
        )
     
        print("Pool (initial state): ")
        print(pair_contract.query({"pool": {}}), "\n")
     

It starts by calling `_parse_commandline()` to retrieve the command-line arguments. These arguments control various aspects of the liquidity pool interaction, like swap amounts and liquidity provision. We then create new wallet called `wallet`. This wallet will be used for conducting transactions. We proceed and set the network configuration to the latest stable testnet. Through the `faucet_api` we add tokens to the wallet. This simulates the process of acquiring tokens from an external source. We go on and define the contract addresses. In the part, addresses of three different contracts (CW20 token, pair, and liquidity token contracts) are defined. These contracts are essential for interacting with the liquidity pool. Finally we print the initial pool state. This provides an initial snapshot of the liquidity pool before any actions are taken.

     
        # Swap atestfet for CW20 tokens
        swap_amount = str(args.swap_amount)
        native_denom = "atestfet"
     
        tx = pair_contract.execute(
            {
                "swap": {
                    "offer_asset": {
                        "info": {"native_token": {"denom": native_denom}},
                        "amount": swap_amount,
                    }
                }
            },
            sender=wallet,
            funds=swap_amount + native_denom,
        )
     
        print(f"Swapping {swap_amount + native_denom} for CW20 Tokens...")
        tx.wait_to_complete()
     
        print("Pool (after swap): ")
        print(pair_contract.query({"pool": {}}), "\n")
     
        # To provide cw20 token to LP, increase your allowance first
        cw20_liquidity_amount = str(args.cw20_liquidity_amount)
        native_liquidity_amount = str(args.native_liquidity_amount)
     
        tx = token_contract.execute(
            {
                "increase_allowance": {
                    "spender": pair_contract_address,
                    "amount": cw20_liquidity_amount,
                    "expires": {"never": {}},
                }
            },
            wallet,
        )
     
        print("Increasing Allowance...")
        tx.wait_to_complete()
     

In this part of the main() function, the script swaps a specified amount of atestfet tokens for CW20 tokens using the `pair_contract`. This is done by constructing a transaction with the `"swap"` operation. `swap_amount` is the amount of atestfet tokens to swap, retrieved from the command-line arguments. `native_denom` is set to `"atestfet"` which is the native token denomination. The transaction is executed with the `execute()` method, specifying the `"swap"` operation. The `sender` parameter is set to the user’s `wallet`, and the `funds` parameter is set to the amount being swapped in addition to the native denomination. The script then waits for the transaction to complete, and after this, a message is printed to indicate the swap operation has occurred. Within the function, we then provide CW20 tokens to the liquidity pool. The script first increases the allowance for the pair contract to spend CW20 tokens from the user’s wallet. The `cw20_liquidity_amount` is the amount of CW20 tokens to provide to the LP, retrieved from the command-line arguments. The `native_liquidity_amount` is the amount of atestfet tokens to provide to the LP, also retrieved from the command-line arguments. A transaction is created with the `"increase_allowance"` operation using the `execute()` method. The transaction specifies the `spender` (`pair_contract_address`), the `amount` to allow spending (`cw20_liquidity_amount`), and an `expires` parameter set to `never`. The script waits for the transaction to complete, and after this, a message is printed to indicate that the allowance has been increased.

     
        # Provide Liquidity
        # Liquidity should be added so that the slippage tolerance parameter isn't exceeded
     
        tx = pair_contract.execute(
            {
                "provide_liquidity": {
                    "assets": [
                        {
                            "info": {"token": {"contract_addr": token_contract_address}},
                            "amount": cw20_liquidity_amount,
                        },
                        {
                            "info": {"native_token": {"denom": native_denom}},
                            "amount": native_liquidity_amount,
                        },
                    ],
                    "slippage_tolerance": "0.1",
                }
            },
            sender=wallet,
            funds=native_liquidity_amount + native_denom,
        )
     
        print(
            f"Providing {native_liquidity_amount + native_denom} and {cw20_liquidity_amount}CW20 tokens to Liquidity Pool..."
        )
        tx.wait_to_complete()
     
        print("Pool (after providing liquidity): ")
        print(pair_contract.query({"pool": {}}), "\n")
     
        # Withdraw Liquidity
        LP_token_balance = liq_token_contract.query(
            {"balance": {"address": str(wallet.address())}}
        )["balance"]
     
        withdraw_msg = '{"withdraw_liquidity": {}}'
        withdraw_msg_bytes = withdraw_msg.encode("ascii")
        withdraw_msg_base64 = base64.b64encode(withdraw_msg_bytes)
        msg = str(withdraw_msg_base64)[2:-1]
     
        tx = liq_token_contract.execute(
            {
                "send": {
                    "contract": pair_contract_address,
                    "amount": LP_token_balance,
                    "msg": msg,
                }
            },
            sender=wallet,
        )
     
        print(f"Withdrawing {LP_token_balance} from pool's total share...")
        tx.wait_to_complete()
     
        print("Pool (after withdrawing liquidity): ")
        print(pair_contract.query({"pool": {}}), "\n")
     
     
    if __name__ == "__main__":
        main()
     

Within the `main()` script we would need to provide liquidity to the pool, ensuring that the slippage tolerance parameter isn’t exceeded. Liquidity is added by creating a transaction with the `"provide_liquidity"` operation. The assets being provided include CW20 tokens and atestfet tokens. These are specified in a list within the `"assets"` field of the operation. The script also sets a slippage tolerance of `0.1`, meaning that the price impact of the liquidity provision must be within 10% of the expected value. The transaction is executed with `execute()` method, specifying the `"provide_liquidity"` operation. The `sender` parameter is set to the user’s wallet, and the `funds` parameter includes the amount of atestfet tokens being provided. A message is printed indicating the amount of CW20 and atestfet tokens being provided to the liquidity pool.

Afterwards, the script initiates a withdrawal of liquidity from the pool. This involves creating a transaction with the `"withdraw_liquidity"` operation. The LP token balance is queried using `query()` method to determine the amount of LP tokens held by the user. A withdrawal message is constructed in JSON format and then encoded and base64-encoded to be included in the transaction. The transaction is executed with the `execute()`, specifying the `"send"` operation. The `contract` parameter is set to the pair contract address, the `amount` parameter is set to the LP token balance, and the `msg` parameter includes the withdrawal message. A message is printed indicating the amount of LP tokens being withdrawn from the pool. Also, the LP balance is printed after withdrawal take place.

In summary, the main function orchestrates a series of actions, simulating interactions with a liquidity pool. These actions include swapping tokens, providing liquidity, and withdrawing liquidity, and the state of the pool is printed at different stages to provide feedback to the user.

5.  Save the script.

The overall script should be as follows:

     
    import argparse
    import base64
    from cosmpy.aerial.client import LedgerClient, NetworkConfig
    from cosmpy.aerial.contract import LedgerContract
    from cosmpy.aerial.faucet import FaucetApi
    from cosmpy.aerial.wallet import LocalWallet
     
     
    def _parse_commandline():
        parser = argparse.ArgumentParser()
        parser.add_argument(
            "swap_amount",
            type=int,
            nargs="?",
            default=10000,
            help="atestfet swap amount to get some cw20 tokens on wallet's address",
        )
        parser.add_argument(
            "cw20_liquidity_amount",
            type=int,
            nargs="?",
            default=100,
            help="amount of cw20 tokens that will be provided to LP",
        )
        parser.add_argument(
            "native_liquidity_amount",
            type=int,
            nargs="?",
            default=2470,
            help="amount of atestfet tokens that will be provided to LP",
        )
        return parser.parse_args()
     
     
    def main():
        """Run main."""
        args = _parse_commandline()
     
        # Define any wallet
        wallet = LocalWallet.generate()
     
        # Network configuration
        ledger = LedgerClient(NetworkConfig.latest_stable_testnet())
     
        # Add tokens to wallet
        faucet_api = FaucetApi(NetworkConfig.latest_stable_testnet())
        faucet_api.get_wealth(wallet.address())
     
        # Define cw20, pair and liquidity token contracts
        token_contract_address = (
            "fetch1qr8ysysnfxmqzu7cu7cq7dsq5g2r0kvkg5e2wl2fnlkqss60hcjsxtljxl"
        )
        pair_contract_address = (
            "fetch1vgnx2d46uvyxrg9pc5mktkcvkp4uflyp3j86v68pq4jxdc8j4y0s6ulf2a"
        )
        liq_token_contract_address = (
            "fetch1alzhf9yhghud3qhucdjs895f3aek2egfq44qm0mfvahkv4jukx4qd0ltxx"
        )
     
        token_contract = LedgerContract(
            path=None, client=ledger, address=token_contract_address
        )
        pair_contract = LedgerContract(
            path=None, client=ledger, address=pair_contract_address
        )
        liq_token_contract = LedgerContract(
            path=None, client=ledger, address=liq_token_contract_address
        )
     
        print("Pool (initial state): ")
        print(pair_contract.query({"pool": {}}), "\n")
     
        # Swap atestfet for CW20 tokens
        swap_amount = str(args.swap_amount)
        native_denom = "atestfet"
     
        tx = pair_contract.execute(
            {
                "swap": {
                    "offer_asset": {
                        "info": {"native_token": {"denom": native_denom}},
                        "amount": swap_amount,
                    }
                }
            },
            sender=wallet,
            funds=swap_amount + native_denom,
        )
     
        print(f"Swapping {swap_amount + native_denom} for CW20 Tokens...")
        tx.wait_to_complete()
     
        print("Pool (after swap): ")
        print(pair_contract.query({"pool": {}}), "\n")
     
        # To provide cw20 token to LP, increase your allowance first
        cw20_liquidity_amount = str(args.cw20_liquidity_amount)
        native_liquidity_amount = str(args.native_liquidity_amount)
     
        tx = token_contract.execute(
            {
                "increase_allowance": {
                    "spender": pair_contract_address,
                    "amount": cw20_liquidity_amount,
                    "expires": {"never": {}},
                }
            },
            wallet,
        )
     
        print("Increasing Allowance...")
        tx.wait_to_complete()
     
        # Provide Liquidity
        # Liquidity should be added so that the slippage tolerance parameter isn't exceeded
     
        tx = pair_contract.execute(
            {
                "provide_liquidity": {
                    "assets": [
                        {
                            "info": {"token": {"contract_addr": token_contract_address}},
                            "amount": cw20_liquidity_amount,
                        },
                        {
                            "info": {"native_token": {"denom": native_denom}},
                            "amount": native_liquidity_amount,
                        },
                    ],
                    "slippage_tolerance": "0.1",
                }
            },
            sender=wallet,
            funds=native_liquidity_amount + native_denom,
        )
     
        print(
            f"Providing {native_liquidity_amount + native_denom} and {cw20_liquidity_amount}CW20 tokens to Liquidity Pool..."
        )
        tx.wait_to_complete()
     
        print("Pool (after providing liquidity): ")
        print(pair_contract.query({"pool": {}}), "\n")
     
        # Withdraw Liquidity
        LP_token_balance = liq_token_contract.query(
            {"balance": {"address": str(wallet.address())}}
        )["balance"]
     
        withdraw_msg = '{"withdraw_liquidity": {}}'
        withdraw_msg_bytes = withdraw_msg.encode("ascii")
        withdraw_msg_base64 = base64.b64encode(withdraw_msg_bytes)
        msg = str(withdraw_msg_base64)[2:-1]
     
        tx = liq_token_contract.execute(
            {
                "send": {
                    "contract": pair_contract_address,
                    "amount": LP_token_balance,
                    "msg": msg,
                }
            },
            sender=wallet,
        )
     
        print(f"Withdrawing {LP_token_balance} from pool's total share...")
        tx.wait_to_complete()
     
        print("Pool (after withdrawing liquidity): ")
        print(pair_contract.query({"pool": {}}), "\n")
     
     
    if __name__ == "__main__":
        main()</content>
</page>

<page>
  <title>Wallet top-up</title>
  <url>https://network.fetch.ai/docs/guides/cosmpy/use-cases/wallet-top-up</url>
  <content>Introduction[](#introduction)
-----------------------------

The following guide is about how to top-up a wallet using the CosmPy library. To top-up a wallet, you need to create different wallets. In particular, if you are performing multiple transactions from a certain `task_wallet`, you can set an algorithm to keep that wallet address topped-up. For this use case, we will use three different wallets: `wallet`, `authz_wallet`, and `task_wallet`. `wallet` will be the main wallet address that we don’t want to give full access to, therefore we will authorize `authz_wallet` to send a certain amount of tokens from `wallet` to `task_wallet` every time `task_wallet` balance falls below a certain `minimum_balance` threshold. This way, `task_wallet` can keep performing transactions using the main wallet’s tokens by being topped-up by `authz_wallet`.

Walk-through[](#walk-through)
-----------------------------

1.  Let’s start by creating a Python script for this:
    
2.  First of all, we need to import the necessary classes:
    

     
    import argparse
    from datetime import datetime, timedelta
     
    from google.protobuf import any_pb2, timestamp_pb2
     
    from cosmpy.aerial.client import LedgerClient, NetworkConfig
    from cosmpy.aerial.client.utils import prepare_and_broadcast_basic_transaction
    from cosmpy.aerial.faucet import FaucetApi
    from cosmpy.aerial.tx import Transaction
    from cosmpy.aerial.wallet import LocalWallet
    from cosmpy.protos.cosmos.authz.v1beta1.authz_pb2 import Grant
    from cosmpy.protos.cosmos.authz.v1beta1.tx_pb2 import MsgGrant
    from cosmpy.protos.cosmos.bank.v1beta1.authz_pb2 import SendAuthorization
    from cosmpy.protos.cosmos.base.v1beta1.coin_pb2 import Coin
     

3.  We then proceed and define a `_parse_commandline()` function:

     
    def _parse_commandline():
        parser = argparse.ArgumentParser()
        parser.add_argument(
            "authz_address",
            help="address that will be granted authorization to send tokens from wallet",
        )
        parser.add_argument(
            "total_authz_time",
            type=int,
            nargs="?",
            default=10,
            help="authorization time for authz_address in minutes",
        )
        parser.add_argument(
            "spend_limit",
            type=int,
            nargs="?",
            default=1000000000000000000,
            help="maximum tokens that authz_wallet will be able to spend from wallet",
        )
     
        return parser.parse_args()
     

The `_parse_commandline()` function is using the `argparse` module to define a command-line interface for this script. It expects and processes three command-line arguments:

1.  `authz_address`: this is a required argument. It expects the user to provide an address that will be granted authorization to send tokens from a wallet.
    
2.  `total_authz_time`: this is an optional argument. If provided, it should be an integer representing the authorization time for the `authz_address` in minutes. If not provided, it defaults to `10` minutes.
    
3.  `spend_limit`: this is another optional argument. If provided, it should be an integer representing the maximum tokens that the `authz_wallet` will be able to spend from the wallet. If not provided, it defaults to `1000000000000000000`.
    

The `help` parameter provides a description of what each argument is for, which can be helpful for users who might not be familiar with the script. After defining these arguments, the function uses `parser.parse_args()` to process the command-line arguments provided by the user and return them as an object containing the values provided for `authz_address`, `total_authz_time`, and `spend_limit`.

4.  We can then define our `main()` function:

     
    def main():
        """Run main."""
        args = _parse_commandline()
     
        wallet = LocalWallet.generate()
     
        authz_address = args.authz_address
     
        ledger = LedgerClient(NetworkConfig.fetchai_stable_testnet())
        faucet_api = FaucetApi(NetworkConfig.fetchai_stable_testnet())
     
        total_authz_time = args.total_authz_time
        wallet_balance = ledger.query_bank_balance(wallet.address())
     
        amount = args.spend_limit
     
        while wallet_balance < (amount):
            print("Providing wealth to wallet...")
            faucet_api.get_wealth(wallet.address())
            wallet_balance = ledger.query_bank_balance(wallet.address())
     
        spend_amount = Coin(amount=str(amount), denom="atestfet")
     
        # Authorize authz_wallet to send tokens from wallet
        authz_any = any_pb2.Any()
        authz_any.Pack(
            SendAuthorization(spend_limit=[spend_amount]),
            "",
        )
     
        expiry = timestamp_pb2.Timestamp()
        expiry.FromDatetime(datetime.now() + timedelta(seconds=total_authz_time * 60))
        grant = Grant(authorization=authz_any, expiration=expiry)
     
        msg = MsgGrant(
            granter=str(wallet.address()),
            grantee=authz_address,
            grant=grant,
        )
     
        tx = Transaction()
        tx.add_message(msg)
     
        tx = prepare_and_broadcast_basic_transaction(ledger, tx, wallet)
        tx.wait_to_complete()
     
     
    if __name__ == "__main__":
        main()
     

In the first line we define a variable `args` using `_parse_commandline()` function defined previously to retrieve the command-line arguments `authz_address`, `total_authz_time`, and `spend_limit`. The values are stored in the `args` variable. We then generate a new wallet using the `generate()` method of the `LocalWallet` class, and then set the `authz_address` variable to retrieve the `authz_address` from the command-line arguments previously defined. This is the address that will be granted authorization to send tokens from the wallet. We then initialize a `ledger` object using the `LedgerClient` class and configure it to connect to the Fetch.ai stable testnet. We also initialize a `faucet_api` object using the `FaucetApi` class to provide access to a faucet API on the Fetch.ai stable testnet.

`total_authz_time` retrieves the total authorization time (in minutes) from the command-line arguments. We proceed by checking the balance of the wallet by querying the ledger, using the `query_bank_balance()` method. We can then define a loop that continues until the wallet balance is greater than the specified spend amount (`amount`). Within the loop, it requests additional tokens from the faucet using `faucet_api.get_wealth()` and updates the wallet balance.

Below, we define the `spend_amount` variable using a Coin object representing the spend amount. In this case, it’s specified in the “atestfet” denomination. We then constructs an authorization object (`authz_any`) using `SendAuthorization`. It sets an expiration time for the authorization, and creates an instance of `MsgGrant` message type, specifying the `granter` (the wallet’s address), `grantee` (the `authz_address`), and the `grant` (the authorization object). A new transaction (`tx`) is finally created, and `msg` is added to it. The transaction is then prepared and broadcasted using `prepare_and_broadcast_basic_transaction()`. Finally, the script waits for the transaction to complete.

5.  Save the script.

The overall script should be as follows.

     
    import argparse
    from datetime import datetime, timedelta
     
    from google.protobuf import any_pb2, timestamp_pb2
     
    from cosmpy.aerial.client import LedgerClient, NetworkConfig
    from cosmpy.aerial.client.utils import prepare_and_broadcast_basic_transaction
    from cosmpy.aerial.faucet import FaucetApi
    from cosmpy.aerial.tx import Transaction
    from cosmpy.aerial.wallet import LocalWallet
    from cosmpy.protos.cosmos.authz.v1beta1.authz_pb2 import Grant
    from cosmpy.protos.cosmos.authz.v1beta1.tx_pb2 import MsgGrant
    from cosmpy.protos.cosmos.bank.v1beta1.authz_pb2 import SendAuthorization
    from cosmpy.protos.cosmos.base.v1beta1.coin_pb2 import Coin
     
     
    def _parse_commandline():
        parser = argparse.ArgumentParser()
        parser.add_argument(
            "authz_address",
            help="address that will be granted authorization to send tokens from wallet",
        )
        parser.add_argument(
            "total_authz_time",
            type=int,
            nargs="?",
            default=10,
            help="authorization time for authz_address in minutes",
        )
        parser.add_argument(
            "spend_limit",
            type=int,
            nargs="?",
            default=1000000000000000000,
            help="maximum tokens that authz_wallet will be able to spend from wallet",
        )
     
        return parser.parse_args()
     
     
    def main():
        """Run main."""
        args = _parse_commandline()
     
        wallet = LocalWallet.generate()
     
        authz_address = args.authz_address
     
        ledger = LedgerClient(NetworkConfig.fetchai_stable_testnet())
        faucet_api = FaucetApi(NetworkConfig.fetchai_stable_testnet())
     
        total_authz_time = args.total_authz_time
        wallet_balance = ledger.query_bank_balance(wallet.address())
     
        amount = args.spend_limit
     
        while wallet_balance < (amount):
            print("Providing wealth to wallet...")
            faucet_api.get_wealth(wallet.address())
            wallet_balance = ledger.query_bank_balance(wallet.address())
     
        spend_amount = Coin(amount=str(amount), denom="atestfet")
     
        # Authorize authz_wallet to send tokens from wallet
        authz_any = any_pb2.Any()
        authz_any.Pack(
            SendAuthorization(spend_limit=[spend_amount]),
            "",
        )
     
        expiry = timestamp_pb2.Timestamp()
        expiry.FromDatetime(datetime.now() + timedelta(seconds=total_authz_time * 60))
        grant = Grant(authorization=authz_any, expiration=expiry)
     
        msg = MsgGrant(
            granter=str(wallet.address()),
            grantee=authz_address,
            grant=grant,
        )
     
        tx = Transaction()
        tx.add_message(msg)
     
        tx = prepare_and_broadcast_basic_transaction(ledger, tx, wallet)
        tx.wait_to_complete()
     
     
    if __name__ == "__main__":
        main()
     

### Aerial top-up[](#aerial-top-up)

We are now ready to write a Python script which automates the process of topping-up the designated wallet (`task_wallet`) from the main wallet (`wallet`) after authorization from `authz_wallet`, whenever the balance of `task_wallet` falls below a certain threshold (`minimum_balance`).

1.  Let’s create a Python script for this and name it:
    
2.  Let’s then import the needed modules such as `argparse` for command-line argument parsing and modules from the `cosmpy` library for blockchain interaction:
    

     
    import argparse
    import time
     
    from google.protobuf import any_pb2
     
    from cosmpy.aerial.client import LedgerClient, NetworkConfig
    from cosmpy.aerial.client.utils import prepare_and_broadcast_basic_transaction
    from cosmpy.aerial.faucet import FaucetApi
    from cosmpy.aerial.tx import Transaction
    from cosmpy.aerial.wallet import LocalWallet
    from cosmpy.protos.cosmos.authz.v1beta1.tx_pb2 import MsgExec
    from cosmpy.protos.cosmos.bank.v1beta1.tx_pb2 import MsgSend
    from cosmpy.protos.cosmos.base.v1beta1.coin_pb2 import Coin
     

3.  We then define a `_parse_commandline()` function that sets up command-line arguments:

     
    def _parse_commandline():
        parser = argparse.ArgumentParser()
        parser.add_argument("wallet_address", help="main wallet address")
        parser.add_argument(
            "task_wallet_address", help="wallet address that will perform transactions"
        )
        parser.add_argument(
            "top_up_amount",
            type=int,
            nargs="?",
            default=10000000000000000,
            help="top-up amount from wallet address to task_wallet address",
        )
        parser.add_argument(
            "minimum_balance",
            type=int,
            nargs="?",
            default=1000000000000000,
            help="minimum task_wallet address balance that will trigger top-up",
        )
        parser.add_argument(
            "interval_time",
            type=int,
            nargs="?",
            default=5,
            help="interval time in seconds to query task_wallet's balance",
        )
     
        return parser.parse_args()
     

Above we defined different arguments including the addresses of the main wallet (`wallet_address`) and the task wallet (`task_wallet_address`), the top-up amount from `wallet_address` to `task_wallet_address` (`top_up_amount`), the minimum balance for `task_wallet_address` (`minimum_balance`), and the interval time in seconds to query `task_wallet_address`’s balance (`interval_time`).

After these arguments are defined, the function uses `parser.parse_args()` to process the command-line arguments provided by the user. The values are then returned as an object, where each attribute corresponds to the name of the argument. This allows the script to access and utilize these values during execution.

4.  We are now ready to define our `main()` function:

     
    def main():
        """Run main."""
        ledger = LedgerClient(NetworkConfig.fetchai_stable_testnet())
        args = _parse_commandline()
     
        wallet_address = args.wallet_address
     
        task_wallet_address = args.task_wallet_address
     
        # Use aerial_authz.py to authorize authz_wallet address to send tokens from wallet
        authz_wallet = LocalWallet.generate()
        faucet_api = FaucetApi(NetworkConfig.fetchai_stable_testnet())
     
        wallet_balance = ledger.query_bank_balance(authz_wallet.address())
     
        while wallet_balance < (10 ** 18):
            print("Providing wealth to wallet...")
            faucet_api.get_wealth(authz_wallet.address())
            wallet_balance = ledger.query_bank_balance(authz_wallet.address())
     
        ledger = LedgerClient(NetworkConfig.latest_stable_testnet())
     
        # Top-up amount
        amount = args.top_up_amount
        top_up_amount = Coin(amount=str(amount), denom="atestfet")
     
        # Minimum balance for task_wallet
        minimum_balance = args.minimum_balance
     
        # Interval to query task_wallet's balance
        interval_time = args.interval_time
     
        while True:
     
            wallet_balance = ledger.query_bank_balance(wallet_address)
     
            if wallet_balance < amount:
                print("Wallet doesn't have enough balance to top-up task_wallet")
                break
     
            task_wallet_balance = ledger.query_bank_balance(task_wallet_address)
     
            if task_wallet_balance < minimum_balance:
                print("topping up task wallet")
                # Top-up task_wallet
                msg = any_pb2.Any()
                msg.Pack(
                    MsgSend(
                        from_address=wallet_address,
                        to_address=task_wallet_address,
                        amount=[top_up_amount],
                    ),
                    "",
                )
     
                tx = Transaction()
                tx.add_message(MsgExec(grantee=str(authz_wallet.address()), msgs=[msg]))
     
                tx = prepare_and_broadcast_basic_transaction(ledger, tx, authz_wallet)
                tx.wait_to_complete()
     
            time.sleep(interval_time)
     
     
    if __name__ == "__main__":
        main()
     

Here we defined the `main()` function which orchestrates all of the operations. It first initializes a `ledger` object to interact with the blockchain using the `LedgerClient()` class. It then parses command-line arguments using `_parse_commandline()` and stores them in the `args` variable. The function then retrieves wallet addresses for `wallet` and `task_wallet` from `args`. The function then uses `aerial_authz.py` script previously created above to authorize `authz_wallet` address to send tokens from `wallet`. If the balance of `authz_wallet` is below `10**18`, it uses a faucet API to provide wealth to the wallet until it reaches this threshold. Within the script, we then re-initialize the ledger object with the latest stable testnet configuration. We then proceed to set the top-up amount, the minimum balance, and interval timer thresholds from `args`. The script then enters an infinite loop (`while True`) in which it queries the balance of the main `wallet`. Checks if the main wallet has enough balance to top-up `task_wallet`. Queries the balance of `task_wallet`: if its balance falls below the specified minimum, it initiates a top-up by first creating a message to send tokens from `wallet_address` to `task_wallet_address`, then constructing a transaction (`tx`) with the authorization and message. It then prepares, broadcasts the transaction, and waits for a specified interval before repeating the process.

5.  Save the script.

The overall script should be as follows:

     
    import argparse
    import time
     
    from google.protobuf import any_pb2
     
    from cosmpy.aerial.client import LedgerClient, NetworkConfig
    from cosmpy.aerial.client.utils import prepare_and_broadcast_basic_transaction
    from cosmpy.aerial.faucet import FaucetApi
    from cosmpy.aerial.tx import Transaction
    from cosmpy.aerial.wallet import LocalWallet
    from cosmpy.protos.cosmos.authz.v1beta1.tx_pb2 import MsgExec
    from cosmpy.protos.cosmos.bank.v1beta1.tx_pb2 import MsgSend
    from cosmpy.protos.cosmos.base.v1beta1.coin_pb2 import Coin
     
     
    def _parse_commandline():
        parser = argparse.ArgumentParser()
        parser.add_argument("wallet_address", help="main wallet address")
        parser.add_argument(
            "task_wallet_address", help="wallet address that will perform transactions"
        )
        parser.add_argument(
            "top_up_amount",
            type=int,
            nargs="?",
            default=10000000000000000,
            help="top-up amount from wallet address to task_wallet address",
        )
        parser.add_argument(
            "minimum_balance",
            type=int,
            nargs="?",
            default=1000000000000000,
            help="minimum task_wallet address balance that will trigger top-up",
        )
        parser.add_argument(
            "interval_time",
            type=int,
            nargs="?",
            default=5,
            help="interval time in seconds to query task_wallet's balance",
        )
     
        return parser.parse_args()
     
     
    def main():
        """Run main."""
        ledger = LedgerClient(NetworkConfig.fetchai_stable_testnet())
        args = _parse_commandline()
     
        wallet_address = args.wallet_address
     
        task_wallet_address = args.task_wallet_address
     
        # Use aerial_authz.py to authorize authz_wallet address to send tokens from wallet
        authz_wallet = LocalWallet.generate()
        faucet_api = FaucetApi(NetworkConfig.fetchai_stable_testnet())
     
        wallet_balance = ledger.query_bank_balance(authz_wallet.address())
     
        while wallet_balance < (10 ** 18):
            print("Providing wealth to wallet...")
            faucet_api.get_wealth(authz_wallet.address())
            wallet_balance = ledger.query_bank_balance(authz_wallet.address())
     
        ledger = LedgerClient(NetworkConfig.latest_stable_testnet())
     
        # Top-up amount
        amount = args.top_up_amount
        top_up_amount = Coin(amount=str(amount), denom="atestfet")
     
        # Minimum balance for task_wallet
        minimum_balance = args.minimum_balance
     
        # Interval to query task_wallet's balance
        interval_time = args.interval_time
     
        while True:
     
            wallet_balance = ledger.query_bank_balance(wallet_address)
     
            if wallet_balance < amount:
                print("Wallet doesn't have enough balance to top-up task_wallet")
                break
     
            task_wallet_balance = ledger.query_bank_balance(task_wallet_address)
     
            if task_wallet_balance < minimum_balance:
                print("topping up task wallet")
                # Top-up task_wallet
                msg = any_pb2.Any()
                msg.Pack(
                    MsgSend(
                        from_address=wallet_address,
                        to_address=task_wallet_address,
                        amount=[top_up_amount],
                    ),
                    "",
                )
     
                tx = Transaction()
                tx.add_message(MsgExec(grantee=str(authz_wallet.address()), msgs=[msg]))
     
                tx = prepare_and_broadcast_basic_transaction(ledger, tx, authz_wallet)
                tx.wait_to_complete()
     
            time.sleep(interval_time)
     
     
    if __name__ == "__main__":
        main()</content>
</page>

<page>
  <title>Swap automation</title>
  <url>https://network.fetch.ai/docs/guides/cosmpy/use-cases/swap-automation</url>
  <content>Introduction[](#introduction)
-----------------------------

The following guide demonstrates an automated swapping strategy for a liquidity pool on the Fetch.ai network. It interacts with a liquidity pool contract and performs swaps between two different tokens (atestfet and CW20 tokens) based on specified price thresholds. A mean-reversion strategy expects the prices to return to _normal_ levels or a certain moving average following a temporary price spike. We can construct a similar strategy using the Liquidity Pool, where we will set upper and lower bound prices that will trigger a sell and a buy transaction respectively. If the behavior of the LP prices works as expected always returning to a certain moving average, we could profit by selling high and buying low. We will do this by swapping atestfet and cw20 with the Liquidity Pool, we refer to a sell transaction when we sell atestfet and get CW20 tokens, a buy transaction would be exactly the opposite.

Walk-through[](#walk-through)
-----------------------------

1.  Let’s start by creating a Python script and name it:
    
        echo. > aerial_swap_automation.py
    
2.  Let’s then import the needed classes:
    

aerial\_swap\_automation.py

     
    import argparse
    from time import sleep
     
    from cosmpy.aerial.client import LedgerClient, NetworkConfig
    from cosmpy.aerial.contract import LedgerContract
    from cosmpy.aerial.faucet import FaucetApi
    from cosmpy.aerial.wallet import LocalWallet
     

3.  We then need to define a `swap_native_for_cw20()` function which performs a swap from native tokens (atestfet) to CW20 tokens within a liquidity pool:

aerial\_swap\_automation.py

     
    def swap_native_for_cw20(swap_amount, pair_contract, wallet):
        """
        Swap Native for cw20.
     
        :param swap_amount: swap amount
        :param pair_contract: pair contract address
        :param wallet: wallet address
     
        """
        tx = pair_contract.execute(
            {
                "swap": {
                    "offer_asset": {
                        "info": {"native_token": {"denom": "atestfet"}},
                        "amount": str(swap_amount),
                    }
                }
            },
            sender=wallet,
            funds=str(swap_amount) + "atestfet",
        )
        print("swapping native for cw20 tokens")
        tx.wait_to_complete()
     

Within the function, we defined the following parameters:

*   `swap_amount`: this parameter specifies the amount of native tokens to be swapped for CW20 tokens.
    
*   `pair_contract`: this parameter represents the contract address of the liquidity pool pair where the swap will occur.
    
*   `wallet`: this parameter represents the wallet address that will perform the swap.
    

The function constructs a transaction to execute the swap operation. The `execute()` method is called on the `pair_contract` with a dictionary specifying the `"swap"` operation. Inside the `"swap"` operation, the `offer_asset` field is set to the following:

*   `info`: this field specifies that the swap involves native tokens (`native_token`) with the denomination `"atestfet"`.
*   `amount`: this field specifies the amount of native tokens to be swapped, which is converted to a string.

The `sender` parameter is set to the `wallet` address, indicating that the wallet will initiate the swap. The `funds` parameter is set to a string representing the total amount of funds being used for the swap, which includes the `swap_amount` and `"atestfet"`. Finally, the function waits for the transaction to complete and prints a message indicating that native tokens are being swapped for CW20 tokens.

4.  We then need to define a `swap_cw20_for_native()` function which performs a swap from CW20 tokens to native tokens (atestfet) within a liquidity pool:

aerial\_swap\_automation.py

     
    def swap_cw20_for_native(swap_amount, pair_contract_address, token_contract, wallet):
        """
        Swap cw20 for native.
     
        :param swap_amount: swap amount
        :param pair_contract_address: pair contract address
        :param token_contract: token contract
        :param wallet: wallet address
     
        """
        tx = token_contract.execute(
            {
                "send": {
                    "contract": pair_contract_address,
                    "amount": str(swap_amount),
                    "msg": "eyJzd2FwIjp7fX0=",
                }
            },
            wallet,
        )
        print("swapping cw20 for native tokens")
        tx.wait_to_complete()
     

Within the function, we defined the following parameters:

*   `swap_amount`: this parameter specifies the amount of CW20 tokens to be swapped for native tokens.
*   `pair_contract_address`: this parameter represents the contract address of the liquidity pool pair where the swap will occur.
*   `token_contract`: this parameter represents the contract for the CW20 token.
*   `wallet`: This parameter represents the wallet address that will perform the swap.

The function constructs a transaction to execute the swap operation: the `execute()` method is called on the `token_contract` with a dictionary specifying the `"send"` operation. Inside this operation, the contract field is set to `pair_contract_address`, indicating that the CW20 tokens will be sent to the liquidity pool. The `amount` field is set to the `swap_amount`, which is converted to a string. The `msg` field is set to the base64 encoded message `"eyJzd2FwIjp7fX0="`, which likely contains additional instructions or parameters for the swap. The `wallet` address is specified as the sender of the transaction. Finally, the function waits for the transaction to complete and prints a message indicating that CW20 tokens are being swapped for native tokens.

5.  We now would need to proceed by defining a `_parse_commandline()` function:

aerial\_swap\_automation.py

     
    def _parse_commandline():
        """Commandline parser."""
        parser = argparse.ArgumentParser()
     
        parser.add_argument(
            "trading_wallet",
            type=int,
            nargs="?",
            default=1000000,
            help="initial atestfet balance to perform swaps using the liquidity pool",
        )
        parser.add_argument(
            "upper_bound",
            type=int,
            nargs="?",
            default=20.5,
            help="price upper bound that will trigger a swap from cw20 to native tokens",
        )
        parser.add_argument(
            "lower_bound",
            type=int,
            nargs="?",
            default=19.5,
            help="price lower bound that will trigger a swap from native to cw20 tokens",
        )
        parser.add_argument(
            "commission",
            type=int,
            nargs="?",
            default=0.003,
            help="LP commission, for terraswap the default is 0.3%",
        )
        parser.add_argument(
            "interval_time",
            type=int,
            nargs="?",
            default=5,
            help="interval time in seconds to query liquidity pool price",
        )
     
        return parser.parse_args()
     

This function is responsible for parsing command line arguments in the script. It uses the `argparse.ArgumentParser()` class to define and handle the expected command line arguments:

*   `trading_wallet`: this argument represents the initial balance of atestfet in the trading wallet. It’s an optional argument, and if not provided, it defaults to `1000000`.
*   `upper_bound`: this argument specifies the upper price threshold that will trigger a swap from cw20 to native tokens . If not provided, it defaults to `20.5`.
*   `lower_bound`: this argument sets the lower price threshold that will trigger a swap from native to cw20 tokens. It defaults to `19.5` if not provided.
*   `commission`: this argument defines the commission rate for the liquidity pool. The default is `0.003`, representing 0.3%.
*   `interval_time`: this argument determines the interval (in seconds) at which the script queries the liquidity pool price. If not provided, it defaults to `5` seconds.

The function then returns an object containing the parsed arguments. These arguments can be accessed later in the script to control the behavior of the swap automation.

6.  We are ready to write down our `main()` function:

aerial\_swap\_automation.py

     
    def main():
        """Run main."""
        args = _parse_commandline()
     
        # Define any wallet
        wallet = LocalWallet.generate()
     
        # Network configuration
        ledger = LedgerClient(NetworkConfig.latest_stable_testnet())
     
        # Add tokens to wallet
        faucet_api = FaucetApi(NetworkConfig.latest_stable_testnet())
     
        wallet_balance = ledger.query_bank_balance(wallet.address())
     
        while wallet_balance < (10 ** 18):
            print("Providing wealth to wallet...")
            faucet_api.get_wealth(wallet.address())
            wallet_balance = ledger.query_bank_balance(wallet.address())
     
        # Define cw20, pair and liquidity token contracts
        token_contract_address = (
            "fetch1qr8ysysnfxmqzu7cu7cq7dsq5g2r0kvkg5e2wl2fnlkqss60hcjsxtljxl"
        )
        pair_contract_address = (
            "fetch1vgnx2d46uvyxrg9pc5mktkcvkp4uflyp3j86v68pq4jxdc8j4y0s6ulf2a"
        )
     
        token_contract = LedgerContract(
            path=None, client=ledger, address=token_contract_address
        )
        pair_contract = LedgerContract(
            path=None, client=ledger, address=pair_contract_address
        )
     
        # tokens in trading wallet (currency will vary [atestfet,cw20] )
        currency = "atestfet"
        tokens = args.trading_wallet
     
        # Swap thresholds
        upper_bound = args.upper_bound
        lower_bound = args.lower_bound
     
        # LP commission
        commission = args.commission
     
        # Wait time
        interval = args.interval_time
     
        while True:
     
            # Query LP status
            pool = pair_contract.query({"pool": {}})
            native_amount = int(pool["assets"][1]["amount"])
            cw20_amount = int(pool["assets"][0]["amount"])
     
            if currency == "atestfet":
                # Calculate received cw20 tokens if atestfet tokens are given to LP
                tokens_out = round(
                    ((cw20_amount * tokens) / (native_amount + tokens)) * (1 - commission)
                )
     
                # Sell price of atestfet => give atestfet, get cw20
                sell_price = tokens / tokens_out
                print("atestfet sell price: ", sell_price)
                if sell_price <= lower_bound:
                    swap_native_for_cw20(tokens, pair_contract, wallet)
                    tokens = int(
                        token_contract.query(
                            {"balance": {"address": str(wallet.address())}}
                        )["balance"]
                    )
     
                    # Trading wallet currency changed to cw20
                    currency = "CW20"
            else:
                # Calculate received atestfet tokens if cw20 tokens are given to LP
                tokens_out = round(
                    ((native_amount * tokens) / (cw20_amount + tokens)) * (1 - commission)
                )
     
                # Buy price of atestfet => give cw20, get atestfet
                buy_price = tokens_out / tokens
                print("atestfet buy price: ", buy_price)
                if buy_price >= upper_bound:
                    swap_cw20_for_native(
                        tokens, pair_contract_address, token_contract, wallet
                    )
                    tokens = tokens_out
     
                    # Trading wallet currency changed to cw20
                    currency = "atestfet"
     
            sleep(interval)
     
     
    if __name__ == "__main__":
        main()
     

Within the `main()` function, the `_parse_commandline()` function is used to parse command line arguments. It sets various parameters such as the initial trading wallet balance, upper and lower price bounds for triggering swaps, liquidity pool commission, and interval time for querying the liquidity pool price, and all of these values are store in the `args` variable. After this, a new wallet is generated using the `generate()` method of the `LocalWallet` class, and network configuration is set up using the `LedgerClient()` class. Tokens are added to the wallet by using the Faucet API. This happens within a `while` loop which continues until the wallet balance reaches at least `10**18`. The wallet balance is retrieved using the `query_bank_balance()`. Afterwards, we need to define the addresses of the CW20, pair, and liquidity token contracts, as well as initialize various variables based on the command line arguments, including the initial wallet balance, `upper_bound` and `lower_bound` price bounds for swaps, LP commission rate, and the interval at which to check the liquidity pool price.

We then define a loop (`while True`), which:

*   Queries the liquidity pool status (`pair_contract.query({"pool": {}})`) to get the current amounts of native tokens (`atestfet`) and CW20 tokens.
*   Checks the current currency in the trading wallet (`currency`), which can be either native or CW20 tokens.
*   If the current `currency` is `atestfet`, it calculates the potential amount of CW20 tokens that would be received if native tokens were given to the liquidity pool. This is done based on the ratio of CW20 tokens to the total of native tokens and current wallet tokens, with a deduction for the LP commission. It calculates a `sell_price` as the ratio of the current wallet tokens to tokens swapped out.
*   If the sell price is lower than or equal to the specified `lower_bound`, it triggers the `swap_native_for_cw20()` function, which swaps atestfet tokens for CW20 tokens.
*   After the successful swap, it updates the tokens variable to the new balance of CW20 tokens and changes the currency to `"CW20"`.
*   If the current currency is `"CW20"`, it calculates the potential amount of atestfet tokens that would be received if CW20 tokens are given to the liquidity pool. This is done based on the ratio of native tokens to the total of CW20 tokens and current wallet tokens, with a deduction for the LP commission. It calculates a `buy_price` as the ratio of potential atestfet tokens to the current wallet tokens.
*   If the `buy_price` is higher than or equal to the specified `upper_bound`, it triggers the `swap_cw20_for_native()` function, which swaps CW20 tokens for atestfet tokens.
*   After the successful swap, it updates the tokens variable to the new balance of atestfet tokens and changes the currency to `"atestfet"`. The loop then waits for the specified `interval` before checking the liquidity pool status and performing the next iteration.

7.  Save the script.

The overall script should be as follows:

aerial\_swap\_automation.py

     
    import argparse
    from time import sleep
     
    from cosmpy.aerial.client import LedgerClient, NetworkConfig
    from cosmpy.aerial.contract import LedgerContract
    from cosmpy.aerial.faucet import FaucetApi
    from cosmpy.aerial.wallet import LocalWallet
     
     
    def swap_native_for_cw20(swap_amount, pair_contract, wallet):
        """
        Swap Native for cw20.
     
        :param swap_amount: swap amount
        :param pair_contract: pair contract address
        :param wallet: wallet address
     
        """
        tx = pair_contract.execute(
            {
                "swap": {
                    "offer_asset": {
                        "info": {"native_token": {"denom": "atestfet"}},
                        "amount": str(swap_amount),
                    }
                }
            },
            sender=wallet,
            funds=str(swap_amount) + "atestfet",
        )
        print("swapping native for cw20 tokens")
        tx.wait_to_complete()
     
     
    def swap_cw20_for_native(swap_amount, pair_contract_address, token_contract, wallet):
        """
        Swap cw20 for native.
     
        :param swap_amount: swap amount
        :param pair_contract_address: pair contract address
        :param token_contract: token contract
        :param wallet: wallet address
     
        """
        tx = token_contract.execute(
            {
                "send": {
                    "contract": pair_contract_address,
                    "amount": str(swap_amount),
                    "msg": "eyJzd2FwIjp7fX0=",
                }
            },
            wallet,
        )
        print("swapping cw20 for native tokens")
        tx.wait_to_complete()
     
     
    def _parse_commandline():
        """Commandline parser."""
        parser = argparse.ArgumentParser()
     
        parser.add_argument(
            "trading_wallet",
            type=int,
            nargs="?",
            default=1000000,
            help="initial atestfet balance to perform swaps using the liquidity pool",
        )
        parser.add_argument(
            "upper_bound",
            type=int,
            nargs="?",
            default=20.5,
            help="price upper bound that will trigger a swap from cw20 to native tokens",
        )
        parser.add_argument(
            "lower_bound",
            type=int,
            nargs="?",
            default=19.5,
            help="price lower bound that will trigger a swap from native to cw20 tokens",
        )
        parser.add_argument(
            "commission",
            type=int,
            nargs="?",
            default=0.003,
            help="LP commission, for terraswap the default is 0.3%",
        )
        parser.add_argument(
            "interval_time",
            type=int,
            nargs="?",
            default=5,
            help="interval time in seconds to query liquidity pool price",
        )
     
        return parser.parse_args()
     
     
    def main():
        """Run main."""
        args = _parse_commandline()
     
        # Define any wallet
        wallet = LocalWallet.generate()
     
        # Network configuration
        ledger = LedgerClient(NetworkConfig.latest_stable_testnet())
     
        # Add tokens to wallet
        faucet_api = FaucetApi(NetworkConfig.latest_stable_testnet())
     
        wallet_balance = ledger.query_bank_balance(wallet.address())
     
        while wallet_balance < (10 ** 18):
            print("Providing wealth to wallet...")
            faucet_api.get_wealth(wallet.address())
            wallet_balance = ledger.query_bank_balance(wallet.address())
     
        # Define cw20, pair and liquidity token contracts
        token_contract_address = (
            "fetch1qr8ysysnfxmqzu7cu7cq7dsq5g2r0kvkg5e2wl2fnlkqss60hcjsxtljxl"
        )
        pair_contract_address = (
            "fetch1vgnx2d46uvyxrg9pc5mktkcvkp4uflyp3j86v68pq4jxdc8j4y0s6ulf2a"
        )
     
        token_contract = LedgerContract(
            path=None, client=ledger, address=token_contract_address
        )
        pair_contract = LedgerContract(
            path=None, client=ledger, address=pair_contract_address
        )
     
        # tokens in trading wallet (currency will vary [atestfet,cw20] )
        currency = "atestfet"
        tokens = args.trading_wallet
     
        # Swap thresholds
        upper_bound = args.upper_bound
        lower_bound = args.lower_bound
     
        # LP commission
        commission = args.commission
     
        # Wait time
        interval = args.interval_time
     
        while True:
     
            # Query LP status
            pool = pair_contract.query({"pool": {}})
            native_amount = int(pool["assets"][1]["amount"])
            cw20_amount = int(pool["assets"][0]["amount"])
     
            if currency == "atestfet":
                # Calculate received cw20 tokens if atestfet tokens are given to LP
                tokens_out = round(
                    ((cw20_amount * tokens) / (native_amount + tokens)) * (1 - commission)
                )
     
                # Sell price of atestfet => give atestfet, get cw20
                sell_price = tokens / tokens_out
                print("atestfet sell price: ", sell_price)
                if sell_price <= lower_bound:
                    swap_native_for_cw20(tokens, pair_contract, wallet)
                    tokens = int(
                        token_contract.query(
                            {"balance": {"address": str(wallet.address())}}
                        )["balance"]
                    )
     
                    # Trading wallet currency changed to cw20
                    currency = "CW20"
            else:
                # Calculate received atestfet tokens if cw20 tokens are given to LP
                tokens_out = round(
                    ((native_amount * tokens) / (cw20_amount + tokens)) * (1 - commission)
                )
     
                # Buy price of atestfet => give cw20, get atestfet
                buy_price = tokens_out / tokens
                print("atestfet buy price: ", buy_price)
                if buy_price >= upper_bound:
                    swap_cw20_for_native(
                        tokens, pair_contract_address, token_contract, wallet
                    )
                    tokens = tokens_out
     
                    # Trading wallet currency changed to cw20
                    currency = "atestfet"
     
            sleep(interval)
     
     
    if __name__ == "__main__":
        main()</content>
</page>

<page>
  <title>Installation 🛠</title>
  <url>https://network.fetch.ai/docs/guides/jenesis/install</url>
  <content>Introduction[](#introduction)
-----------------------------

**Jenesis** is a command line tool for rapid contract and service development for the Fetch.ai blockchain network and other CosmWasm-enabled blockchains ecosystems.

System Requirements[](#system-requirements)
-------------------------------------------

If you want to correctly use Jenesis, installation requires:

*   **OS**: Linux, MacOS.
*   **Python**: 3.8 to 3.10.
*   **Docker**: 20.10.22 or higher recommended.
*   **Git**: any.

Installation[](#installation)
-----------------------------

You can install Jenesis via [PyPI](https://pypi.org/project/jenesis/) . Make sure you satisfy the system requirements above provided, then, simply run:

⚠️

This documentation is currently under construction, and the content may not be up-to-date.

Last updated on

May 14, 2025

[Registration and endpoints weighting](https://network.fetch.ai/docs/introduction/almanac/endpoints "Registration and endpoints weighting")</content>
</page>

<page>
  <title>Getting started</title>
  <url>https://network.fetch.ai/docs/guides/jenesis/getting-started</url>
  <content>There are multiple commands integrated into jenesis that allow you to perform a variety of tasks. A full list of these commands is provided below:

*   `new`
*   `init`
*   `add`
*   `update`
*   `attach`
*   `compile`
*   `keys`
*   `deploy`
*   `run`
*   `shell`
*   `network`

In the following section of this page, we will cover the first commands so to show you **how to create a new project** and **how to configure a network**.

For additional information, have a look at the [Keys](https://network.fetch.ai/docs/guides/jenesis/keys) documentation for information about managing keys using Jenesis and the Working with contracts section, which illustrates different contract related executable operations using Jenesis tools and commands.

**Let’s get started!**

Create a new project[](#create-a-new-project)
---------------------------------------------

You can create a new project using the `new` command as depicted below:

    jenesis new my_project [--profile my_profile] [--network network_name]

This will create a new directory called `my_project`. You can use `--profile` and `--network` optional arguments to provide additional arguments for profile and network desired for the project. Whenever these arguments are not used, these will be set to `testing` and `fetchai-testnet` respectively.

Inside this directory for your project, a `jenesis.toml` file will be created containing the following information:

    [project]
    name = "my_project"
    authors = [ "Alice Tyler <alice@mail.com>"]
    keyring_backend = "os"
     
    [profile.my_profile]
    default = true
     
    [profile.my_profile.network]
    name = "fetchai-testnet"
    chain_id = "dorado-1"
    fee_minimum_gas_price = 5000000000
    fee_denomination = "atestfet"
    staking_denomination = "atestfet"
    url = "grpc+https://grpc-dorado.fetch.ai"
    faucet_url = "https://faucet-dorado.fetch.ai"
    is_local = false
     
    [profile.my_profile.contracts]

The project’s `name` is the argument passed to the `new` command while the authors field is populated by querying the user’s GitHub username and email address. The profile’s network will be filled with the relevant configuration variables. The contracts field will remain empty until new contracts are added. This `my_profile` profile will be set as the default profile, this means that every time you use a jenesis command without specifying a profile, `my_profile` will be used.

An empty `contracts` folder will also be created inside `my_project` directory that will eventually contain all the information needed to compile and deploy the desired contracts.

The `init` command is similar to the `new`` command, but in this case, you will not need a project` name\` argument since **this command is intended to run inside an existing project directory**:

    jenesis init [--profile my_profile] [--network network_name]

This command will create the same files and folders inside your project directory as the ones described for the `new` command above.

If using a cargo workspace, you just need to navigate to the top level of your project and run the `init` command shown above. This will create the `jenesis.toml` configuration file inside your workspace including all the relevant information from existing contracts.

Configure a network[](#configure-a-network)
-------------------------------------------

**Jenesis will configure the project to run on the latest stable Fetch.ai testnet by default,**. Use `fetchai-mainnet` to configure for the Fetch.ai mainnet or directly edit the `jenesis.toml` file to configure for other networks.

If you want to test on a local node, you will need to pass the argument `--network fetchai-localnode` when creating a project:

    jenesis new my_project --network fetchai-localnode

or:

    jenesis init --network fetchai-localnode

The configuration can be found under the `network` heading in the `jenesis.toml` file and can be changed as desired:

    [profile.testing.network]
    name = "fetchai-localnode"
    chain_id = "localnode"
    fee_minimum_gas_price = 5000000000
    fee_denomination = "atestfet"
    staking_denomination = "atestfet"
    url = "grpc+http://127.0.0.1:9090/"
    is_local = true
    keep_running = false
    cli_binary = "fetchd"
    validator_key_name = "validator"
    mnemonic = "gap bomb bulk border original scare assault pelican resemble found laptop skin gesture height inflict clinic reject giggle hurdle bubble soldier hurt moon hint"
    password = "12345678"
    moniker = "test-node"
    genesis_accounts = [ "fetch1vas6cc9650z0s08230ytqjphgzl5tcq9crqhhu",]
    timeout_commit = "5s"
    debug_trace = true

In particular, **to fund some accounts for testing**, replace the `genesis_accounts` field with the addresses to be funded.

When running any of the commands `deploy`, `run`, `shell`, and `attach`, Jenesis will check for a currently running local node. If there is not one provided, a new one will be created in a docker container.

If you wish to **keep a local node running**, you need to set the `keep_running` parameter to `true`. Otherwise, nodes will be stopped after any of the command mentioned above finish running.

At any time, **you can start or stop a local node from running**, using the following commands:

    jenesis network start [--profile my_profile]

or:

    jenesis network stop [--profile my_profile]

You can also **view the logs from the local node**, by simply running:

    jenesis network logs [--profile my_profile]</content>
</page>

<page>
  <title>Keys</title>
  <url>https://network.fetch.ai/docs/guides/jenesis/keys</url>
  <content>You can use the `keys` command to either list all the locally available `keys` or show the address of a specific key. You can list all the `keys` available by simply running the following command:

On the other hand, you can look up the address for a specified key by running the `show` command and pass the `key` name as an argument:

If you wish to access other key functionalities, including _adding new keys_, _looking up an address_, and _recovering keys_, you can use the [Fetchd CLI - Managing Keys](https://network.fetch.ai/docs/guides/cli/keys) guide.

Last updated on

May 14, 2025

[Registration and endpoints weighting](https://network.fetch.ai/docs/introduction/almanac/endpoints "Registration and endpoints weighting")</content>
</page>

<page>
  <title>How to add profiles</title>
  <url>https://network.fetch.ai/docs/guides/jenesis/contracts/add-profiles</url>
  <content>Introduction[](#introduction)
-----------------------------

A contract **profile** is a contract configuration setting that defines various parameters related to a specific network or environment where a contract will be deployed and interacted with.

Walk-through[](#walk-through)
-----------------------------

You can add more profiles than the one specified using the `new` command, presented in [getting started](https://network.fetch.ai/docs/guides/jenesis/getting-started) , by running the following `add profile` command:

    jenesis add profile my_second_profile

By default, the profile’s network will be set to `fetchai-testnet`, but you can specify it using the `--network` optional argument. The following data will be added to the existing information in your `jenesis.toml` file:

    [profile.my_second_profile.network]
    name = "fetchai-testnet"
    chain_id = "dorado-1"
    fee_minimum_gas_price = 5000000000
    fee_denomination = "atestfet"
    staking_denomination = "atestfet"
    url = "grpc+https://grpc-dorado.fetch.ai"
    faucet_url = "https://faucet-dorado.fetch.ai"
    is_local = false
     
    [profile.my_second_profile.contracts]

At the moment, the available network configurations are `fetchai-testnet`, `fetchai-mainnet`, and `fetchai-localnode`, but Jenesis is easily configurable for other networks by directly editing the `jenesis.toml` file.

In the snippet above, a profile named `my_second_profile` is added with default settings for the `fetchai-testnet` network. This allows developers to easily switch between different network configurations when deploying or interacting with contracts.

Last updated on

May 14, 2025

[Registration and endpoints weighting](https://network.fetch.ai/docs/introduction/almanac/endpoints "Registration and endpoints weighting")</content>
</page>

<page>
  <title>How to add contract templates</title>
  <url>https://network.fetch.ai/docs/guides/jenesis/contracts/add-contracts</url>
  <content>Introduction[](#introduction)
-----------------------------

Once you have successfully [created your project](https://network.fetch.ai/docs/guides/jenesis/getting-started#create-a-new-project) , you can add **contract templates**.

A **contract template** is a pre-defined, reusable blueprint or pattern for creating a smart contract in a blockchain environment. It provides a structured starting point with predefined functionalities, variables, and logic that can be customized to suit specific use cases.

ℹ️

A contract template is a specific implementation that can be added to a project. These templates serve as a foundation for creating contracts by providing pre-configured settings, initial code, and common functionalities. They streamline the process of developing contracts by offering a structured starting point that developers can build upon. By using contract templates, developers can save time and effort in setting up the basic structure and functionalities of their contracts, allowing them to focus on customizing and implementing the specific features required for their use case.

Overview[](#overview)
---------------------

If you want to add a template to a contract, you first need to navigate into your project’s directory and run the following command:

    jenesis add contract <template> <contract_name>

You can find all the contract templates available in [Jenesis Templates](https://github.com/fetchai/jenesis-templates)  GitHub repository. As for an overview, the available templates are the following:

*   **starter**: a bare-bones contract that sets and increments a counter, [here](https://github.com/fetchai/jenesis-templates/tree/master/contracts/starter) .
    
*   **token**: a fungible token contract, [here](https://github.com/fetchai/jenesis-templates/tree/master/contracts/cw20-base) .
    
*   **proxy**: a basic proxy contract, [here](https://github.com/fetchai/jenesis-templates/tree/master/contracts/cw1-subkeys) 
    
*   **multisig**: a fixed multisig contract, [here](https://github.com/fetchai/jenesis-templates/tree/master/contracts/cw3-fixed-multisig) .
    
*   **nft**: a general token contract supporting nfts, [here](https://github.com/fetchai/jenesis-templates/tree/master/contracts/cw721-base) .
    
*   **oracle**: a contract storing a value to be requested for a fee, [here](https://github.com/fetchai/jenesis-templates/tree/master/contracts/oracle) .
    
*   **oracle-client**: a contract for requesting a value for a fee from a specified oracle contract, [here](https://github.com/fetchai/jenesis-templates/tree/master/contracts/oracle_client)  .
    

### Example: CW-20 basic template for fungible token contract[](#example-cw-20-basic-template-for-fungible-token-contract)

The **cw20-base** template is designed for creating CW-20 tokens on the Fetch.ai blockchain. CW-20 tokens are a standard interface for fungible tokens. This template provides a solid starting point for developers looking to create their own custom CW-20 tokens, complete with essential functionalities like transfers, approvals, and querying balances.

The steps needed to add the **cw20-base** template with the name `my_token` are provided below:

    jenesis add contract cw20-base my_token

If you need multiple deployments of the same contract, you can use the `--deployments` or `-d` flag to specify multiple deployments and name them:

    jenesis add contract <template> <contract_name> [--deployments <deployments>]

Jenesis will add the deployments to all profiles for the specified contract.

In the example below, `token_1` and `token_2` deployments have been added. This will allow you to deploy `my_token` contract with two different configurations. You can add as many deployments as we wish:

    jenesis add contract cw20-base my_token -d token_1 token_2

If no deployments are selected when adding a contract, the default deployment name will be equal to the contract name.

The `add contract` command will add a contract template to our jenesis project inside `contracts/my_token/` folder. It will also update the `jenesis.toml` configuration file with the contract information:

    [profile.testing.contracts.token_1]
    name = "token_1"
    contract = "my_token"
    network = "fetchai-testnet"
    deployer_key = ""
    init_funds = ""
     
    [profile.testing.contracts.token_2]
    name = "token_2"
    contract = "my_token"
    network = "fetchai-testnet"
    deployer_key = ""
    init_funds = ""
     
    [profile.testing.contracts.token_1.init]
     
    [profile.testing.contracts.token_2.init]

The `deployer_key` field can be manually specified. You can choose any private key locally available to deploy any specific contract. You can also leave this field empty since the `deploy` command has an optional argument to deploy all contracts inside a specified profile with the same key, overriding this `deployer_key` argument in the `jenesis.toml` file. Checkout the [deploy contracts](https://network.fetch.ai/docs/guides/jenesis/contracts/deploy-contracts) guide for more information.

Finally, the `init` section contains the parameters needed in the instantiation message for this contract to be deployed. The required parameters are taken from the schema file inside the `contracts` directory. Since this contract template doesn’t include a schema, it will be generated when [compiling](https://network.fetch.ai/docs/guides/jenesis/contracts/compile-contracts) the `my_token` contract loading the init fields to the `jenesis.toml` file. You will need to manually add the values for these parameters in their correct variable type, which are listed on the schema file. For this **my\_token** contract, you need to fill the `init` fields for each deployment after [compiling](https://network.fetch.ai/docs/guides/jenesis/contracts/compile-contracts).

Below, we can find an example for this:

    [profile.testing.contracts.token_1.init]
    decimals = 6
    name = "my_token_name"
    symbol = "SYMBOL"
    initial_balances = [{ address = "fetch1d25ap9danl4726uk2nt307y630v87h3h2vq6pl", amount =  "5000"}]
    
    [profile.testing.contracts.token_2.init]
    decimals = 6
    name = "my_token_name_2"
    symbol = "SYMBOL"
    initial_balances = [{ address = "fetch1d25ap9danl4726uk2nt307y630v87h3h2vq6pl", amount =  "2000"}]

If your contract requires nested instantiation messages, you may add fields following this structure:

    [profile.testing.contracts.example-nested-contract.init]
    price = {amount = 1000, denom = DLS}
    info = {performance = {max_speed = 200, unit = kph}, fuel = {consumption = 7, unit = kmpl}}

⚠️

Before editing the `jenesis.toml` configuration file with the desired `deployer_key` and `init` parameters, make sure to first [compile](https://network.fetch.ai/guides/fetch-network/jenesis/contracts/compile-contracts) your contract. All configuration parameters will restart every time a contract is compiled if the schema has changed

You can also add contracts manually by copying and pasting the contract directory from another project you may have. However, they would need to follow the same directory structure as the [starter](https://github.com/fetchai/jenesis-templates/tree/master/contracts/starter)  template.

When adding a contract manually, you need to update the `jenesis.toml` file with the contract information by running the following command:

The `update` command will automatically detect which contract is missing in the `jenesis.toml` configuration file by revising the contracts directory.

#### Add contract deployments[](#add-contract-deployments)

You can also add further deployments for a given contract by specifying the contract name and the deployment name.

If you want to add a third token called `token_3` using `my_token` contract, you can run:

    jenesis add deployment my_token token_3

This will automatically create another deployment entry called `token_3`.

#### Attach deployed contracts[](#attach-deployed-contracts)

If you add a contract into the project’s contract folder that has already been deployed in the network, you can attach the deployment to your project for future interaction using the `attach` command.

You can add a deployment to your project by running the following command:

    jenesis add contract cw20-base my_token -d token_1

Then, you would need to compile the contract:

You can also attach the contract. In this case, you will need to specify the deployment’s name and address. You can optionally specify the profile where you wish to insert the contract into. If this is not specified, the deployment will be attached to the default profile, which is the first profile created in our project, unless the `default` settings are manually changed:

    jenesis attach token_1 fetch18xs97q6h9zgh4sz730a42pp0dqa9sh4eef7eutfkv69q3v2y3x8s72pkua

This will add the relevant deployment information into a `jenesis.lock` file, and you will now be able to interact with `token_1` using [contract interactions](https://network.fetch.ai/docs/guides/jenesis/contracts/contracts-interaction).</content>
</page>

<page>
  <title>How to compile contracts</title>
  <url>https://network.fetch.ai/docs/guides/jenesis/contracts/compile-contracts</url>
  <content>You can compile your contracts by running the following command inside your project’s directory:

    jenesis compile [--optimize] [--rebuild] [--no-log]

This will compile all packages in your project’s contracts directory and output the wasm code under the artifacts’ directory.

If you are using a cargo workspace, jenesis will automatically detect this and the compiled contracts will appear in the `contracts/artifacts/`. Otherwise, they will go to the `artifacts` directory under the individual contracts.

The contracts are simply compiled and not optimized by default. For an **optimized build**, use the flag `--optimize` or `-o`.

In case you need to **force a rebuild**, use the flag `--rebuild` or `-r`. To suppress contract compilation logs, use the flag `--no-log`.

In case of **compilation failure**, the logs will show by default.

ℹ️

`jenesis compile` requires that docker to be running and configured with permissions for your user.

Last updated on

May 14, 2025

[Registration and endpoints weighting](https://network.fetch.ai/docs/introduction/almanac/endpoints "Registration and endpoints weighting")</content>
</page>

<page>
  <title>How to deploy contracts</title>
  <url>https://network.fetch.ai/docs/guides/jenesis/contracts/deploy-contracts</url>
  <content>Once you have successfully compiled your contracts, you need to make sure to fill out the necessary instantiation message information under the `init` field in the `jenesis.toml` file.

ℹ️

`jenesis deploy` currently requires that each contract’s directory name matches the `.wasm` file name under the `artifacts` directory\*\*.

You can **deploy all the contracts inside a profile**, by following one of these two options:

1.  You can fill the `deployer_key` field for each contract inside the `jenesis.toml` file (keys can be different for each contract) and run the following command:
    
        jenesis deploy [--profile profile_name]
    
    Each contract inside the specified profile will be deployed with the specified key.
    
2.  You can simply specify a certain key as an argument of the deploy command:
    
        jenesis deploy key_name [--profile profile_name]
    
    The `deployer_key` field will be ignored in this case and all contracts inside the specified profile will be deployed using the key `key_name`.
    

After running either of the commands mentioned above, all the deployment information will be saved in the `jenesis.lock` file inside your project’s directory and depicted as follows:

    [profile.testing.my_first_contract]
    checksum = "ecf640a7512be3777c72ec42aff01fdb22897b71953011af3c41ee5dbf3d3bc5"
    digest = "be4a4bdfeb4ed8f504c7b7ac84e31ad3876627398a6586b49cac586633af8b85"
    address = "fetch16l239ggyr4z7pvsxec0ervlyw03mn6pz62l9ss6la94cf06awv0q36cq7u"
    code_id = 2594

Deploy contracts depending on other deployments[](#deploy-contracts-depending-on-other-deployments)
---------------------------------------------------------------------------------------------------

You can point to other contract addresses in any contract’s instantiation message if required.

For instance, if you have contracts `A`, `B`, and `C` within our project, but contract `A` requires contract’s `B` deployment address in its instantiation message and contract `B` requires contract’s `C` deployment address, these will need to be deployed in the following order: `C`, `B`, `A`.

In order to provide this information to `Jenesis` you will need to specify where exactly these contract addresses need to be inserted inside the instantiation messages. You can do this by writing the `$` symbol followed by the contract name in the corresponding field in the init parameters:

    [profile.testing.contracts.A.init]
    name = "A"
    token_contract_address = "$B"
     
    [profile.testing.contracts.B.init]
    token_name = "my_token"
    liquidity_contract_address = "$C"
     
    [profile.testing.contracts.C.init]
    count = 5

Finally, `Jenesis` will detect this information and deploy the contracts in the correct order: `C`, `B`, `A`.

Last updated on

May 14, 2025

[Registration and endpoints weighting](https://network.fetch.ai/docs/introduction/almanac/endpoints "Registration and endpoints weighting")</content>
</page>

<page>
  <title>Contract Interaction</title>
  <url>https://network.fetch.ai/docs/guides/jenesis/contracts/contract-interaction</url>
  <content>Introduction[](#introduction)
-----------------------------

**Contract interactions**, in blockchains networks, refers to the process of communicating with deployed smart contracts. This involves querying contract information or executing specific functions defined within the contract. Interactions can include tasks ranging from checking balances to transferring tokens, and so on.

Profiles provide network and contract configurations, while dynamic methods simplify common tasks. Scripts automate interactions for programmatic tasks. This interaction is vital for utilizing decentralized applications and services offered by smart contracts on the blockchain.

Start an interaction[](#start-an-interaction)
---------------------------------------------

You can interact with your project’s contracts by using the `shell` or `run` commands.

### Getting started[](#getting-started)

You can reproduce the examples provided here, by initially adding and compiling a basic [starter](https://github.com/fetchai/jenesis-templates/tree/master/contracts/starter)  contract and a [cw-20 token contract](https://github.com/fetchai/jenesis-templates/tree/master/contracts/cw20-base)  to your project with the following commands:

    jenesis add contract starter my_first_contract -d deployment_1
    jenesis add contract cw20-base my_token -d token_1
    jenesis compile

For more information on contract template examples, visit [Jenesis Templates](https://github.com/fetchai/jenesis-templates) .

### Interactive shell[](#interactive-shell)

You can open a shell within which you can easily start an interaction with your contracts, by simply running:

If a profile is not selected, the default profile will be selected automatically. You can specify any profile using the `--profile` optional argument:

    jenesis shell --profile my_profile

You will observe the following text indicating the available contracts in your project:

    Network: fetchai-testnet
    Detecting contracts...
    C deployment_1
    C token_1
    Detecting contracts...complete

ℹ️

`jenesis shell` currently requires that contract names use accepted python variable names. For example, using `token-1` instead of `token_1` will generate an error when trying to interact with it.\*\*

In this case, we can see that `deployment_1` and `token_1` deployments are available for this project. If these contracts have been already deployed, you can directly interact with them by performing contract queries and executions, such as:

    >>> deployment_1.query(args = {'msg_name': {...}}
    >>> deployment_1.execute(args = {'msg_name': {...}}

A ledger client (`ledger`) and your locally stored wallet keys will also be available in the shell. For example, if you have a local key named `alice`, you will find this under `wallets['alice']` and you can query the balance as follows:

    >>> ledger.query_bank_balance(wallets['alice'])
    10000000000000000000

If the ledger is a testnet with a faucet URL, you can get funds using the `faucet`:

    >>> faucet.get_wealth(wallets['alice'])

### Dynamic methods[](#dynamic-methods)

Jenesis also attaches the contract query, execution and deploy messages as dynamic methods.

For instance, the following query:

    >>> token_1.query({"balance": {"address": str(wallet.address())}}))

can also be run as follows:

    >>> token_1.balance(address=str(wallet.address()))
    {'balance': '4000'}

Similarly, instead of using `token_1.execute...`, a transfer can be executed with the following:

    >>> token_1.transfer(amount='1000', recipient=str(wallet2.address()), sender=wallet)

Additionally, Jenesis has an autocompletion helper for query, execution and deployment arguments. It will show automatically when typing in the shell.

We will now show an example assuming that `token_1` deployment contract has only been compiled and not yet deployed, going through _deployment_, _execution_, and _querying_ using dynamic methods.

For this example, we will first generate two wallets. We provide wealth to the sender wallet in atestfet so it can pay for transaction fees:

    >>> wallet = LocalWallet.generate()
    >>> wallet2 = LocalWallet.generate()
    >>> faucet.get_wealth(wallet)

We can then proceed to deploy `my_token` contract using `token_1` deployment configuration. We define the arguments for the CW-20 token: `name`, `symbol`, `decimal`, and the `address` that will be funded with these CW-20 tokens. In this case, we will fund wallet’s address with 5000 tokens:

    >>> token_1.deploy(name="Crab Coin", symbol="CRAB", decimals=6, initial_balances=[{ "address": str(wallet.address()), "amount" : "5000"}], sender=wallet)

We can **query wallet balance** to make sure it has been funded with cw20 tokens. Run the following:

    >>> token_1.balance(address=str(wallet.address()))
    {'balance': '5000'}

We can now execute a CW-20 token **transfer** of 1000 tokens from wallet to wallet2:

    >>> token_1.transfer(amount='1000', recipient=str(wallet2.address()), sender=wallet)

Finally, we **query both wallets’ balance**:

    >>> token_1.balance(address=str(wallet.address()))
    {'balance': '4000'}
    >>> token_1.balance(address=str(wallet2.address()))
    {'balance': '1000'}

We can observe that _wallet has sent 1000 tokens to wallet2_.

### Executing scripts[](#executing-scripts)

You can also assemble the above commands into a script that is executable by the `run` command, in the following way:

    from cosmpy.aerial.wallet import LocalWallet
     
    wallet = LocalWallet.generate()
    faucet.get_wealth(wallet.address())
    wallet2 = LocalWallet.generate()
     
    token_1.deploy(name="Crab Coin", symbol="CRAB", decimals=6, initial_balances=[{ "address": str(wallet.address()), "amount" :  "5000"}], sender=wallet)
     
    print("wallet initial cw20 MT balance: ", token_1.balance(address=str(wallet.address())))
     
    tx = token_1.transfer(amount='1000', recipient=str(wallet2.address()), sender=wallet)
    print("transferring 1000 cw20 MT tokens from wallet to wallet2")
    tx.wait_to_complete()
     
    print("wallet final cw20 MT balance: ", token_1.balance(address=str(wallet.address())))
    print("wallet2 final cw20 MT balance: ", token_1.balance(address=str(wallet2.address())))

If you paste the above code into the file `script.py` inside the project’s directory, you can run it with:

And you will observe the same output as before. You can also specify the profile as an optional argument using `--profile`.

Finally, you can pass arguments to the script just as you would to a standard Python script by placing all the arguments to the script after the `--` delimiter:

    jenesis run script.py [--profile profile_name] -- arg1 arg2 --key1 value1 --key2 value2

For a better understanding, visit the [CosmPy](https://network.fetch.ai/docs/guides/cosmpy/installation) documentation for more contract interaction examples.</content>
</page>

<page>
  <title>Versions</title>
  <url>https://network.fetch.ai/docs/guides/ledger/references/versions</url>
  <content>There are multiple versions of the `fetchd` software with differing levels of features and maturity.

The following table outlines the rough overview of these **versions**:

| Version | Maturity | Description |
| --- | --- | --- |
| v0.2.x | Deprecated | This is a stable version of the network to support agent development |
| v0.3.x | Deprecated | Builds upon our stable release and adds support for the random beacon consensus module |
| v0.4.x | Deprecated | Builds upon the random beacon consensus and adds support for aggregated signatures |
| v0.5.x | Deprecated | Extension of v0.4.x |
| v0.6.x | Deprecated | Extension of v0.5.x |
| v0.7.x | Deprecated | Pre stargate fetchhub mainnet version |
| v0.8.x | Deprecated | Mainline version of the network used for **Stargate** fetchhub mainnet |
| v0.9.x | Deprecated | Mainline version of the network used for **Capricorn** fetchhub mainnet |
| v0.10.x | Stable | Mainline version of the network used for **Dorado** fetchhub mainnet |

Upgrade history
---------------

For node operators, the full upgrade history, documentation and procedures are available [here](https://github.com/fetchai/genesis-fetchhub) .

Last updated on

May 14, 2025

[Registration and endpoints weighting](https://network.fetch.ai/docs/introduction/almanac/endpoints "Registration and endpoints weighting")</content>
</page>

<page>
  <title>Active networks</title>
  <url>https://network.fetch.ai/docs/guides/ledger/references/active-networks</url>
  <content>Main network[](#main-network)
-----------------------------

The chain identifier for our production network is **fetchhub-4**. Below you can find all of needed specifications for the **Fetch Main Network (Mainnet)**:

| Parameter | Value |
| --- | --- |
| Chain ID | fetchhub-4 |
| Block range | 5,300,202 —> |
| Date range | 05 Apr 2022, 16:00:36Z UTC —> |
| Denomination | afet |
| Decimals | 18 (1fet = 1000000000000000000afet) |
| Version | [v0.10.3](https://github.com/fetchai/fetchd/releases/tag/v0.10.3)  for blocks > 5300201, new eon (genesis upgrade) |
|  | [v0.10.4](https://github.com/fetchai/fetchd/releases/tag/v0.10.4)  for blocks > 6295500, standard software upgrade |
|  | [v0.10.5](https://github.com/fetchai/fetchd/releases/tag/v0.10.5)  for blocks > 7305500, standard software upgrade |
|  | [v0.10.7](https://github.com/fetchai/fetchd/releases/tag/v0.10.7)  for blocks > 11235678, standard software upgrade |
|  | [v0.11.3](https://github.com/fetchai/fetchd/releases/tag/v0.11.3)  for blocks > 14699873, standard software upgrade |
|  | [v0.14.0](https://github.com/fetchai/fetchd/releases/tag/v0.14.0)  for blocks > 18938999, standard software upgrade |
| RPC Endpoint | [https://rpc-fetchhub.fetch.ai:443](https://rpc-fetchhub.fetch.ai/)  |
| GRPC Endpoint | [https://grpc-fetchhub.fetch.ai:443](https://grpc-fetchhub.fetch.ai/)  |
| REST Endpoint | [https://rest-fetchhub.fetch.ai:443](https://rest-fetchhub.fetch.ai/)  |
| Block Explorer | [https://explore-fetchhub.fetch.ai](https://explore-fetchhub.fetch.ai/)  |
| Token Faucet | N/A |
| Genesis | `curl https://raw.githubusercontent.com/fetchai/genesis-fetchhub/fetchhub-4/fetchhub-4/data/genesis_migrated_5300200.json --output ~/.fetchd/config/genesis.json` |
| Seed Node(s) | [17693da418c15c95d629994a320e2c4f51a8069b@connect-fetchhub.fetch.ai](mailto:17693da418c15c95d629994a320e2c4f51a8069b@connect-fetchhub.fetch.ai):36456,[a575c681c2861fe945f77cb3aba0357da294f1f2@connect-fetchhub.fetch.ai](mailto:a575c681c2861fe945f77cb3aba0357da294f1f2@connect-fetchhub.fetch.ai):36457,[d7cda986c9f59ab9e05058a803c3d0300d15d8da@connect-fetchhub.fetch.ai](mailto:d7cda986c9f59ab9e05058a803c3d0300d15d8da@connect-fetchhub.fetch.ai):36458 |
| Snapshots | [https://storage.googleapis.com/fetch-ai-mainnet-snapshots/fetchhub-4-pruned.tgz](https://storage.googleapis.com/fetch-ai-mainnet-snapshots/fetchhub-4-pruned.tgz)    
[https://storage.googleapis.com/fetch-ai-mainnet-snapshots/fetchhub-4-full.tgz](https://storage.googleapis.com/fetch-ai-mainnet-snapshots/fetchhub-4-full.tgz)    
[https://storage.googleapis.com/fetch-ai-mainnet-snapshots/fetchhub-4-archive.tgz](https://storage.googleapis.com/fetch-ai-mainnet-snapshots/fetchhub-4-archive.tgz)   |

Test networks[](#test-networks)
-------------------------------

### Eridanus Testnet[](#eridanus-testnet)

The Eridanus testnet was forked from the dorado-1 testnet at block height 12,440,494. It is expected to be useful for developers and users to understand and test the upcoming migration of the Fetch network to the ASI network. It is expected to be stable for deploying smart contracts and testing.

Below you can find all specifications needed for the **Fetch Eridanus Test network (Testnet)**:

| Parameter | Value |
| --- | --- |
| Chain ID | eridanus-1 |
| Block range | 12,440,495 —> |
| Date range | 31 May 2024, 17:25:39 UTC —> |
| Denomination | atestasi |
| Decimals | 18 (1testasi = 1000000000000000000atestasi) |
| Min Gas Prices | 1000000000atestasi |
| Version | [v0.12.0-rc1](https://github.com/fetchai/fetchd/releases/tag/v0.12.0-rc1)  for blocks > 12440494, new eon (genesis upgrade), fork of dorado-1 |
| RPC Endpoint | [https://rpc-eridanus-1.fetch.ai:443](https://rpc-eridanus-1.fetch.ai/)  |
| GRPC Endpoint | [https://grpc-eridanus-1.fetch.ai:443](https://grpc-eridanus-1.fetch.ai/)  |
| REST Endpoint | [https://rest-eridanus-1.fetch.ai:443](https://rest-eridanus-1.fetch.ai/)  |
| Block Explorer | [https://explore-eridanus-1.fetch.ai/](https://explore-eridanus-1.fetch.ai/)  |
| Token Faucet | Use block explorer |
| Genesis | `curl https://storage.googleapis.com/fetch-ai-testnet-genesis/genesis-eridanus-12440494.json --output ~/.fetchd/config/genesis.json` |
| Seed Node(s) | [eb9b9717975b49a57e62ea93aa4480e091ae0660@connect-eridanus-1.fetch.ai](mailto:eb9b9717975b49a57e62ea93aa4480e091ae0660@connect-eridanus-1.fetch.ai):36556,[46d2f86a255ece3daf244e2ca11d5be0f16cb633@connect-eridanus-1.fetch.ai](mailto:46d2f86a255ece3daf244e2ca11d5be0f16cb633@connect-eridanus-1.fetch.ai):36557,[066fc564979b1f3173615f101b62448ac7e00eb1@connect-eridanus-1.fetch.ai](mailto:066fc564979b1f3173615f101b62448ac7e00eb1@connect-eridanus-1.fetch.ai):36558 |

### Dorado Testnet[](#dorado-testnet)

This network is running the same major version of `fetchd` as our mainnet (`fetchhub-4`), possibly at a more recent minor version.

In the short term, we will continue to provide support for this testnet. However, after the ASI migration it is expected that we will depreciate this network in favor of the Eridanus testnet.

Below you can find all specifications needed for the **Fetch Dorado Test network (Testnet)**:

| Parameter | Value |
| --- | --- |
| Chain ID | dorado-1 |
| Block range | 827,202 —> |
| Date range | 27 Apr 2022, 16:30:05 UTC —> |
| Denomination | atestfet |
| Decimals | 18 (1testfet = 1000000000000000000atestfet) |
| Min Gas Prices | 1000000000atestfet |
| Version | [v0.10.3](https://github.com/fetchai/fetchd/releases/tag/v0.10.3)  for blocks > 827201, new eon (genesis upgrade) |
|  | [v0.10.4](https://github.com/fetchai/fetchd/releases/tag/v0.10.4)  for blocks > 947800, standard software upgrade |
|  | [v0.10.5](https://github.com/fetchai/fetchd/releases/tag/v0.10.5)  for blocks > 2198000, standard software upgrade |
|  | [v0.10.7](https://github.com/fetchai/fetchd/releases/tag/v0.10.7)  for blocks > 6506910, standard software upgrade |
|  | [v0.11.2](https://github.com/fetchai/fetchd/releases/tag/v0.11.2)  for blocks > 8578263, standard software upgrade |
|  | [v0.11.3](https://github.com/fetchai/fetchd/releases/tag/v0.11.3)  for blocks > 9223305, standard software upgrade |
| RPC Endpoint | [https://rpc-dorado.fetch.ai:443](https://rpc-dorado.fetch.ai/)  |
| GRPC Endpoint | [https://grpc-dorado.fetch.ai:443](https://grpc-dorado.fetch.ai/)  |
| REST Endpoint | [https://rest-dorado.fetch.ai:443](https://rest-dorado.fetch.ai/)  |
| Block Explorer | [https://explore-dorado.fetch.ai/](https://explore-dorado.fetch.ai/)  |
| Ledger Explorer | [https://browse-dorado.fetch.ai/](https://browse-dorado.fetch.ai/)  |
| Token Faucet | Use block explorer |
| Genesis | `curl https://storage.googleapis.com/fetch-ai-testnet-genesis/genesis-dorado-827201.json --output ~/.fetchd/config/genesis.json` |
| Seed Node(s) | [eb9b9717975b49a57e62ea93aa4480e091ae0660@connect-dorado.fetch.ai](mailto:eb9b9717975b49a57e62ea93aa4480e091ae0660@connect-dorado.fetch.ai):36556,[46d2f86a255ece3daf244e2ca11d5be0f16cb633@connect-dorado.fetch.ai](mailto:46d2f86a255ece3daf244e2ca11d5be0f16cb633@connect-dorado.fetch.ai):36557,[066fc564979b1f3173615f101b62448ac7e00eb1@connect-dorado.fetch.ai](mailto:066fc564979b1f3173615f101b62448ac7e00eb1@connect-dorado.fetch.ai):36558 |
| Snapshots | [https://storage.googleapis.com/fetch-ai-testnet-snapshots/dorado-pruned.tgz](https://storage.googleapis.com/fetch-ai-testnet-snapshots/dorado-pruned.tgz)   
[https://storage.googleapis.com/fetch-ai-testnet-snapshots/dorado-full.tgz](https://storage.googleapis.com/fetch-ai-testnet-snapshots/dorado-full.tgz)   
[https://storage.googleapis.com/fetch-ai-testnet-snapshots/dorado-archive.tgz](https://storage.googleapis.com/fetch-ai-testnet-snapshots/dorado-archive.tgz)  |

Last updated on

May 14, 2025

[Registration and endpoints weighting](https://network.fetch.ai/docs/introduction/almanac/endpoints "Registration and endpoints weighting")</content>
</page>